<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>iTimeTraveler</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://github.com/"/>
  <updated>2017-08-04T05:50:51.838Z</updated>
  <id>http://github.com/</id>
  
  <author>
    <name>Mr.Seven</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【Android】源码分析 - Handler消息机制再梳理</title>
    <link href="http://github.com/2017/08/03/%E3%80%90Android%E3%80%91%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%20-%20Handler%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E5%86%8D%E6%A2%B3%E7%90%86/"/>
    <id>http://github.com/2017/08/03/【Android】源码分析 - Handler消息机制再梳理/</id>
    <published>2017-08-03T08:03:00.000Z</published>
    <updated>2017-08-04T05:50:51.838Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>多线程的消息传递处理，从初学Android时的Handler，懵懵懂懂地照猫画虎，到后来一头雾水的疑惑它为什么这么复杂，再到熟悉之后的叹为观止，一步步地都是自己踩过的足迹，都是成长啊哈哈哈。虽然离出神入化的境界还远十万八千里呢，但Android中的Handler多线程消息传递机制，的确是研发技术学习中不可多得的一个宝藏。本来我以为自己之前的学习以及比较了解 Handler，在印象中 Android 消息机制无非就是：</p>
<ol>
<li>Handler 给 MessageQueue 添加消息</li>
<li>然后 Looper 无限循环读取消息</li>
<li>再调用 Handler 处理消息</li>
</ol>
<p>但是只知道整体流程，细节还不是特别透彻。最近不甚忙碌，回头看到这块又有些许收获，我们来记录一下吧。</p>
<p>在整个Android的源码世界里，有两大利剑，其一是<strong>Binder IPC机制</strong>，另一个便是<strong>消息机制</strong>。Android有大量的消息驱动方式来进行交互，比如Android的四剑客<code>Activity</code>, <code>Service</code>, <code>Broadcast</code>, <code>ContentProvider</code>的启动过程的交互，都离不开消息机制，Android某种意义上也可以说成是一个以消息驱动的系统。而Android 消息机制主要涉及 4 个类：</p>
<ul>
<li>Handler</li>
<li>Message</li>
<li>MessageQueue</li>
<li>Looper</li>
</ul>
<p>我们依次结合源码分析一下。</p>
<a id="more"></a>
<h2 id="初学Handler"><a href="#初学Handler" class="headerlink" title="初学Handler"></a>初学Handler</h2><p>每个初学Android开发的都绕不开Handler这个“坎”，为什么说是个坎呢，首先这是Android架构的精髓之一，其次大部分人都是知其然却不知其所以然。所以决定再去翻翻源代码梳理一下Handler的实现机制。</p>
<h3 id="异步更新UI"><a href="#异步更新UI" class="headerlink" title="异步更新UI"></a>异步更新UI</h3><p>我们都知道Android中主线程就是UI线程。<strong>在主线程不能做耗时操作，而子线程不能更新UI</strong>。主线程如果耗时操作太久（超过5秒）会引起ANR。子线程更新UI，会导致线程不安全，界面的刷新不能同步，可能不起作用甚至是崩溃。详细的分析可以看这篇文章<a href="http://www.cnblogs.com/lao-liang/p/5108745.html" target="_blank" rel="external">Android子线程真的不能更新UI么？</a></p>
<p>上面这个规定应该是初学必知的，那要怎么来解决这个问题呢，这时候<code>Handler</code>就出现在我们面前了，我们也可以利用<code>AsyncTask</code>或者<code>IntentService</code>进行异步的操作。这两者又是怎么做到的呢？其实，在AsyncTask和IntentService的内部亦使用了<code>Handler</code>实现其主要功能。抛开这两者不谈，当我们打开Android源码的时候也随处可见Handler的身影。所以，Handler是Android异步操作的核心和精髓，它在众多领域发挥着极其重要甚至是不可替代的作用。我们先来一段经典常用代码（这里忽略内存泄露问题，我们后面再说）：</p>
<p>首先在Activity中新建一个handler:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> Handler mHandler = <span class="keyword">new</span> Handler() &#123;</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">		<span class="keyword">super</span>.handleMessage(msg);</div><div class="line">		<span class="keyword">switch</span> (msg.what) &#123;</div><div class="line">			<span class="keyword">case</span> <span class="number">0</span>:</div><div class="line">				mTestTV.setText(<span class="string">"This is handleMessage"</span>);	<span class="comment">//更新UI</span></div><div class="line">				<span class="keyword">break</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>然后在子线程里发送消息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Thread.sleep(<span class="number">1000</span>);	<span class="comment">//在子线程有一段耗时操作,比如请求网络</span></div><div class="line">            mHandler.sendEmptyMessage(<span class="number">0</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;).start();</div></pre></td></tr></table></figure>
<p>我们可以看到，子线程拿着主线程的<code>mHandler</code>对象调用了它的<code>sendEmptyMessage(0)</code>方法发送了一个空Message。然后主线程就更新了<code>mTestTV</code>这个TextView的内容。下面，我们就根据这段代码逐步跟踪分析一下Handler源码，梳理一下Android的这个消息机制。</p>
<h2 id="Handler源码跟踪"><a href="#Handler源码跟踪" class="headerlink" title="Handler源码跟踪"></a>Handler源码跟踪</h2><p>根据上面的Handler使用例子，我们从Handler的<code>sendEmptyMessage()</code>方法这里开始，翻看Handler的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendEmptyMessage</span><span class="params">(<span class="keyword">int</span> what)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> sendEmptyMessageDelayed(what, <span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendEmptyMessageDelayed</span><span class="params">(<span class="keyword">int</span> what, <span class="keyword">long</span> delayMillis)</span> </span>&#123;</div><div class="line">    Message msg = Message.obtain();</div><div class="line">    msg.what = what;</div><div class="line">    <span class="keyword">return</span> sendMessageDelayed(msg, delayMillis);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessageDelayed</span><span class="params">(Message msg, <span class="keyword">long</span> delayMillis)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (delayMillis &lt; <span class="number">0</span>) &#123;</div><div class="line">        delayMillis = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以看到，最后调用了<code>sendMessageAtTime()</code>方法，我们接着看这个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtTime</span><span class="params">(Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</div><div class="line">    MessageQueue queue = mQueue;	<span class="comment">//拿到MessageQueue队列对象</span></div><div class="line">    <span class="keyword">if</span> (queue == <span class="keyword">null</span>) &#123;</div><div class="line">        RuntimeException e = <span class="keyword">new</span> RuntimeException(</div><div class="line">                <span class="keyword">this</span> + <span class="string">" sendMessageAtTime() called with no mQueue"</span>);</div><div class="line">        Log.w(<span class="string">"Looper"</span>, e.getMessage(), e);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">  	<span class="comment">//把msg对象入队</span></div><div class="line">    <span class="keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>也就是说，目前我们看到的Handler的<code>sendEmptyMessage()</code>方法调用逻辑如下图：</p>
<p><img src="/gallery/android-handler/java_sendmessage.png" alt="Handler的sendEmptyMessage()方法调用逻辑"></p>
<p>最后这个<code>sendMessageAtTime()</code>方法我们看到两个亮点：</p>
<ul>
<li>第一步，<strong>首先拿到消息队列<code>MessageQueue</code>类型的<code>mQueue</code>对象</strong>。</li>
<li>第二步，<strong>把消息<code>Message</code>类型的实例<code>msg</code>对象入队</strong>。</li>
</ul>
<p>接下来，我们就沿着这两个问题分别往下跟踪。</p>
<h2 id="MessageQueue对象从哪里来"><a href="#MessageQueue对象从哪里来" class="headerlink" title="MessageQueue对象从哪里来"></a>MessageQueue对象从哪里来</h2><p>我们先来看<code>mQueue</code>这个MessageQueue对象哪来的呢？我们找到了赋值的地方，原来在Handler的构造函数里：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (FIND_POTENTIAL_LEAKS) &#123;</div><div class="line">        <span class="keyword">final</span> Class&lt;? extends Handler&gt; klass = getClass();</div><div class="line">        <span class="keyword">if</span> ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;</div><div class="line">                (klass.getModifiers() &amp; Modifier.STATIC) == <span class="number">0</span>) &#123;</div><div class="line">            Log.w(TAG, <span class="string">"The following Handler class should be static or leaks might occur: "</span> +</div><div class="line">                klass.getCanonicalName());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    mLooper = Looper.myLooper();	<span class="comment">//使用Looper.myLooper()取到了mLooper对象</span></div><div class="line">    <span class="keyword">if</span> (mLooper == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</div><div class="line">            <span class="string">"Can't create handler inside thread that has not called Looper.prepare()"</span>);</div><div class="line">    &#125;</div><div class="line">    mQueue = mLooper.mQueue;	<span class="comment">//原来消息队列来自mLooper对象里的mQueue</span></div><div class="line">    mCallback = callback;</div><div class="line">    mAsynchronous = async;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>原来<code>mQueue</code>这个对象是从<code>Looper</code>这个对象中获取的，同时我们看到是通过<code>Looper.myLooper()</code>获取到Looper对象的。也就是说每个Looper拥有一个消息队列<code>MessageQueue</code>对象。我们在Looper的构造函数里看到是它new了一个MessageQueue：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> MessageQueue mQueue;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="title">Looper</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</div><div class="line">    mQueue = <span class="keyword">new</span> MessageQueue(quitAllowed);	<span class="comment">//初始化MessageQueue对象</span></div><div class="line">    mThread = Thread.currentThread();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们紧接着再进入Looper类中的<code>myLooper()</code>方法看看如何得到Looper实例对象的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Return the Looper object associated with the current thread.  Returns</div><div class="line"> * null if the calling thread is not associated with a Looper.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Looper <span class="title">myLooper</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> sThreadLocal.get();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// sThreadLocal.get() will return null unless you've called prepare().</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Looper&gt; sThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;Looper&gt;();</div></pre></td></tr></table></figure>
<p>原来这个looper对象是从一个<code>ThreadLocal</code>线程本地存储TLS对象中取到的，而且这个实例声明上面我们可以看到一行注释：<strong>如果不提前调用<code>prepare()</code>方法的话<code>sThreadLocal.get()</code>可能返回null</strong>。</p>
<p>我们来看看这个<code>prepare()</code>方法到底干了什么：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</div><div class="line">	 <span class="comment">//每个线程只允许执行一次该方法，第二次执行时线程的TLS已有数据，则会抛出异常。</span></div><div class="line">    <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//创建Looper对象，并保存到当前线程的TLS区域</span></div><div class="line">    sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>原来是给<code>ThreadLocal</code>线程本地存储TLS对象set了一个新的Looper对象。换句话说，就是new了一个Looper对象然后保存在了线程本地存储区里了。而这个<code>ThreadLocal</code>线程本地存储对象就是每个线程专有的变量，可以理解成线程的自有变量保存区。我们这里不作深入介绍，只用理解每个线程可以通过<code>Looper.prepare()</code>方法new一个Looper对象保存起来，然后就可以拥有一个Looper了。这也就是我们在非UI线程中使用Handler之前必须首先调用<code>Looper.prepare()</code>方法的根本原因。</p>
<blockquote>
<p><strong>插播</strong>：<code>ThreadLocal</code>类实现一个线程本地的存储，也就是说，每个线程都有自己的局部变量。所有线程都共享一个ThreadLocal对象，但是每个线程在访问这些变量的时候能得到不同的值，每个线程可以更改这些变量并且不会影响其他的线程，并且支持null值。详细介绍可以看看这里：<a href="http://www.cnblogs.com/whoislcj/p/5811989.html" target="_blank" rel="external">Android线程管理之ThreadLocal理解及应用场景</a></p>
</blockquote>
<p>比如我们在Activity的onCreate()方法中写一段这样的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">    setContentView(R.layout.activity_main);</div><div class="line"></div><div class="line">    Handler h1 = <span class="keyword">new</span> Handler();</div><div class="line"></div><div class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            Handler h2 = <span class="keyword">new</span> Handler();		<span class="comment">//直接在子线程中new一个Handler</span></div><div class="line">        &#125;</div><div class="line">    &#125;).start();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行之后h1正常创建，但是创建h2的时候crash了：</p>
<blockquote>
<p>——— beginning of crash<br>E/AndroidRuntime: FATAL EXCEPTION: Thread-263<br>Process: com.example.stone.sfsandroidclient, PID: 32286<br>java.lang.RuntimeException: <strong>Can’t create handler inside thread that has not called Looper.prepare()</strong><br>   at android.os.Handler.<init>(Handler.java:200)<br>   at android.os.Handler.<init>(Handler.java:114)<br>   at com.example.stone.sfsandroidclient.MainActivity$1.run(MainActivity.java:71)<br>   at java.lang.Thread.run(Thread.java:818)</init></init></p>
</blockquote>
<p>很明显，出错日志提示<strong>不能在一个没有调用过<code>Looper.prepare()</code>的Thread里边<code>new Handler()</code></strong>。</p>
<p>看到了这里有一个疑惑，那就是我们在文章开头的示例代码中新建<code>mHandler</code>的时候并没有调用<code>Looper.prepare()</code>方法，那Looper的创建以及方法调用在哪里呢？其实这些东西Android本身已经帮我们做了，在程序入口<strong>ActivityThread</strong>的main方法里面我们可以找到：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    ...</div><div class="line">    Looper.prepareMainLooper();		<span class="comment">//这里等同于Looper.prepare()</span></div><div class="line">    ...</div><div class="line">    Looper.loop();</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Message对象如何入队"><a href="#Message对象如何入队" class="headerlink" title="Message对象如何入队"></a>Message对象如何入队</h2><p>我们明白了MessageQueue消息队列对象是来自于ThreadLocal线程本地存储区存储的那个唯一的Looper对象。我们接着看<strong>Handler</strong>在发送消息的最后调用的<code>enqueueMessage()</code>方法，看名字应该是把消息加入队列的意思，点进去看下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(MessageQueue queue, Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</div><div class="line">    msg.target = <span class="keyword">this</span>;		<span class="comment">//注意此处Handler把自己this赋值给了Message的target变量</span></div><div class="line">    <span class="keyword">if</span> (mAsynchronous) &#123;</div><div class="line">        msg.setAsynchronous(<span class="keyword">true</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们看到msg的target的赋值是Handler自己，也就是说这个<code>msg</code>实例对象现在持有了主线程中<code>mHandler</code>这个对象。注意这里，我们稍后会讲到<code>msg</code>持有这个<code>mHandler</code>对象的用途。最后调用了<code>MessageQueue</code>类的<code>enqueueMessage()</code>方法加入到了消息队列。</p>
<p>看来真正的入队方法交给了<strong>MessageQueue</strong>，这个<code>enqueueMessage()</code>方法较长，我们现在继续进入看看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(Message msg, <span class="keyword">long</span> when)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (msg.target == <span class="keyword">null</span>) &#123;    <span class="comment">//这里要求消息必须跟 Handler 关联</span></div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Message must have a target."</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (msg.isInUse()) &#123;    </div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(msg + <span class="string">" This message is already in use."</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (mQuitting) &#123;    <span class="comment">//如果消息队列已经退出，还入队就报错</span></div><div class="line">            IllegalStateException e = <span class="keyword">new</span> IllegalStateException(</div><div class="line">                    msg.target + <span class="string">" sending message to a Handler on a dead thread"</span>);</div><div class="line">            Log.w(TAG, e.getMessage(), e);</div><div class="line">            msg.recycle();</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        msg.markInUse();    <span class="comment">//消息入队后就标记为 在被使用</span></div><div class="line">        msg.when = when;</div><div class="line">        Message p = mMessages;</div><div class="line">        <span class="keyword">boolean</span> needWake;</div><div class="line">        <span class="comment">//添加消息到链表中</span></div><div class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;    </div><div class="line">            <span class="comment">//之前是空链表的时候读取消息会阻塞，新添加消息后唤醒</span></div><div class="line">            msg.next = p;</div><div class="line">            mMessages = msg;</div><div class="line">            needWake = mBlocked;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">//插入消息到队列时，只有在队列头部有个屏障并且当前消息是异步的时才需要唤醒队列</span></div><div class="line">            needWake = mBlocked &amp;&amp; p.target == <span class="keyword">null</span> &amp;&amp; msg.isAsynchronous();</div><div class="line">            Message prev;</div><div class="line">            <span class="keyword">for</span> (;;) &#123;</div><div class="line">                prev = p;</div><div class="line">                p = p.next;</div><div class="line">                <span class="keyword">if</span> (p == <span class="keyword">null</span> || when &lt; p.when) &#123;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</div><div class="line">                    needWake = <span class="keyword">false</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            msg.next = p; <span class="comment">// invariant: p == prev.next</span></div><div class="line">            prev.next = msg;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// We can assume mPtr != 0 because mQuitting is false.</span></div><div class="line">        <span class="keyword">if</span> (needWake) &#123;</div><div class="line">            nativeWake(mPtr);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到一个无限循环将消息加入到消息队列中（链表的形式），但是有放就有拿，这个消息怎样把它取出来呢？</p>
<p>翻看<code>MessageQueue</code>的方法，我们找到了<code>next()</code>方法，也就是出队方法。这个方法代码太长，可以不用细看我们知道它是用来把消息取出来的就行了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div></pre></td><td class="code"><pre><div class="line"><span class="function">Message <span class="title">next</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">//如果消息的 looper 退出，就退出这个方法</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">long</span> ptr = mPtr;</div><div class="line">    <span class="keyword">if</span> (ptr == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> pendingIdleHandlerCount = -<span class="number">1</span>; <span class="comment">// -1 only during first iteration</span></div><div class="line">    <span class="keyword">int</span> nextPollTimeoutMillis = <span class="number">0</span>;</div><div class="line">    <span class="comment">//也是一个循环，有合适的消息就返回，没有就阻塞</span></div><div class="line">    <span class="keyword">for</span> (;;) &#123;</div><div class="line">        <span class="keyword">if</span> (nextPollTimeoutMillis != <span class="number">0</span>) &#123;    <span class="comment">//如果有需要过段时间再处理的消息，先调用 Binder 的这个方法</span></div><div class="line">            Binder.flushPendingCommands();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        nativePollOnce(ptr, nextPollTimeoutMillis);</div><div class="line"></div><div class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">            <span class="comment">//获取下一个消息</span></div><div class="line">            <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</div><div class="line">            Message prevMsg = <span class="keyword">null</span>;</div><div class="line">            Message msg = mMessages;    <span class="comment">//当前链表的头结点</span></div><div class="line">            <span class="keyword">if</span> (msg != <span class="keyword">null</span> &amp;&amp; msg.target == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="comment">//如果消息没有 target，那它就是一个屏障，需要一直往后遍历找到第一个异步的消息</span></div><div class="line">                                do &#123;</div><div class="line">                    prevMsg = msg;</div><div class="line">                    msg = msg.next;</div><div class="line">                &#125; <span class="keyword">while</span> (msg != <span class="keyword">null</span> &amp;&amp; !msg.isAsynchronous());</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">if</span> (now &lt; msg.when) &#123;    <span class="comment">//如果这个消息还没到处理时间，就设置个时间过段时间再处理</span></div><div class="line">                    nextPollTimeoutMillis = (<span class="keyword">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="comment">// 消息是正常的、可以立即处理的</span></div><div class="line">                    mBlocked = <span class="keyword">false</span>;</div><div class="line">                    <span class="comment">//取出当前消息，链表头结点后移一位</span></div><div class="line">                    <span class="keyword">if</span> (prevMsg != <span class="keyword">null</span>) &#123;</div><div class="line">                        prevMsg.next = msg.next;</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        mMessages = msg.next;</div><div class="line">                    &#125;</div><div class="line">                    msg.next = <span class="keyword">null</span>;</div><div class="line">                    <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">"Returning message: "</span> + msg);</div><div class="line">                    msg.markInUse();    <span class="comment">//标记这个消息在被使用</span></div><div class="line">                    <span class="keyword">return</span> msg;</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// 消息链表里没有消息了</span></div><div class="line">                nextPollTimeoutMillis = -<span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">//如果收到退出的消息，并且所有等待处理的消息都处理完时，调用 Native 方法销毁队列</span></div><div class="line">                        <span class="keyword">if</span> (mQuitting) &#123;</div><div class="line">                dispose();</div><div class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">//有消息等待过段时间执行时，pendingIdleHandlerCount 增加</span></div><div class="line">            <span class="keyword">if</span> (pendingIdleHandlerCount &lt; <span class="number">0</span></div><div class="line">                    &amp;&amp; (mMessages == <span class="keyword">null</span> || now &lt; mMessages.when)) &#123;</div><div class="line">                pendingIdleHandlerCount = mIdleHandlers.size();</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (pendingIdleHandlerCount &lt;= <span class="number">0</span>) &#123;</div><div class="line">                mBlocked = <span class="keyword">true</span>;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (mPendingIdleHandlers == <span class="keyword">null</span>) &#123;</div><div class="line">                mPendingIdleHandlers = <span class="keyword">new</span> IdleHandler[Math.max(pendingIdleHandlerCount, <span class="number">4</span>)];</div><div class="line">            &#125;</div><div class="line">            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;</div><div class="line">            <span class="keyword">final</span> IdleHandler idler = mPendingIdleHandlers[i];</div><div class="line">            mPendingIdleHandlers[i] = <span class="keyword">null</span>; <span class="comment">// release the reference to the handler</span></div><div class="line"></div><div class="line">            <span class="keyword">boolean</span> keep = <span class="keyword">false</span>;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                keep = idler.queueIdle();</div><div class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">                Log.wtf(TAG, <span class="string">"IdleHandler threw exception"</span>, t);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (!keep) &#123;</div><div class="line">                <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">                    mIdleHandlers.remove(idler);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Reset the idle handler count to 0 so we do not run them again.</span></div><div class="line">        pendingIdleHandlerCount = <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="comment">// While calling an idle handler, a new message could have been delivered</span></div><div class="line">        <span class="comment">// so go back and look again for a pending message without waiting.</span></div><div class="line">        nextPollTimeoutMillis = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，<code>MessageQueue.next()</code> 方法里有一个循环，在这个循环中遍历消息链表，找到下一个可以处理的、<code>target</code> 不为空的消息并且执行时间不在未来的消息，就返回，否则就继续往后找。</p>
<p>如果有阻塞（没有消息了或者只有 Delay 的消息），会把 <code>mBlocked</code>这个变量标记为 <code>true</code>，在下一个 Message 进队时会判断这个<code>message</code> 的位置，如果在队首就会调用<code>nativeWake()</code> 方法唤醒线程！</p>
<p>不过<code>MessageQueue.next()</code> 这个方法是在什么地方调用的呢，不是在<code>Handler</code>中，我们找到了<strong><code>Looper</code></strong>这个关键人物，专门负责从消息队列中拿消息。</p>
<h2 id="Looper如何处理Message"><a href="#Looper如何处理Message" class="headerlink" title="Looper如何处理Message"></a>Looper如何处理Message</h2><p>我们又来到了<code>Looper</code>的阵地，他在调用MessageQueue的<code>next()</code>方法，来从消息队列中拿Message对象，关键代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Run the message queue in this thread. Be sure to call</div><div class="line"> * &#123;<span class="doctag">@link</span> #quit()&#125; to end the loop.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Looper me = myLooper();</div><div class="line">    <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;    <span class="comment">//当前线程必须创建 Looper 才可以执行</span></div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No Looper; Looper.prepare() wasn't called on this thread."</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">final</span> MessageQueue queue = me.mQueue;</div><div class="line"></div><div class="line">    <span class="comment">//底层对 IPC 标识的处理，不用关心 </span></div><div class="line">    Binder.clearCallingIdentity();</div><div class="line">    <span class="keyword">final</span> <span class="keyword">long</span> ident = Binder.clearCallingIdentity();</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (;;) &#123;    <span class="comment">//无限循环模式</span></div><div class="line">        Message msg = queue.next(); <span class="comment">//从消息队列中读取消息，可能会阻塞</span></div><div class="line">        <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;    <span class="comment">//当消息队列中没有消息时就会返回，不过这只发生在 queue 退出的时候</span></div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//...</span></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            msg.target.dispatchMessage(msg);    <span class="comment">//调用消息关联的 Handler 处理消息</span></div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            <span class="keyword">if</span> (traceTag != <span class="number">0</span>) &#123;</div><div class="line">                Trace.traceEnd(traceTag);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//...</span></div><div class="line">        msg.recycleUnchecked();    <span class="comment">//标记这个消息被回收</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，<code>Looper.loop()</code> 也很简单，就是调用消息队列 <code>MessageQueue.next()</code> 方法取消息，如果没有消息的话会阻塞，直到有新的消息进入或者消息队列退出。也就是不断重复下面的操作，直到没有消息时退出循环</p>
<ul>
<li>读取MessageQueue的下一条<strong>Message</strong>；</li>
<li>把Message分发给相应的<strong>target</strong>；</li>
<li>再把分发后的Message回收到消息池，以便重复利用。</li>
</ul>
<p>拿到消息后调用<code>msg.target</code>的<code>dispatchMessage(msg)</code>方法，而这个<code>msg.target</code>是什么呢？就是前面<code>Handler</code>发送消息<code>sendMessageAtTime()</code>时把自己赋值给<code>msg.target</code>的主线程的<code>mHandler</code>对象。也就是说，最后还是 Handler 负责处理消息。可以看到，<strong>Looper 并没有执行消息，真正执行消息的还是添加消息到队列中的那个 Handler</strong>。</p>
<p><img src="/gallery/android-handler/looper.png" alt="Looper处理Message的大致流程"></p>
<p>所以我们来看Handler中的<code>dispatchMessage(msg)</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Handle system messages here.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</div><div class="line">        handleCallback(msg);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        handleMessage(msg);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleCallback</span><span class="params">(Message message)</span> </span>&#123;</div><div class="line">    message.callback.run();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，Handler 在处理消息时，会有三种情况：</p>
<ol>
<li><strong>msg.callback 不为空</strong> <ul>
<li>这在使用 <code>Handler.postXXX(Runnable)</code> 发送消息的时候会发生</li>
<li>这就直接调用 Runnable 的 run() 方法</li>
</ul>
</li>
<li><strong>mCallback 不为空</strong> <ul>
<li>这在我们使用前面介绍的 Handler.Callback 为参数构造 Handler 时会发生</li>
<li>那就调用构造函数里传入的 <code>handleMessage()</code> 方法</li>
<li>如果返回 true，那就不往下走了</li>
</ul>
</li>
<li><strong>最后就调用<code>Handler.handleMessage()</code> 方法</strong><ul>
<li>这是一个空实现，需要我们在 Handler 子类里重写</li>
</ul>
</li>
</ol>
<p>而我们开头的例子，使用的就是第3种方法，大家可以回顾一下。</p>
<p><img src="/gallery/android-handler/0_1327991304aZK7.jpg" alt="子线程向主线程中发送UI更新消息的整体流程"></p>
<p>到这里，我们的疑问基本上就解决了，虽然没有再深入到jni层看native底层实现，但是java层的机制我们大概明白了。最后我们对上面的源码跟踪分析做一个宏观上的总结。</p>
<h2 id="整体运行机制"><a href="#整体运行机制" class="headerlink" title="整体运行机制"></a>整体运行机制</h2><h3 id="四大主角"><a href="#四大主角" class="headerlink" title="四大主角"></a>四大主角</h3><p>与Windows系统一样，Android也是消息驱动型的系统。引用一下消息驱动机制的四要素：</p>
<ul>
<li>接收消息的“消息队列”</li>
<li>阻塞式地从消息队列中接收消息并进行处理的“线程”</li>
<li>可发送的“消息的格式”</li>
<li>“消息发送函数”</li>
</ul>
<p>与之对应，Android中的实现对应了</p>
<ul>
<li>接收消息的“消息队列” ——【MessageQueue】</li>
<li>阻塞式地从消息队列中接收消息并进行处理的“线程” ——【Thread+Looper】</li>
<li>可发送的“消息的格式” ——【Message】</li>
<li>“消息发送函数”——【Handler的post和sendMessage】</li>
</ul>
<p>也就是说，消息机制主要包含以下四个主角：</p>
<ul>
<li><strong>Message</strong>：消息分为硬件产生的消息（如按钮、触摸）和软件生成的消息；</li>
<li><strong>MessageQueue</strong>：消息队列的主要功能向消息池投递消息（<code>MessageQueue.enqueueMessage()</code>）和取走消息池的消息（<code>MessageQueue.next()</code>）；</li>
<li><strong>Handler</strong>：消息辅助类，主要功能向消息池发送各种消息事件（<code>Handler.sendMessage()</code>）和处理相应消息事件（<code>Handler.handleMessage()</code>）；</li>
<li><strong>Looper</strong>：不断循环执行（<code>Looper.loop()</code>），按分发机制将消息分发给目标处理者。</li>
</ul>
<p>他们之间的关系如下：</p>
<ul>
<li><strong>Thread</strong>：一个线程有唯一一个对应的Looper；</li>
<li><strong>Looper</strong>：有一个MessageQueue消息队列；</li>
<li><strong>MessageQueue</strong>：有一组待处理的Message；</li>
<li><strong>Message</strong>中有一个用于处理消息的Handler；</li>
<li><strong>Handler</strong>中有Looper和MessageQueue。</li>
</ul>
<h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p><img src="/gallery/android-handler/1836169-c13aab3f58697aaa.png" alt=""></p>
<p>一个<code>Looper</code>类似一个消息泵。它本身是一个死循环，不断地从<code>MessageQueue</code>中提取<code>Message</code>或者Runnable。而<code>Handler</code>可以看做是一个<code>Looper</code>的暴露接口，向外部暴露一些事件，并暴露<code>sendMessage()</code>和<code>post()</code>函数。</p>
<p>在安卓中，除了<code>UI线程</code>/<code>主线程</code>以外，普通的线程(先不提<code>HandlerThread</code>)是不自带<code>Looper</code>的。想要通过UI线程与子线程通信需要在子线程内自己实现一个<code>Looper</code>。开启Looper分<strong>三步走</strong>：</p>
<ol>
<li>判定是否已有<code>Looper</code>并<code>Looper.prepare()</code></li>
<li>做一些准备工作(如暴露handler等)</li>
<li>调用<code>Looper.loop()</code>，线程进入阻塞态</li>
</ol>
<p>由于每一个线程内最多只可以有一个<code>Looper</code>，所以一定要在<code>Looper.prepare()</code>之前做好判定，否则会抛出<code>java.lang.RuntimeException: Only one Looper may be created per thread</code>。为了获取Looper的信息可以使用两个方法：</p>
<ul>
<li>Looper.myLooper()</li>
<li>Looper.getMainLooper()</li>
</ul>
<p><code>Looper.myLooper()</code>获取当前线程绑定的Looper，如果没有返回<code>null</code>。<code>Looper.getMainLooper()</code>返回主线程的<code>Looper</code>,这样就可以方便的与主线程通信。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><code>Looper</code>调用<code>prepare()</code>进行初始化，创建了一个与当前线程对应的<code>Looper</code>对象（通过<code>ThreadLocal</code>实现），并且初始化了一个与当前<code>Looper</code>对应的<code>MessageQueue</code>对象。</li>
<li><code>Looper</code>调用静态方法<code>loop()</code>开始消息循环，通过<code>MessageQueue.next()</code>方法获取<code>Message</code>对象。</li>
<li>当获取到一个<code>Message</code>对象时，让<code>Message</code>的发送者（<code>target</code>）去处理它。</li>
<li><code>Message</code>对象包括数据，发送者（<code>Handler</code>），可执行代码段（<code>Runnable</code>）三个部分组成。</li>
<li><code>Handler</code>可以在一个已经<code>Looper.prepare()</code>的线程中初始化，如果线程没有初始化<code>Looper</code>，创建<code>Handler</code>对象会失败</li>
<li>一个线程的执行流中可以构造多个<code>Handler</code>对象，它们都往同一个MQ中发消息，消息也只会分发给对应的<code>Handler</code>处理。</li>
<li><code>Handler</code>将消息发送到MQ中，<code>Message</code>的<code>target</code>域会引用自己的发送者，<code>Looper</code>从MQ中取出来后，再交给发送这个<code>Message</code>的<code>Handler</code>去处理。</li>
<li><code>Message</code>可以直接添加一个<code>Runnable</code>对象，当这条消息被处理的时候，直接执行<code>Runnable.run()</code>方法。</li>
</ul>
<h2 id="Handler的内存泄露问题"><a href="#Handler的内存泄露问题" class="headerlink" title="Handler的内存泄露问题"></a>Handler的内存泄露问题</h2><p>再来看看我们的新建Handler的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> Handler mHandler = <span class="keyword">new</span> Handler() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><strong>当使用内部类（包括匿名类）来创建Handler的时候，Handler对象会隐式地持有Activity的引用。</strong></p>
<p>而Handler通常会伴随着一个耗时的后台线程一起出现，这个后台线程在任务执行完毕后发送消息去更新UI。然而，如果用户在网络请求过程中关闭了Activity，正常情况下，Activity不再被使用，它就有可能在GC检查时被回收掉，但由于这时线程尚未执行完，而该线程持有Handler的引用（不然它怎么发消息给Handler？），这个Handler又持有Activity的引用，就导致该Activity无法被回收（即内存泄露），直到网络请求结束。</p>
<p>另外，如果执行了Handler的postDelayed()方法，那么在设定的delay到达之前，会有一条<strong>MessageQueue -&gt; Message -&gt; Handler -&gt; Activity</strong>的链，导致你的Activity被持有引用而无法被回收。</p>
<p>解决方法之一，使用弱引用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</div><div class="line">    WeakReference&lt;Activity &gt; mActivityReference;</div><div class="line">    MyHandler(Activity activity) &#123;</div><div class="line">        mActivityReference= <span class="keyword">new</span> WeakReference&lt;Activity&gt;(activity);</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> Activity activity = mActivityReference.get();</div><div class="line">        <span class="keyword">if</span> (activity != <span class="keyword">null</span>) &#123;</div><div class="line">            mImageView.setImageBitmap(mBitmap);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从JDK1.2开始，Java把对象的引用分为四种级别，这四种级别由高到低依次为：强引用、软引用、弱引用和虚引用。</p>
<ol>
<li><p><strong>强引用</strong>：我们一般使用的就是强引用，垃圾回收器一般都不会对其进行回收操作。当内存空间不足时Java虚拟机宁愿抛出OutOfMemoryError错误使程序异常终止，也不会回收具有强引用的对象。</p>
</li>
<li><p><strong>软引用(SoftReference)</strong>：如果一个对象具有软引用(SoftReference)，在内存空间足够的时候GC不会回收它，如果内存空间不足了GC就会回收这些对象的内存空间。</p>
</li>
<li><p><strong>弱引用(WeakReference)</strong> ：如果一个对象具有弱引用(WeakReference)，那么当GC线程扫描的过程中一旦发现某个对象只具有弱引用而不存在强引用时不管当前内存空间足够与否GC都会回收它的内存。由于垃圾回收器是一个优先级较低的线程，所以不一定会很快发现那些只具有弱引用的对象。为了防止内存溢出，在处理一些占用内存大而且生命周期较长的对象时候，可以尽量使用软引用和弱引用。</p>
</li>
<li><p><strong>虚引用(PhantomReference)</strong> ：虚引用(PhantomReference)与其他三种引用都不同，它并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。所以，虚引用主要用来跟踪对象被垃圾回收器回收的活动，在一般的开发中并不会使用它。</p>
</li>
</ol>
<h2 id="进程、线程间通信方式"><a href="#进程、线程间通信方式" class="headerlink" title="进程、线程间通信方式"></a>进程、线程间通信方式</h2><p>文章最后，我们来整理一下进程、线程间通信方式，参考<a href="http://www.cnblogs.com/xh0102/p/5710074.html" target="_blank" rel="external">线程通信与进程通信的区别</a>。看看Handler消息传递机制属于哪种？</p>
<h3 id="一、进程间的通信方式"><a href="#一、进程间的通信方式" class="headerlink" title="一、进程间的通信方式"></a>一、进程间的通信方式</h3><ul>
<li><strong>管道( pipe )</strong>：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。</li>
<li><strong>有名管道 (namedpipe)</strong> ： 有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。</li>
<li><strong>信号量(semophore )</strong> ： 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</li>
<li><strong>消息队列( messagequeue )</strong> ： 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</li>
<li><strong>信号 (sinal )</strong> ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</li>
<li><strong>共享内存(shared memory )</strong> ：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。</li>
<li><strong>套接字(socket )</strong> ： 套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。</li>
</ul>
<table>
<thead>
<tr>
<th><strong>IPC</strong></th>
<th><strong>数据拷贝次数</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>共享内存</td>
<td>0</td>
</tr>
<tr>
<td>Android Binder</td>
<td>1</td>
</tr>
<tr>
<td>Socket/管道/消息队列</td>
<td>2</td>
</tr>
</tbody>
</table>
<h3 id="二、线程间的通信方式"><a href="#二、线程间的通信方式" class="headerlink" title="二、线程间的通信方式"></a>二、线程间的通信方式</h3><ul>
<li><strong>锁机制</strong>：包括互斥锁、条件变量、读写锁<ol>
<li>互斥锁提供了以排他方式防止数据结构被并发修改的方法。</li>
<li>读写锁允许多个线程同时读共享数据，而对写操作是互斥的。</li>
<li>条件变量可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。</li>
</ol>
</li>
<li><strong>信号量机制(Semaphore)</strong>：包括无名线程信号量和命名线程信号量</li>
<li><strong>信号机制(Signal)</strong>：类似进程间的信号处理</li>
</ul>
<p>线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制。</p>
<blockquote>
<p>很明显，Android的Handler消息机制使用消息队列( MessageQueue )实现的线程间通信方式。而Binder是Android建立额一套新的IPC机制来满足系统对通信方式，传输性能和安全性的要求。<strong>Binder基于Client-Server通信模式，传输过程只需一次拷贝，为发送发添加UID/PID身份，既支持实名Binder也支持匿名Binder，安全性高。</strong>此处就不对Binder作更多介绍了。</p>
</blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://gityuan.com/2015/12/26/handler-message-framework/" target="_blank" rel="external">Android消息机制1-Handler(Java层)</a></li>
<li><a href="http://blog.csdn.net/ly502541243/article/details/52062179/" target="_blank" rel="external">从Handler.post(Runnable r)再一次梳理Android的消息机制</a></li>
<li><a href="http://blog.csdn.net/u011240877/article/details/72892321" target="_blank" rel="external"><a href="http://blog.csdn.net/u011240877/article/details/72892321" target="_blank" rel="external">Android 进阶14：源码解读 Android 消息机制（ Message MessageQueue Handler Looper）</a></a></li>
<li><a href="http://www.jianshu.com/p/10dd4d605d40" target="_blank" rel="external">Android源码：Handler, Looper和MessageQueue实现解析</a></li>
<li><a href="http://www.androidchina.net/6053.html" target="_blank" rel="external">深入探讨Android异步精髓Handler</a></li>
<li><a href="https://hzj163.gitbooks.io/android-thread/content/androidxiao_xi_ji_zhi.html" target="_blank" rel="external">Android消息机制</a></li>
<li><a href="https://hit-alibaba.github.io/interview/Android/basic/Android-handler-thread-looper.html" target="_blank" rel="external">哈工大面试指导：Android中的Thread, Looper和Handler机制</a></li>
<li><a href="http://blog.csdn.net/fenggit/article/details/50766820" target="_blank" rel="external">Android 线程本地变量&lt;一&gt; ThreadLocal源码解析</a></li>
<li><a href="http://www.cnblogs.com/whoislcj/p/5811989.html" target="_blank" rel="external">Android线程管理之ThreadLocal理解及应用场景</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;多线程的消息传递处理，从初学Android时的Handler，懵懵懂懂地照猫画虎，到后来一头雾水的疑惑它为什么这么复杂，再到熟悉之后的叹为观止，一步步地都是自己踩过的足迹，都是成长啊哈哈哈。虽然离出神入化的境界还远十万八千里呢，但Android中的Handler多线程消息传递机制，的确是研发技术学习中不可多得的一个宝藏。本来我以为自己之前的学习以及比较了解 Handler，在印象中 Android 消息机制无非就是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Handler 给 MessageQueue 添加消息&lt;/li&gt;
&lt;li&gt;然后 Looper 无限循环读取消息&lt;/li&gt;
&lt;li&gt;再调用 Handler 处理消息&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;但是只知道整体流程，细节还不是特别透彻。最近不甚忙碌，回头看到这块又有些许收获，我们来记录一下吧。&lt;/p&gt;
&lt;p&gt;在整个Android的源码世界里，有两大利剑，其一是&lt;strong&gt;Binder IPC机制&lt;/strong&gt;，另一个便是&lt;strong&gt;消息机制&lt;/strong&gt;。Android有大量的消息驱动方式来进行交互，比如Android的四剑客&lt;code&gt;Activity&lt;/code&gt;, &lt;code&gt;Service&lt;/code&gt;, &lt;code&gt;Broadcast&lt;/code&gt;, &lt;code&gt;ContentProvider&lt;/code&gt;的启动过程的交互，都离不开消息机制，Android某种意义上也可以说成是一个以消息驱动的系统。而Android 消息机制主要涉及 4 个类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Handler&lt;/li&gt;
&lt;li&gt;Message&lt;/li&gt;
&lt;li&gt;MessageQueue&lt;/li&gt;
&lt;li&gt;Looper&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们依次结合源码分析一下。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://github.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://github.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>连通图的最大生成树的权和</title>
    <link href="http://github.com/2017/07/31/Google%20%E7%AC%94%E8%AF%95%E9%A2%98%20-%20%E8%BF%9E%E9%80%9A%E5%9B%BE%E7%9A%84%E6%9C%80%E5%A4%A7%E7%94%9F%E6%88%90%E6%A0%91%E7%9A%84%E6%9D%83%E5%92%8C/"/>
    <id>http://github.com/2017/07/31/Google 笔试题 - 连通图的最大生成树的权和/</id>
    <published>2017-07-31T09:20:55.000Z</published>
    <updated>2017-08-01T02:27:59.366Z</updated>
    
    <content type="html"><![CDATA[<p>这是一道Google 笔试题</p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>一个有n个结点的连通图的生成树是原图的最小连通子图, 且包含原图中所有n个结点，并且有保持图联通的最少的边。最大生成树就是权和最大生成树，现在给出一个无向带权图的邻接矩阵，权为0表示没有边。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;&#123;0, 4, 5, 0, 3&#125;, </div><div class="line"> &#123;4, 0, 4, 2, 3&#125;, </div><div class="line"> &#123;5, 4, 0, 2, 0&#125;, </div><div class="line"> &#123;0, 2, 2, 0, 1&#125;, </div><div class="line"> &#123;3, 3, 0, 1, 0&#125;&#125;</div></pre></td></tr></table></figure></p>
<p>求这个图的最大生成树的权和。</p>
<p>A、11</p>
<p>B、12</p>
<p>C、13</p>
<p>D、14</p>
<p>E、15</p>
<a id="more"></a>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>题意是在考察最大生成树，我们需要根据给出的邻接矩阵代表的无向带权图求出最大生成树，然后计算权和就很简单水到渠成了。</p>
<h3 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h3><p>说到最大生成树，我们得先回顾一下最小生成树：</p>
<p>最小生成树其实是最小权重生成树的简称。一个连通图可能有多个生成树。当图中的边具有权值时，总会有一个生成树的边的权值之和小于或者等于其它生成树的边的权值之和。也就是说最小生成树就是<strong>边权重之和最小</strong>的生成树。总结起来就是以下：</p>
<ul>
<li>1）必须使用且仅使用该网络中的n-1条边来连接网络中的n个顶点。</li>
<li>2）不能使用产生回路的边。</li>
<li>3）各边上的权值的总和达到最小。</li>
</ul>
<p>简单点说有几个城市你要设计一个路线，这个路线能走完所有的这几个城市，而且路程最短，这个路线就是最小生成树的含义。相反地，最大生成树就是边权重之和最大的生成树。</p>
<p>那么，如何生成最小生成树呢？常用的算法有<strong><a href="https://zh.wikipedia.org/wiki/%E6%99%AE%E6%9E%97%E5%A7%86%E7%AE%97%E6%B3%95" target="_blank" rel="external">Prim算法</a></strong>（普里姆算法）和<strong><a href="https://zh.wikipedia.org/wiki/%E5%85%8B%E9%B2%81%E6%96%AF%E5%85%8B%E5%B0%94%E6%BC%94%E7%AE%97%E6%B3%95" target="_blank" rel="external">Kruskal算法</a></strong>（克鲁斯克尔算法）。</p>
<h3 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h3><p>Prim算法是用来从带权图中搜索最小生成树的一种算法。 从单一顶点开始，Prim普里姆算法按照以下步骤逐步扩大树中所含顶点的数目，直到遍及连通图的所有顶点。</p>
<ol>
<li><p>输入：一个加权连通图，其中顶点集合为$V$ ，边集合为$E$；</p>
</li>
<li><p>初始化：$V_{new} = {x}$ ，其中x为集合V中的任一节点（起始点）， $E_{new} = \{\}$ ；</p>
</li>
<li><p>重复下列操作，直到$V_{new} = V$ ：</p>
<p><strong>a.</strong> 在集合E中选取权值最小的边（u, v），其中u为集合$V_{new}​$中的元素，而v则是V中没有加入$V_{new}​$的顶点（如<strong>b.</strong> 果存在有多条满足前述条件即具有相同权值的边，则可任意选取其中之一）；将v加入集合$V_{new}​$中，将（u, v）加入集合$E_{new}​$中；</p>
</li>
<li><p>输出：使用集合$V_{new}$和$E_{new}$来描述所得到的最小生成树。</p>
</li>
</ol>
<p>算法伪代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Prim(G, T) &#123;</div><div class="line">    T = NULL;</div><div class="line">    U = &#123;w&#125;;    <span class="comment">//添加任一顶点w</span></div><div class="line">    <span class="keyword">while</span>((V - U)!=NULL) &#123;</div><div class="line">        设(u, v)是u ∈ U 与 v ∈ （V - U),且权值最小的边</div><div class="line">        T = T ∪ (u, v);</div><div class="line">        U = U ∪ v ;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>说白了，就是将起点u（任一节点）放入空集合S，则S = {u}；再找到距离集合S最近的一点u，加入S集合。直到所有节点都加入进来。</p>
<blockquote>
<p>Prim算法时间复杂度为O(V^2)，比较适合于求稠密图的最小生成树。</p>
</blockquote>
<h3 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a><strong>Kruskal算法</strong></h3><p>Kruskal算法是一种按权值的递增次序选择合适的边来构成最小生成树的方法。算法描述如下：</p>
<ol>
<li>新建图G，G中拥有原图中相同的节点，但没有边</li>
<li>将原图中所有的边按权值从小到大排序</li>
<li>从权值最小的边开始，如果这条边连接的两个节点于图G中不在同一个连通分量中，则添加这条边到图G中</li>
<li>重复3，直至图G中所有的节点都在同一个连通分量中</li>
</ol>
<p>算法伪代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">KRUSKAL-FUNCTION(G, w)</div><div class="line">    F := 空集合</div><div class="line">    <span class="keyword">for</span> each 图 G 中的顶点 v</div><div class="line">        do 將 v 加入森林 F</div><div class="line">    所有的边(u, v) ∈ E依权重 w 递增排序</div><div class="line">   <span class="keyword">for</span> each 边(u, v) ∈ E</div><div class="line">        do <span class="keyword">if</span> u 和 v 不在同一棵子树</div><div class="line">            then F := F ∪ &#123;(u, v)&#125;</div><div class="line">                將 u 和 v 所在的子树合并</div></pre></td></tr></table></figure>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>Prim算法：是针对顶点展开的，适合于边数较多的情况。</p>
<p>Kruskal算法：是针对边展开的，适合于边的数量较少的情况。</p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>使用Krustal算法或者Prime算法构造“”最大生成树”：</p>
<ul>
<li><p><strong>Prime算法</strong>：选择权重最大的边的两个顶点加入等价类</p>
</li>
<li><p><strong>Krustal算法</strong>：即每次选择权重最大的边加入森林；</p>
</li>
</ul>
<p>我们看邻接矩阵</p>
<table>
<thead>
<tr>
<th></th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>0</td>
<td><strong>4</strong></td>
<td><strong>5</strong></td>
<td>0</td>
<td><strong>3</strong></td>
</tr>
<tr>
<td>B</td>
<td>4</td>
<td>0</td>
<td>4</td>
<td><strong>2</strong></td>
<td>3</td>
</tr>
<tr>
<td>C</td>
<td>5</td>
<td>4</td>
<td>0</td>
<td>2</td>
<td>0</td>
</tr>
<tr>
<td>D</td>
<td>0</td>
<td>2</td>
<td>2</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>E</td>
<td>3</td>
<td>3</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>利用Krustal算法，选择最大的边加入，但是不能形成回路，图中表黑的就是被选出的，DE边是不能选的，否则就形成闭路。总共5+4+3+2=14</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://blog.chinaunix.net/uid-26345906-id-3951551.html" target="_blank" rel="external">数据结构深入剖析（14）–最小连通图 </a></li>
<li><a href="https://www.zybuluo.com/pastqing/note/318392#prim算法" target="_blank" rel="external">图的常见算法</a></li>
<li><a href="https://www.zybuluo.com/guoxs/note/262429" target="_blank" rel="external">数据结构之图的存储方式</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是一道Google 笔试题&lt;/p&gt;
&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;一个有n个结点的连通图的生成树是原图的最小连通子图, 且包含原图中所有n个结点，并且有保持图联通的最少的边。最大生成树就是权和最大生成树，现在给出一个无向带权图的邻接矩阵，权为0表示没有边。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;&amp;#123;0, 4, 5, 0, 3&amp;#125;, &lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &amp;#123;4, 0, 4, 2, 3&amp;#125;, &lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &amp;#123;5, 4, 0, 2, 0&amp;#125;, &lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &amp;#123;0, 2, 2, 0, 1&amp;#125;, &lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &amp;#123;3, 3, 0, 1, 0&amp;#125;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;求这个图的最大生成树的权和。&lt;/p&gt;
&lt;p&gt;A、11&lt;/p&gt;
&lt;p&gt;B、12&lt;/p&gt;
&lt;p&gt;C、13&lt;/p&gt;
&lt;p&gt;D、14&lt;/p&gt;
&lt;p&gt;E、15&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://github.com/categories/Algorithm/"/>
    
    
      <category term="Google" scheme="http://github.com/tags/Google/"/>
    
  </entry>
  
  <entry>
    <title>八大排序算法总结与java实现</title>
    <link href="http://github.com/2017/07/18/%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%E4%B8%8Ejava%E5%AE%9E%E7%8E%B0/"/>
    <id>http://github.com/2017/07/18/八大排序算法总结与java实现/</id>
    <published>2017-07-18T04:30:55.000Z</published>
    <updated>2017-08-02T05:43:33.157Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>因为健忘，加上对各种排序算法理解不深刻，过段时间面对排序就蒙了。所以决定对我们常见的这几种排序算法进行统一总结，强行学习。首先罗列一下常见的十大排序算法：</p>
<p><img src="/gallery/sort-algorithms/big-o.png" alt=""></p>
<ul>
<li>直接插入排序</li>
<li>希尔排序</li>
<li>简单选择排序</li>
<li>堆排序</li>
<li>冒泡排序</li>
<li>快速排序</li>
<li>归并排序</li>
<li>基数排序</li>
</ul>
<a id="more"></a>
<p>其中我们讨论的这八大排序算法的实现可以参考<a href="https://github.com/iTimeTraveler/SortAlgorithms">我的Github：<strong>SortAlgorithms</strong></a>，它们都属于内部排序，也就是只考虑数据量较小仅需要使用内存的排序算法，他们之间关系如下：</p>

$$
\begin{cases}
内部排序 

\begin{cases}
插入排序

\begin{cases}
直接插入排序\\
希尔排序
\end{cases}

\\
选择排序
\begin{cases}
简单选择排序\\
堆排序
\end{cases}
\\

交换排序
\begin{cases}
冒泡排序\\
快速排序 
\end{cases}

\\

归并排序\\
基数排序

\end{cases}

\\
外部排序 
\end{cases}
$$

<h3 id="一、直接插入排序（Insertion-Sort）"><a href="#一、直接插入排序（Insertion-Sort）" class="headerlink" title="一、直接插入排序（Insertion Sort）"></a>一、直接插入排序（Insertion Sort）</h3><hr>
<p>插入排序的设计初衷是<strong>往有序的数组中快速插入一个新的元素</strong>。它的算法思想是：把要排序的数组分为了两个部分, 一部分是数组的全部元素(除去待插入的元素), 另一部分是待插入的元素; 先将第一部分排序完成, 然后再插入这个元素. 其中第一部分的排序也是通过再次拆分为两部分来进行的.</p>
<p>插入排序由于操作不尽相同, 可分为 <code>直接插入排序</code> , <code>折半插入排序</code>(又称二分插入排序), <code>链表插入排序</code> , <code>希尔排序</code> 。我们先来看下直接插入排序。</p>
<h4 id="1、基本思想"><a href="#1、基本思想" class="headerlink" title="1、基本思想"></a>1、基本思想</h4><p>直接插入排序的基本思想是：将数组中的所有元素依次跟前面已经排好的元素相比较，如果选择的元素比已排序的元素小，则交换，直到全部元素都比较过为止。</p>
<p><img src="/gallery/sort-algorithms/Insertion-sort-example-300px.gif" alt="使用插入排序为一列数字进行排序的过程"></p>
<h4 id="2、算法描述"><a href="#2、算法描述" class="headerlink" title="2、算法描述"></a>2、算法描述</h4><p>一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：</p>
<p>①. 从第一个元素开始，该元素可以认为已经被排序<br>②. 取出下一个元素，在已经排序的元素序列中从后向前扫描<br>③. 如果该元素（已排序）大于新元素，将该元素移到下一位置<br>④. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置<br>⑤. 将新元素插入到该位置后<br>⑥. 重复步骤②~⑤</p>
<p><img src="/gallery/sort-algorithms/insert-sort.gif" alt="直接插入排序演示"></p>
<p>如果<em>比较操作</em>的代价比<em>交换操作</em>大的话，可以采用<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%B3%95" target="_blank" rel="external">二分查找法</a>来减少<em>比较操作</em>的数目。该算法可以认为是<strong>插入排序</strong>的一个变种，称为<a href="https://zh.wikipedia.org/w/index.php?title=%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F&amp;action=edit&amp;redlink=1" target="_blank" rel="external">二分查找插入排序</a>。</p>
<h4 id="3、代码实现"><a href="#3、代码实现" class="headerlink" title="3、代码实现"></a>3、代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 插入排序</div><div class="line"> *</div><div class="line"> * 1. 从第一个元素开始，该元素可以认为已经被排序</div><div class="line"> * 2. 取出下一个元素，在已经排序的元素序列中从后向前扫描</div><div class="line"> * 3. 如果该元素（已排序）大于新元素，将该元素移到下一位置</div><div class="line"> * 4. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置</div><div class="line"> * 5. 将新元素插入到该位置后</div><div class="line"> * 6. 重复步骤2~5</div><div class="line"> * <span class="doctag">@param</span> arr  待排序数组</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</div><div class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length-<span class="number">1</span>; i++ ) &#123;</div><div class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> j=i+<span class="number">1</span>; j&gt;<span class="number">0</span>; j-- ) &#123;</div><div class="line">            <span class="keyword">if</span>( arr[j-<span class="number">1</span>] &lt;= arr[j] )</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">int</span> temp = arr[j];      <span class="comment">//交换操作</span></div><div class="line">            arr[j] = arr[j-<span class="number">1</span>];</div><div class="line">            arr[j-<span class="number">1</span>] = temp;</div><div class="line">            System.out.println(<span class="string">"Sorting:  "</span> + Arrays.toString(arr));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>直接插入排序复杂度如下：</p>
<table>
<thead>
<tr>
<th>平均时间复杂度</th>
<th>最好情况</th>
<th>最坏情况</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>O(n²)</td>
<td>O(n²)</td>
<td>O(n²)</td>
<td>O(1)</td>
</tr>
</tbody>
</table>
<p>Tips: 由于直接插入排序每次只移动一个元素的位， 并不会改变值相同的元素之间的排序， 因此它是一种稳定排序。</p>
<h3 id="二、希尔排序（Shell-Sort）"><a href="#二、希尔排序（Shell-Sort）" class="headerlink" title="二、希尔排序（Shell Sort）"></a>二、希尔排序（Shell Sort）</h3><hr>
<blockquote class="pullquote right"><p>第一个突破O(n^2)的排序算法；是简单插入排序的改进版；它与插入排序的不同之处在于，它会优先比较距离较远的元素。</p>
</blockquote>
<p>希尔排序，也称<strong>递减增量排序算法</strong>，1959年Shell发明。是插入排序的一种高速而稳定的改进版本。</p>
<p>希尔排序是先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。</p>
<h4 id="1、基本思想-1"><a href="#1、基本思想-1" class="headerlink" title="1、基本思想"></a>1、基本思想</h4><p><img src="/gallery/sort-algorithms/shell-sort.jpg" alt=""></p>
<p>将待排序数组按照步长gap进行分组，然后将每组的元素利用直接插入排序的方法进行排序；每次再将gap折半减小，循环上述操作；当gap=1时，利用直接插入，完成排序。</p>
<p>可以看到步长的选择是希尔排序的重要部分。只要最终步长为1任何步长序列都可以工作。一般来说最简单的步长取值是<strong>初次取数组长度的一半</strong>为增量，之后每次再减半，直到增量为1。更好的步长序列取值可以参考<a href="https://zh.wikipedia.org/wiki/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F#.E6.AD.A5.E9.95.BF.E5.BA.8F.E5.88.97" target="_blank" rel="external">维基百科</a>。</p>
<h4 id="2、算法描述-1"><a href="#2、算法描述-1" class="headerlink" title="2、算法描述"></a>2、算法描述</h4><p>①. 选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；（<strong>一般初次取数组半长，之后每次再减半，直到增量为1</strong>）<br>②. 按增量序列个数k，对序列进行k 趟排序；<br>③. 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</p>
<h4 id="3、代码实现-1"><a href="#3、代码实现-1" class="headerlink" title="3、代码实现"></a>3、代码实现</h4><p>以下是我自己的实现，可以看到实现很幼稚，但是好处是理解起来很简单。因为没有经过任何的优化，所以不建议大家直接使用。建议对比下方的维基百科官方实现代码，特别是步长取值策略部分。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 希尔排序</div><div class="line"> *</div><div class="line"> * 1. 选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；（一般初次取数组半长，之后每次再减半，直到增量为1）</div><div class="line"> * 2. 按增量序列个数k，对序列进行k 趟排序；</div><div class="line"> * 3. 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。</div><div class="line"> *    仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</div><div class="line"> * <span class="doctag">@param</span> arr  待排序数组</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> gap = arr.length / <span class="number">2</span>;</div><div class="line">    <span class="keyword">for</span> (; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;      <span class="comment">//不断缩小gap，直到1为止</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; (j+gap) &lt; arr.length; j++)&#123;     <span class="comment">//使用每个gap进行遍历</span></div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; (k+gap) &lt; arr.length; k += gap)&#123;</div><div class="line">                <span class="keyword">if</span>(arr[k] &gt; arr[k+gap])&#123;</div><div class="line">                    <span class="keyword">int</span> temp = arr[k+gap];      <span class="comment">//交换操作</span></div><div class="line">                    arr[k+gap] = arr[k];</div><div class="line">                    arr[k] = temp;</div><div class="line">                    System.out.println(<span class="string">"Gap="</span> + gap + <span class="string">", Sorting:  "</span> + Arrays.toString(arr));</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(gap == <span class="number">1</span>)&#123;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面是维基百科官方实现，大家注意gap步长取值部分：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 希尔排序（Wiki官方版）</div><div class="line"> *</div><div class="line"> * 1. 选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；（注意此算法的gap取值）</div><div class="line"> * 2. 按增量序列个数k，对序列进行k 趟排序；</div><div class="line"> * 3. 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。</div><div class="line"> *    仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</div><div class="line"> * <span class="doctag">@param</span> arr  待排序数组</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shell_sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> gap = <span class="number">1</span>, i, j, len = arr.length;</div><div class="line">    <span class="keyword">int</span> temp;</div><div class="line">    <span class="keyword">while</span> (gap &lt; len / <span class="number">3</span>)</div><div class="line">        gap = gap * <span class="number">3</span> + <span class="number">1</span>;      <span class="comment">// &lt;O(n^(3/2)) by Knuth,1973&gt;: 1, 4, 13, 40, 121, ...</span></div><div class="line">    <span class="keyword">for</span> (; gap &gt; <span class="number">0</span>; gap /= <span class="number">3</span>) &#123;</div><div class="line">        <span class="keyword">for</span> (i = gap; i &lt; len; i++) &#123;</div><div class="line">            temp = arr[i];</div><div class="line">            <span class="keyword">for</span> (j = i - gap; j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; temp; j -= gap)</div><div class="line">                arr[j + gap] = arr[j];</div><div class="line">            arr[j + gap] = temp;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以下是希尔排序复杂度:</p>
<table>
<thead>
<tr>
<th>平均时间复杂度</th>
<th>最好情况</th>
<th>最坏情况</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>O(nlog2 n)</td>
<td>O(nlog2 n)</td>
<td>O(nlog2 n)</td>
<td>O(1)</td>
</tr>
</tbody>
</table>
<h3 id="三、选择排序（Selection-Sort）"><a href="#三、选择排序（Selection-Sort）" class="headerlink" title="三、选择排序（Selection Sort）"></a>三、选择排序（Selection Sort）</h3><hr>
<blockquote class="pullquote right"><p><img src="/gallery/sort-algorithms/Selection-Sort-Animation.gif" alt="选择排序的示例动画。红色表示当前最小值，黄色表示已排序序列，蓝色表示当前位置。"></p>
</blockquote>
<p>从算法逻辑上看，选择排序是一种简单直观的排序算法，在简单选择排序过程中，所需移动记录的次数比较少。</p>
<h4 id="1、基本思想-2"><a href="#1、基本思想-2" class="headerlink" title="1、基本思想"></a>1、基本思想</h4><p>选择排序的基本思想：比较 + 交换。</p>
<p>在未排序序列中找到最小（大）元素，存放到未排序序列的起始位置。在所有的完全依靠交换去移动元素的排序方法中，选择排序属于非常好的一种。</p>
<h4 id="2、算法描述-2"><a href="#2、算法描述-2" class="headerlink" title="2、算法描述"></a>2、算法描述</h4><p>①. 从待排序序列中，找到关键字最小的元素；<br>②. 如果最小元素不是待排序序列的第一个元素，将其和第一个元素互换；<br>③. 从余下的 N - 1 个元素中，找出关键字最小的元素，重复①、②步，直到排序结束。</p>
<h4 id="3、代码实现-2"><a href="#3、代码实现-2" class="headerlink" title="3、代码实现"></a>3、代码实现</h4><p>选择排序比较简单，以下是我自己的实现，跟官方版差不多，所以完全可以参考。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 选择排序</div><div class="line"> *</div><div class="line"> * 1. 从待排序序列中，找到关键字最小的元素；</div><div class="line"> * 2. 如果最小元素不是待排序序列的第一个元素，将其和第一个元素互换；</div><div class="line"> * 3. 从余下的 N - 1 个元素中，找出关键字最小的元素，重复①、②步，直到排序结束。</div><div class="line"> *    仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</div><div class="line"> * <span class="doctag">@param</span> arr  待排序数组</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length-<span class="number">1</span>; i++)&#123;</div><div class="line">        <span class="keyword">int</span> min = i;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; arr.length; j++)&#123;    <span class="comment">//选出之后待排序中值最小的位置</span></div><div class="line">            <span class="keyword">if</span>(arr[j] &lt; arr[min])&#123;</div><div class="line">                min = j;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(min != i)&#123;</div><div class="line">            <span class="keyword">int</span> temp = arr[min];      <span class="comment">//交换操作</span></div><div class="line">            arr[min] = arr[i];</div><div class="line">            arr[i] = temp;</div><div class="line">            System.out.println(<span class="string">"Sorting:  "</span> + Arrays.toString(arr));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以下是选择排序复杂度:</p>
<table>
<thead>
<tr>
<th>平均时间复杂度</th>
<th>最好情况</th>
<th>最坏情况</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>O(n²)</td>
<td>O(n²)</td>
<td>O(n²)</td>
<td>O(1)</td>
</tr>
</tbody>
</table>
<p>选择排序的简单和直观名副其实，这也造就了它”出了名的慢性子”，无论是哪种情况，哪怕原数组已排序完成，它也将花费将近n²/2次遍历来确认一遍。即便是这样，它的排序结果也还是不稳定的。 唯一值得高兴的是，它并不耗费额外的内存空间。</p>
<h3 id="四、堆排序（Heap-Sort）"><a href="#四、堆排序（Heap-Sort）" class="headerlink" title="四、堆排序（Heap Sort）"></a>四、堆排序（Heap Sort）</h3><hr>
<blockquote>
<p>1991年的计算机先驱奖获得者、斯坦福大学计算机科学系教授罗伯特·弗洛伊德(Robert W．Floyd) 和威廉姆斯(J．Williams) 在1964年共同发明了著名的堆排序算法(Heap Sort).</p>
</blockquote>
<p>堆的定义如下：$n$个元素的序列
$\left\{{k_1,k_2,···,k_n}\right\}$
当且仅当满足下关系时，称之为堆。</p>

$$
\left\{
\begin{aligned}
k_i & \leqslant  k_{2i} \\
k_i & \leqslant  k_{2i+1} 
\end{aligned}
\right.
\quad  或  \quad
\left\{
\begin{aligned}
k_i & \geqslant  k_{2i} \\
k_i & \geqslant k_{2i+1} 
\end{aligned}
\right.
\quad (i = 1,2,···, \left \lfloor { \frac{n}{2} } \right \rfloor )
$$

<p>把此序列对应的二维数组看成一个完全二叉树。那么堆的含义就是：<strong>完全二叉树中任何一个非叶子节点的值均不大于（或不小于）其左，右孩子节点的值。</strong>由上述性质可知大顶堆的堆顶的关键字肯定是所有关键字中最大的，小顶堆的堆顶的关键字是所有关键字中最小的。因此我们可使用大顶堆进行升序排序, 使用小顶堆进行降序排序。</p>
<h4 id="1、基本思想-3"><a href="#1、基本思想-3" class="headerlink" title="1、基本思想"></a>1、基本思想</h4><p>此处以大顶堆为例，堆排序的过程就是将待排序的序列构造成一个堆，选出堆中最大的移走，再把剩余的元素调整成堆，找出最大的再移走，重复直至有序。</p>
<h4 id="2、算法描述-3"><a href="#2、算法描述-3" class="headerlink" title="2、算法描述"></a>2、算法描述</h4><p>①. 先将初始序列$K[1..n]$建成一个大顶堆, 那么此时第一个元素$K_1$最大, 此堆为初始的无序区.<br>②. 再将关键字最大的记录$K_1$ (即堆顶, 第一个元素)和无序区的最后一个记录 $K_n$ 交换, 由此得到新的无序区$K[1..n-1]$和有序区$K[n]$, 且满足$K[1..n-1].keys \leqslant K[n].key$<br>③. 交换$K_1$ 和 $K_n$ 后, 堆顶可能违反堆性质, 因此需将$K[1..n-1]$调整为堆. 然后重复步骤②, 直到无序区只有一个元素时停止.</p>
<p>动图效果如下所示：</p>
<p><img src="/gallery/sort-algorithms/heap_sort_gif.gif" alt="堆排序过程"></p>
<p><img src="/gallery/sort-algorithms/Sorting_heapsort_anim.gif" alt="堆排序算法的演示。首先，将元素进行重排，以匹配堆的条件。图中排序过程之前简单的绘出了堆树的结构。"></p>
<h4 id="3、代码实现-3"><a href="#3、代码实现-3" class="headerlink" title="3、代码实现"></a>3、代码实现</h4><p>从算法描述来看，堆排序需要两个过程，一是建立堆，二是堆顶与堆的最后一个元素交换位置。所以堆排序有两个函数组成。一是建堆函数，二是反复调用建堆函数以选择出剩余未排元素中最大的数来实现排序的函数。</p>
<p>总结起来就是定义了以下几种操作：</p>
<ul>
<li>最大堆调整（Max_Heapify）：将堆的末端子节点作调整，使得子节点永远小于父节点</li>
<li>创建最大堆（Build_Max_Heap）：将堆所有数据重新排序</li>
<li>堆排序（HeapSort）：移除位在第一个数据的根节点，并做最大堆调整的递归运算</li>
</ul>
<p>对于堆节点的访问：</p>
<ul>
<li>父节点i的左子节点在位置：<code>(2*i+1)</code>;</li>
<li>父节点i的右子节点在位置：<code>(2*i+2)</code>;</li>
<li>子节点i的父节点在位置：<code>floor((i-1)/2)</code>;</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 堆排序</div><div class="line"> *</div><div class="line"> * 1. 先将初始序列K[1..n]建成一个大顶堆, 那么此时第一个元素K1最大, 此堆为初始的无序区.</div><div class="line"> * 2. 再将关键字最大的记录K1 (即堆顶, 第一个元素)和无序区的最后一个记录 Kn 交换, 由此得到新的无序区K[1..n−1]和有序区K[n], 且满足K[1..n−1].keys⩽K[n].key</div><div class="line"> * 3. 交换K1 和 Kn 后, 堆顶可能违反堆性质, 因此需将K[1..n−1]调整为堆. 然后重复步骤②, 直到无序区只有一个元素时停止.</div><div class="line"> * <span class="doctag">@param</span> arr  待排序数组</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = arr.length; i &gt; <span class="number">0</span>; i--)&#123;</div><div class="line">        max_heapify(arr, i);</div><div class="line"></div><div class="line">        <span class="keyword">int</span> temp = arr[<span class="number">0</span>];      <span class="comment">//堆顶元素(第一个元素)与Kn交换</span></div><div class="line">        arr[<span class="number">0</span>] = arr[i-<span class="number">1</span>];</div><div class="line">        arr[i-<span class="number">1</span>] = temp;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">max_heapify</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> limit)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(arr.length &lt;= <span class="number">0</span> || arr.length &lt; limit) <span class="keyword">return</span>;</div><div class="line">    <span class="keyword">int</span> parentIdx = limit / <span class="number">2</span>;</div><div class="line"></div><div class="line">    <span class="keyword">for</span>(; parentIdx &gt;= <span class="number">0</span>; parentIdx--)&#123;</div><div class="line">        <span class="keyword">if</span>(parentIdx * <span class="number">2</span> &gt;= limit)&#123;</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> left = parentIdx * <span class="number">2</span>;       <span class="comment">//左子节点位置</span></div><div class="line">        <span class="keyword">int</span> right = (left + <span class="number">1</span>) &gt;= limit ? left : (left + <span class="number">1</span>);    <span class="comment">//右子节点位置，如果没有右节点，默认为左节点位置</span></div><div class="line"></div><div class="line">        <span class="keyword">int</span> maxChildId = arr[left] &gt;= arr[right] ? left : right;</div><div class="line">        <span class="keyword">if</span>(arr[maxChildId] &gt; arr[parentIdx])&#123;   <span class="comment">//交换父节点与左右子节点中的最大值</span></div><div class="line">            <span class="keyword">int</span> temp = arr[parentIdx];</div><div class="line">            arr[parentIdx] = arr[maxChildId];</div><div class="line">            arr[maxChildId] = temp;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    System.out.println(<span class="string">"Max_Heapify: "</span> + Arrays.toString(arr));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>注:</strong> x&gt;&gt;1 是位运算中的右移运算, 表示右移一位, 等同于x除以2再取整, 即 x&gt;&gt;1 == Math.floor(x/2) .</p>
</blockquote>
<p>以上,<br>①. 建立堆的过程, 从length/2 一直处理到0, 时间复杂度为O(n);<br>②. 调整堆的过程是沿着堆的父子节点进行调整, 执行次数为堆的深度, 时间复杂度为O(lgn);<br>③. 堆排序的过程由n次第②步完成, 时间复杂度为O(nlgn).</p>
<table>
<thead>
<tr>
<th>平均时间复杂度</th>
<th>最好情况</th>
<th>最坏情况</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>$O(n \log_{2}n)$</td>
<td>$O(n \log_{2}n)$</td>
<td>$O(n \log_{2}n)$</td>
<td>O(1)</td>
</tr>
</tbody>
</table>
<p>Tips: <strong>由于堆排序中初始化堆的过程比较次数较多, 因此它不太适用于小序列.</strong> 同时由于多次任意下标相互交换位置, 相同元素之间原本相对的顺序被破坏了, 因此, 它是不稳定的排序.</p>
<h3 id="五、冒泡排序（Bubble-Sort）"><a href="#五、冒泡排序（Bubble-Sort）" class="headerlink" title="五、冒泡排序（Bubble Sort）"></a>五、冒泡排序（Bubble Sort）</h3><hr>
<p><img src="/gallery/sort-algorithms/bubble-sort02.gif" alt="冒泡排序的思想"></p>
<blockquote>
<p>我想对于它每个学过C语言的都会了解，这可能是很多人接触的第一个排序算法。</p>
</blockquote>
<h4 id="1、基本思想-4"><a href="#1、基本思想-4" class="headerlink" title="1、基本思想"></a>1、基本思想</h4><p>冒泡排序（Bubble Sort）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p>
<p><img src="/gallery/sort-algorithms/bubble-sort.gif" alt="冒泡排序演示"></p>
<h4 id="2、算法描述-4"><a href="#2、算法描述-4" class="headerlink" title="2、算法描述"></a>2、算法描述</h4><p>冒泡排序算法的运作如下：</p>
<p>①. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。<br>②. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。<br>③. 针对所有的元素重复以上的步骤，除了最后一个。<br>④. 持续每次对越来越少的元素重复上面的步骤①~③，直到没有任何一对数字需要比较。</p>
<h4 id="3、代码实现-4"><a href="#3、代码实现-4" class="headerlink" title="3、代码实现"></a>3、代码实现</h4><p>冒泡排序需要两个嵌套的循环. 其中, <strong>外层循环</strong>移动游标; <strong>内层循环</strong>遍历游标及之后(或之前)的元素, 通过两两交换的方式, 每次只确保该内循环结束位置排序正确, 然后内层循环周期结束, 交由外层循环往后(或前)移动游标, 随即开始下一轮内层循环, 以此类推, 直至循环结束.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 冒泡排序</div><div class="line"> *</div><div class="line"> * ①. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。</div><div class="line"> * ②. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</div><div class="line"> * ③. 针对所有的元素重复以上的步骤，除了最后一个。</div><div class="line"> * ④. 持续每次对越来越少的元素重复上面的步骤①~③，直到没有任何一对数字需要比较。</div><div class="line"> * <span class="doctag">@param</span> arr  待排序数组</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length; i &gt; <span class="number">0</span>; i--) &#123;      <span class="comment">//外层循环移动游标</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i &amp;&amp; (j+<span class="number">1</span>) &lt; i; j++)&#123;    <span class="comment">//内层循环遍历游标及之后(或之前)的元素</span></div><div class="line">            <span class="keyword">if</span>(arr[j] &gt; arr[j+<span class="number">1</span>])&#123;</div><div class="line">                <span class="keyword">int</span> temp = arr[j];</div><div class="line">                arr[j] = arr[j+<span class="number">1</span>];</div><div class="line">                arr[j+<span class="number">1</span>] = temp;</div><div class="line">                System.out.println(<span class="string">"Sorting: "</span> + Arrays.toString(arr));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以下是冒泡排序算法复杂度:</p>
<table>
<thead>
<tr>
<th>平均时间复杂度</th>
<th>最好情况</th>
<th>最坏情况</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>O(n²)</td>
<td>O(n)</td>
<td>O(n²)</td>
<td>O(1)</td>
</tr>
</tbody>
</table>
<p>冒泡排序是最容易实现的排序, 最坏的情况是每次都需要交换, 共需遍历并交换将近n²/2次, 时间复杂度为O(n²). 最佳的情况是内循环遍历一次后发现排序是对的, 因此退出循环, 时间复杂度为O(n). 平均来讲, 时间复杂度为O(n²). 由于冒泡排序中只有缓存的temp变量需要内存空间, 因此空间复杂度为常量O(1).</p>
<p>Tips: 由于冒泡排序只在相邻元素大小不符合要求时才调换他们的位置, 它并不改变相同元素之间的相对顺序, 因此它是稳定的排序算法.</p>
<h3 id="六、快速排序（Quick-Sort）"><a href="#六、快速排序（Quick-Sort）" class="headerlink" title="六、快速排序（Quick Sort）"></a>六、快速排序（Quick Sort）</h3><hr>
<p>快速排序（Quicksort）是对冒泡排序的一种改进，借用了分治的思想，由C. A. R. Hoare在1962年提出。</p>
<h4 id="1、基本思想-5"><a href="#1、基本思想-5" class="headerlink" title="1、基本思想"></a>1、基本思想</h4><p>快速排序的基本思想：<strong>挖坑填数+分治法</strong>。</p>
<p>首先选一个轴值(pivot，也有叫基准的)，通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p>
<p><img src="/gallery/sort-algorithms/Sorting_quicksort_anim.gif" alt="使用快速排序法对一列数字进行排序的过程"></p>
<h4 id="2、算法描述-5"><a href="#2、算法描述-5" class="headerlink" title="2、算法描述"></a>2、算法描述</h4><p>快速排序使用分治策略来把一个序列（list）分为两个子序列（sub-lists）。步骤为：</p>
<p>①. 从数列中挑出一个元素，称为”基准”（pivot）。<br>②. 重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。<br>③. 递归地（recursively）把小于基准值元素的子数列和大于基准值元素的子数列排序。</p>
<p>递归到最底部时，数列的大小是零或一，也就是已经排序好了。这个算法一定会结束，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。</p>
<p><img src="/gallery/sort-algorithms/quick-sort09.gif" alt="快速排序演示"></p>
<h4 id="3、代码实现-5"><a href="#3、代码实现-5" class="headerlink" title="3、代码实现"></a>3、代码实现</h4><p>用伪代码描述如下：</p>
<p>①. <code>i = L; j = R;</code> 将基准数挖出形成第一个坑<code>a[i]</code>。<br>②．<code>j--</code>，由后向前找比它小的数，找到后挖出此数填前一个坑<code>a[i]</code>中。<br>③．<code>i++</code>，由前向后找比它大的数，找到后也挖出此数填到前一个坑<code>a[j]</code>中。<br>④．再重复执行②，③二步，直到<code>i==j</code>，将基准数填入<code>a[i]</code>中</p>
<p><img src="/gallery/sort-algorithms/200px-Partition_example.svg.png" alt="快速排序采用“分而治之、各个击破”的观念，此为原地（In-place）分区版本。"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 快速排序（递归）</div><div class="line"> *</div><div class="line"> * ①. 从数列中挑出一个元素，称为"基准"（pivot）。</div><div class="line"> * ②. 重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。</div><div class="line"> * ③. 递归地（recursively）把小于基准值元素的子数列和大于基准值元素的子数列排序。</div><div class="line"> * <span class="doctag">@param</span> arr   待排序数组</div><div class="line"> * <span class="doctag">@param</span> low   左边界</div><div class="line"> * <span class="doctag">@param</span> high  右边界</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(arr.length &lt;= <span class="number">0</span>) <span class="keyword">return</span>;</div><div class="line">    <span class="keyword">if</span>(low &gt;= high) <span class="keyword">return</span>;</div><div class="line">    <span class="keyword">int</span> left = low;</div><div class="line">    <span class="keyword">int</span> right = high;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> temp = arr[left];   <span class="comment">//挖坑1：保存基准的值</span></div><div class="line">    <span class="keyword">while</span> (left &lt; right)&#123;</div><div class="line">        <span class="keyword">while</span>(left &lt; right &amp;&amp; arr[right] &gt;= temp)&#123;  <span class="comment">//坑2：从后向前找到比基准小的元素，插入到基准位置坑1中</span></div><div class="line">            right--;</div><div class="line">        &#125;</div><div class="line">        arr[left] = arr[right];</div><div class="line">        <span class="keyword">while</span>(left &lt; right &amp;&amp; arr[left] &lt;= temp)&#123;   <span class="comment">//坑3：从前往后找到比基准大的元素，放到刚才挖的坑2中</span></div><div class="line">            left++;</div><div class="line">        &#125;</div><div class="line">        arr[right] = arr[left];</div><div class="line">    &#125;</div><div class="line">    arr[left] = temp;   <span class="comment">//基准值填补到坑3中，准备分治递归快排</span></div><div class="line">    System.out.println(<span class="string">"Sorting: "</span> + Arrays.toString(arr));</div><div class="line">    quickSort(arr, low, left-<span class="number">1</span>);</div><div class="line">    quickSort(arr, left+<span class="number">1</span>, high);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>快速排序是通常被认为在同数量级（O(nlog2n)）的排序方法中平均性能最好的。但若初始序列按关键码有序或基本有序时，快排序反而蜕化为冒泡排序。为改进之，通常以“三者取中法”来选取基准记录，即将排序区间的两个端点与中点三个记录关键码居中的调整为支点记录。快速排序是一个不稳定的排序方法。</p>
<p>以下是快速排序算法复杂度:</p>
<table>
<thead>
<tr>
<th>平均时间复杂度</th>
<th>最好情况</th>
<th>最坏情况</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>O(nlog₂n)</td>
<td>O(nlog₂n)</td>
<td>O(n²)</td>
<td>O(1)（原地分区递归版）</td>
</tr>
</tbody>
</table>
<p>快速排序排序效率非常高。 虽然它运行最糟糕时将达到O(n²)的时间复杂度, 但通常平均来看, 它的时间复杂为O(nlogn), 比同样为O(nlogn)时间复杂度的归并排序还要快. 快速排序似乎更偏爱乱序的数列, 越是乱序的数列, 它相比其他排序而言, 相对效率更高. </p>
<p>Tips: 同选择排序相似, 快速排序每次交换的元素都有可能不是相邻的, 因此它有可能打破原来值为相同的元素之间的顺序. 因此, 快速排序并不稳定.</p>
<h3 id="七、归并排序（Merging-Sort）"><a href="#七、归并排序（Merging-Sort）" class="headerlink" title="七、归并排序（Merging Sort）"></a>七、归并排序（Merging Sort）</h3><hr>
<blockquote class="pullquote right"><p><img src="/gallery/sort-algorithms/merging-sort_sample.jpg" alt=""></p>
</blockquote>
<p>归并排序是建立在归并操作上的一种有效的排序算法，1945年由约翰·冯·诺伊曼首次提出。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用，且各层分治递归可以同时进行。</p>
<h4 id="1、基本思想-6"><a href="#1、基本思想-6" class="headerlink" title="1、基本思想"></a>1、基本思想</h4><p>归并排序算法是将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。</p>
<p><img src="/gallery/sort-algorithms/2016-07-15_归并排序.gif" alt="这个图很有概括性，来自维基"></p>
<h4 id="2、算法描述-6"><a href="#2、算法描述-6" class="headerlink" title="2、算法描述"></a>2、算法描述</h4><p><strong>归并排序可通过两种方式实现：</strong></p>
<ul>
<li>自上而下的递归</li>
<li>自下而上的迭代</li>
</ul>
<p><strong>一、递归法</strong>（假设序列共有n个元素）：</p>
<p>①. 将序列每相邻两个数字进行归并操作，形成 floor(n/2)个序列，排序后每个序列包含两个元素；<br>②. 将上述序列再次归并，形成 floor(n/4)个序列，每个序列包含四个元素；<br>③. 重复步骤②，直到所有元素排序完毕。</p>
<p><img src="/gallery/sort-algorithms/merging-sort.gif" alt=""></p>
<p><strong>二、迭代法</strong></p>
<p>①. 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列<br>②. 设定两个指针，最初位置分别为两个已经排序序列的起始位置<br>③. 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置<br>④. 重复步骤③直到某一指针到达序列尾<br>⑤. 将另一序列剩下的所有元素直接复制到合并序列尾</p>
<h4 id="3、代码实现-6"><a href="#3、代码实现-6" class="headerlink" title="3、代码实现"></a>3、代码实现</h4><p>归并排序其实要做两件事：</p>
<ul>
<li>分解：将序列每次折半拆分</li>
<li>合并：将划分后的序列段两两排序合并</li>
</ul>
<p>因此，归并排序实际上就是两个操作，拆分+合并</p>
<p><strong>如何合并？</strong></p>
<p>L[first…mid]为第一段，L[mid+1…last]为第二段，并且两端已经有序，现在我们要将两端合成达到L[first…last]并且也有序。</p>
<p>首先依次从第一段与第二段中取出元素比较，将较小的元素赋值给temp[]<br>重复执行上一步，当某一段赋值结束，则将另一段剩下的元素赋值给temp[]<br>此时将temp[]中的元素复制给L[]，则得到的L[first…last]有序</p>
<p><strong>如何分解？</strong></p>
<p>在这里，我们采用递归的方法，首先将待排序列分成A,B两组；然后重复对A、B序列<br>分组；直到分组后组内只有一个元素，此时我们认为组内所有元素有序，则分组结束。</p>
<p>这里我写了递归算法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 归并排序（递归）</div><div class="line"> *</div><div class="line"> * ①. 将序列每相邻两个数字进行归并操作，形成 floor(n/2)个序列，排序后每个序列包含两个元素；</div><div class="line"> * ②. 将上述序列再次归并，形成 floor(n/4)个序列，每个序列包含四个元素；</div><div class="line"> * ③. 重复步骤②，直到所有元素排序完毕。</div><div class="line"> * <span class="doctag">@param</span> arr	 待排序数组</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] mergingSort(<span class="keyword">int</span>[] arr)&#123;</div><div class="line">    <span class="keyword">if</span>(arr.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> arr;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> num = arr.length &gt;&gt; <span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span>[] leftArr = Arrays.copyOfRange(arr, <span class="number">0</span>, num);</div><div class="line">    <span class="keyword">int</span>[] rightArr = Arrays.copyOfRange(arr, num, arr.length);</div><div class="line">    System.out.println(<span class="string">"split two array: "</span> + Arrays.toString(leftArr) + <span class="string">" And "</span> + Arrays.toString(rightArr));</div><div class="line">    <span class="keyword">return</span> mergeTwoArray(mergingSort(leftArr), mergingSort(rightArr));      <span class="comment">//不断拆分为最小单元，再排序合并</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] mergeTwoArray(<span class="keyword">int</span>[] arr1, <span class="keyword">int</span>[] arr2)&#123;</div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[arr1.length + arr2.length];  <span class="comment">//申请额外的空间存储合并之后的数组</span></div><div class="line">    <span class="keyword">while</span>(i &lt; arr1.length &amp;&amp; j &lt; arr2.length)&#123;      <span class="comment">//选取两个序列中的较小值放入新数组</span></div><div class="line">        <span class="keyword">if</span>(arr1[i] &lt;= arr2[j])&#123;</div><div class="line">            result[k++] = arr1[i++];</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            result[k++] = arr2[j++];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span>(i &lt; arr1.length)&#123;     <span class="comment">//序列1中多余的元素移入新数组</span></div><div class="line">        result[k++] = arr1[i++];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span>(j &lt; arr2.length)&#123;     <span class="comment">//序列2中多余的元素移入新数组</span></div><div class="line">        result[k++] = arr2[j++];</div><div class="line">    &#125;</div><div class="line">    System.out.println(<span class="string">"Merging: "</span> + Arrays.toString(result));</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由上, 长度为n的数组, 最终会调用mergeSort函数2n-1次。<strong>通过自上而下的递归实现的归并排序, 将存在堆栈溢出的风险。</strong></p>
<p>以下是归并排序算法复杂度:</p>
<table>
<thead>
<tr>
<th>平均时间复杂度</th>
<th>最好情况</th>
<th>最坏情况</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>O(nlog₂n)</td>
<td>O(nlog₂n)</td>
<td>O(nlog₂n)</td>
<td>O(n)</td>
</tr>
</tbody>
</table>
<p>从效率上看，归并排序可算是排序算法中的”佼佼者”. 假设数组长度为n，那么拆分数组共需logn，, 又每步都是一个普通的合并子数组的过程， 时间复杂度为O(n)， 故其综合时间复杂度为O(nlogn)。另一方面， 归并排序多次递归过程中拆分的子数组需要保存在内存空间， 其空间复杂度为O(n)。</p>
<blockquote>
<p>和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是<code>O(n log n）</code>的时间复杂度。代价是需要额外的内存空间。</p>
</blockquote>
<h3 id="八、基数排序（Radix-Sort）"><a href="#八、基数排序（Radix-Sort）" class="headerlink" title="八、基数排序（Radix Sort）"></a>八、基数排序（Radix Sort）</h3><hr>
<p>基数排序的发明可以追溯到1887年赫尔曼·何乐礼在打孔卡片制表机（Tabulation Machine）, 排序器每次只能看到一个列。它是基于元素值的每个位上的字符来排序的。 对于数字而言就是分别基于个位，十位， 百位或千位等等数字来排序。</p>
<p>基数排序（Radix sort）是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</p>
<h4 id="1、基本思想-7"><a href="#1、基本思想-7" class="headerlink" title="1、基本思想"></a>1、基本思想</h4><p>它是这样实现的：将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。</p>
<p>基数排序按照优先从高位或低位来排序有两种实现方案：</p>
<ul>
<li><p><strong>MSD（Most significant digital） 从最左侧高位开始进行排序</strong>。先按k1排序分组, 同一组中记录, 关键码k1相等, 再对各组按k2排序分成子组, 之后, 对后面的关键码继续这样的排序分组, 直到按最次位关键码kd对各子组排序后. 再将各组连接起来, 便得到一个有序序列。<em>MSD方式适用于位数多的序列</em>。</p>
</li>
<li><p><strong>LSD （Least significant digital）从最右侧低位开始进行排序</strong>。先从kd开始排序，再对kd-1进行排序，依次重复，直到对k1排序后便得到一个有序序列。<em>LSD方式适用于位数少的序列</em>。</p>
</li>
</ul>
<p><img src="/gallery/sort-algorithms/radix-sort_sample.gif" alt="基数排序LSD动图演示"></p>
<h4 id="2、算法描述-7"><a href="#2、算法描述-7" class="headerlink" title="2、算法描述"></a>2、算法描述</h4><p>我们以LSD为例，从最低位开始，具体算法描述如下：</p>
<p>①. 取得数组中的最大数，并取得位数；<br>②. arr为原始数组，从最低位开始取每个位组成radix数组；<br>③. 对radix进行计数排序（利用计数排序适用于小范围数的特点）；</p>
<h4 id="3、代码实现-7"><a href="#3、代码实现-7" class="headerlink" title="3、代码实现"></a>3、代码实现</h4><p>基数排序：通过序列中各个元素的值，对排序的N个元素进行若干趟的“分配”与“收集”来实现排序。</p>
<ul>
<li><p><strong>分配</strong>：我们将L[i]中的元素取出，首先确定其个位上的数字，根据该数字分配到与之序号相同的桶中</p>
</li>
<li><p><strong>收集</strong>：当序列中所有的元素都分配到对应的桶中，再按照顺序依次将桶中的元素收集形成新的一个待排序列L[]。对新形成的序列L[]重复执行分配和收集元素中的十位、百位…直到分配完该序列中的最高位，则排序结束</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 基数排序（LSD 从低位开始）</div><div class="line"> *</div><div class="line"> * 基数排序适用于：</div><div class="line"> *  (1)数据范围较小，建议在小于1000</div><div class="line"> *  (2)每个数值都要大于等于0</div><div class="line"> *</div><div class="line"> * ①. 取得数组中的最大数，并取得位数；</div><div class="line"> * ②. arr为原始数组，从最低位开始取每个位组成radix数组；</div><div class="line"> * ③. 对radix进行计数排序（利用计数排序适用于小范围数的特点）；</div><div class="line"> * <span class="doctag">@param</span> arr	 待排序数组</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">radixSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(arr.length &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</div><div class="line"></div><div class="line">    <span class="comment">//取得数组中的最大数，并取得位数</span></div><div class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</div><div class="line">        <span class="keyword">if</span>(max &lt; arr[i])&#123;</div><div class="line">            max = arr[i];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> maxDigit = <span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span>(max / <span class="number">10</span> &gt; <span class="number">0</span>)&#123;</div><div class="line">        maxDigit++;</div><div class="line">        max = max / <span class="number">10</span>;</div><div class="line">    &#125;</div><div class="line">    System.out.println(<span class="string">"maxDigit: "</span> + maxDigit);</div><div class="line"></div><div class="line">    <span class="comment">//申请一个桶空间</span></div><div class="line">    <span class="keyword">int</span>[][] buckets = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][arr.length-<span class="number">1</span>];</div><div class="line">    <span class="keyword">int</span> base = <span class="number">10</span>;</div><div class="line"></div><div class="line">    <span class="comment">//从低位到高位，对每一位遍历，将所有元素分配到桶中</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxDigit; i++)&#123;</div><div class="line">        <span class="keyword">int</span>[] bktLen = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];        <span class="comment">//存储各个桶中存储元素的数量</span></div><div class="line">        </div><div class="line">        <span class="comment">//分配：将所有元素分配到桶中</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length; j++)&#123;</div><div class="line">            <span class="keyword">int</span> whichBucket = (arr[j] % base) / (base / <span class="number">10</span>);</div><div class="line">            buckets[whichBucket][bktLen[whichBucket]] = arr[j];</div><div class="line">            bktLen[whichBucket]++;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//收集：将不同桶里数据挨个捞出来,为下一轮高位排序做准备,由于靠近桶底的元素排名靠前,因此从桶底先捞</span></div><div class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> b = <span class="number">0</span>; b &lt; buckets.length; b++)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> p = <span class="number">0</span>; p &lt; bktLen[b]; p++)&#123;</div><div class="line">                arr[k++] = buckets[b][p];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        System.out.println(<span class="string">"Sorting: "</span> + Arrays.toString(arr));</div><div class="line">        base *= <span class="number">10</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以下是基数排序算法复杂度:</p>
<table>
<thead>
<tr>
<th>平均时间复杂度</th>
<th>最好情况</th>
<th>最坏情况</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>O(n * k)</td>
<td>O(n * k)</td>
<td>O(n * k)</td>
<td>O(k+N)</td>
</tr>
</tbody>
</table>
<p>基数排序更适合用于对时间, 字符串等这些<strong>整体权值未知的数据</strong>进行排序。</p>
<p>Tips: 基数排序不改变相同元素之间的相对顺序，因此它是稳定的排序算法。</p>
<p><strong>基数排序 vs 计数排序 vs 桶排序</strong></p>
<p>这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：</p>
<ol>
<li>基数排序：根据键值的每位数字来分配桶</li>
<li>计数排序：每个桶只存储单一键值</li>
<li>桶排序：每个桶存储一定范围的数值</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><hr>
<p>各种排序性能对比如下，有些排序未详细介绍，暂且放到这里:</p>
<table>
<thead>
<tr>
<th>排序类型</th>
<th>平均情况</th>
<th>最好情况</th>
<th>最坏情况</th>
<th>辅助空间</th>
<th>稳定性</th>
</tr>
</thead>
<tbody>
<tr>
<td>冒泡排序</td>
<td>O(n²)</td>
<td>O(n)</td>
<td>O(n²)</td>
<td>O(1)</td>
<td>稳定</td>
</tr>
<tr>
<td>选择排序</td>
<td>O(n²)</td>
<td>O(n²)</td>
<td>O(n²)</td>
<td>O(1)</td>
<td>不稳定</td>
</tr>
<tr>
<td>直接插入排序</td>
<td>O(n²)</td>
<td>O(n)</td>
<td>O(n²)</td>
<td>O(1)</td>
<td>稳定</td>
</tr>
<tr>
<td>折半插入排序</td>
<td>O(n²)</td>
<td>O(n)</td>
<td>O(n²)</td>
<td>O(1)</td>
<td>稳定</td>
</tr>
<tr>
<td>希尔排序</td>
<td>O(n^1.3)</td>
<td>O(nlogn)</td>
<td>O(n²)</td>
<td>O(1)</td>
<td>不稳定</td>
</tr>
<tr>
<td>归并排序</td>
<td>O(nlog₂n)</td>
<td>O(nlog₂n)</td>
<td>O(nlog₂n)</td>
<td>O(n)</td>
<td>稳定</td>
</tr>
<tr>
<td>快速排序</td>
<td>O(nlog₂n)</td>
<td>O(nlog₂n)</td>
<td>O(n²)</td>
<td>O(nlog₂n)</td>
<td>不稳定</td>
</tr>
<tr>
<td>堆排序</td>
<td>O(nlog₂n)</td>
<td>O(nlog₂n)</td>
<td>O(nlog₂n)</td>
<td>O(1)</td>
<td>不稳定</td>
</tr>
<tr>
<td>计数排序</td>
<td>O(n+k)</td>
<td>O(n+k)</td>
<td>O(n+k)</td>
<td>O(k)</td>
<td>稳定</td>
</tr>
<tr>
<td>桶排序</td>
<td>O(n+k)</td>
<td>O(n+k)</td>
<td>O(n²)</td>
<td>O(n+k)</td>
<td>(不)稳定</td>
</tr>
<tr>
<td>基数排序</td>
<td>O(d(n+k))</td>
<td>O(d(n+k))</td>
<td>O(d(n+kd))</td>
<td>O(n+kd)</td>
<td>稳定</td>
</tr>
</tbody>
</table>
<p>从时间复杂度来说：</p>
<p>(1). 平方阶O(n²)排序：<strong><code>各类简单排序：直接插入、直接选择和冒泡排序</code></strong>；</p>
<p>(2). 线性对数阶O(nlog₂n)排序：<strong><code>快速排序、堆排序和归并排序</code></strong>；</p>
<p>(3). O(n1+§))排序，§是介于0和1之间的常数：<strong><code>希尔排序</code></strong></p>
<p>(4). 线性阶O(n)排序：<strong><code>基数排序，此外还有桶、箱排序</code></strong>。
　　</p>
<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><ul>
<li>当原表有序或基本有序时，直接插入排序和冒泡排序将大大减少比较次数和移动记录的次数，时间复杂度可降至O（n）；</li>
<li>而快速排序则相反，当原表基本有序时，将蜕化为冒泡排序，时间复杂度提高为O（n2）；</li>
<li>原表是否有序，对简单选择排序、堆排序、归并排序和基数排序的时间复杂度影响不大。</li>
</ul>
<p><img src="/gallery/sort-algorithms/2016-07-15_常用排序算法.png" alt=""></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li>数据结构可视化：<a href="https://visualgo.net/zh" target="_blank" rel="external">visualgo</a>，<a href="https://www.toptal.com/developers/sorting-algorithms/" target="_blank" rel="external">Sorting Algorithms Animations</a>，<a href="https://codepen.io/iTimeTraveler/pen/dRrwZr" target="_blank" rel="external">CodePen</a> &amp; <a href="https://codepen.io/iTimeTraveler/pen/weORyW" target="_blank" rel="external">sort it out</a></li>
<li>排序算法测试：<a href="http://www.cse.chalmers.se/edu/course/DIT960/lab1-sorting.html" target="_blank" rel="external">Lab 1: Sorting - 哥德堡大学课件（University of Gothenburg）</a></li>
<li><a href="https://www.cs.cmu.edu/~adamchik/15-121/lectures/Sorting%20Algorithms/sorting.html" target="_blank" rel="external">Sorting - 卡内基梅隆大学课件</a></li>
<li><a href="http://www.jianshu.com/p/7d037c332a9d" target="_blank" rel="external">数据结构常见的八大排序算法（详细整理）</a></li>
<li><a href="http://www.jianshu.com/p/8c915179fd02" target="_blank" rel="external">必须知道的八大种排序算法【java实现】</a></li>
<li><a href="http://web.jobbole.com/87968/" target="_blank" rel="external">十大经典排序算法</a></li>
<li><a href="http://blog.jobbole.com/11745/" target="_blank" rel="external">视觉直观感受 7 种常用的排序算法</a></li>
<li><a href="http://louiszhai.github.io/2016/12/23/sort/" target="_blank" rel="external">JS中可能用得到的全部的排序算法</a></li>
<li><a href="http://www.cnblogs.com/minkaihui/p/4077888.html" target="_blank" rel="external">总结5种比较高效常用的排序算法</a></li>
<li><a href="http://www.cnblogs.com/zyb428/p/5673738.html" target="_blank" rel="external">常见排序算法C++总结</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;因为健忘，加上对各种排序算法理解不深刻，过段时间面对排序就蒙了。所以决定对我们常见的这几种排序算法进行统一总结，强行学习。首先罗列一下常见的十大排序算法：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/gallery/sort-algorithms/big-o.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;直接插入排序&lt;/li&gt;
&lt;li&gt;希尔排序&lt;/li&gt;
&lt;li&gt;简单选择排序&lt;/li&gt;
&lt;li&gt;堆排序&lt;/li&gt;
&lt;li&gt;冒泡排序&lt;/li&gt;
&lt;li&gt;快速排序&lt;/li&gt;
&lt;li&gt;归并排序&lt;/li&gt;
&lt;li&gt;基数排序&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://github.com/categories/Algorithm/"/>
    
    
      <category term="Java" scheme="http://github.com/tags/Java/"/>
    
      <category term="Algorithm" scheme="http://github.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>【算法】10亿int型数，统计只出现一次的数</title>
    <link href="http://github.com/2017/07/13/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%9110%E4%BA%BFint%E5%9E%8B%E6%95%B0%EF%BC%8C%E7%BB%9F%E8%AE%A1%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0/"/>
    <id>http://github.com/2017/07/13/【算法】10亿int型数，统计只出现一次的数/</id>
    <published>2017-07-13T10:30:55.000Z</published>
    <updated>2017-07-13T10:37:10.583Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a><strong>题目</strong></h2><p>10亿int整型数，以及一台可用内存为1GB的机器，时间复杂度要求O(n)，统计只出现一次的数？</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>首先分析多大的内存能够表示10亿的数呢？一个int型占4字节，10亿就是40亿字节（很明显就是4GB），也就是如果完全读入内存需要占用4GB，而题目只给1GB内存，显然不可能将所有数据读入内存。</p>
<p>我们先不考虑时间复杂度，仅考虑解决问题。那么接下来的思路一般有两种。</p>
<ol>
<li><strong>位图法</strong>：用一个bit位来标识一个int整数。</li>
<li><strong>分治法</strong>：分批处理这10亿的数。</li>
</ol>
<p>一种是位图法，如果各位老司机有经验的话很快会想到int整型数是4字节（Byte），也就是32位（bit），如果能用一个bit位来标识一个int整数那么存储空间将大大减少。另一种是分治法，内存有限，我想办法分批读取处理。下面大致分析一下两种思路。</p>
<a id="more"></a>
<h3 id="1、位图法（Bitmap）"><a href="#1、位图法（Bitmap）" class="headerlink" title="1、位图法（Bitmap）"></a>1、位图法（Bitmap）</h3><p>位图法是基于int型数的表示范围这个概念的，用一个bit位来标识一个int整数，若该位为1，则说明该数出现；若该位为0，则说明该数没有出现。一个int整型数占4字节（Byte），也就是32位（bit）。那么把所有int整型数字表示出来需要2^32 bit的空间，换算成字节单位也就是2^32/8 = 2^29 Byte，大约等于512MB</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 插播一个常识</span></div><div class="line"><span class="number">2</span>^<span class="number">10</span> Byte = <span class="number">1024</span> Byte = <span class="number">1</span>KB</div><div class="line"><span class="number">2</span>^<span class="number">30</span> Byte = (<span class="number">2</span>^<span class="number">10</span>)^<span class="number">3</span> Byte = <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1024</span> Byte = <span class="number">1</span>GB</div></pre></td></tr></table></figure>
<p>这下就好办了，只需要用512MB的内存就能存储所有的int的范围数。</p>
<h4 id="具体方案"><a href="#具体方案" class="headerlink" title="具体方案"></a>具体方案</h4><p>那么接下来我们只需要申请一个int数组长度为 int tmp[<strong>N/32+1</strong>]即可存储完这些数据，其中<strong>N代表要进行查找的总数（这里也就是2^32）</strong>，tmp中的每个元素在内存在占32位可以对应表示十进制数0~31,所以可得到BitMap表:</p>
<ul>
<li>tmp[0]:可表示0~31</li>
<li>tmp[1]:可表示32~63</li>
<li>tmp[2]可表示64~95</li>
<li>~~</li>
</ul>
<p>假设这10亿int数据为：6,3,8,32,36,……，那么具体的BitMap表示为：</p>
<p><img src="/gallery/bitmap/37237-20160302211041080-958649492.png" alt=""></p>
<p>(1).  如何判断int数字放在哪一个tmp数组中：将数字直接除以32取整数部分(x/32)，例如：整数8除以32取整等于0，那么8就在tmp[0]上；</p>
<p>(2).  如何确定数字放在32个位中的哪个位：将数字mod32取模(x%32)。上例中我们如何确定8在tmp[0]中的32个位中的哪个位，这种情况直接mod上32就ok，又如整数8，在tmp[0]中的第8 mod上32等于8，那么整数8就在tmp[0]中的第八个bit位（从右边数起）。</p>
<p>然后我们怎么统计只出现一次的数呢？每一个数出现的情况我们可以分为三种：0次、1次、大于1次。也就是说我们需要用2个bit位才能表示每个数的出现情况。此时则三种情况分别对应的bit位表示是：00、01、11</p>
<p>我们顺序扫描这10亿的数，在对应的双bit位上标记该数出现的次数。最后取出所有双bit位为01的int型数就可以了。</p>
<h4 id="Bitmap拓展"><a href="#Bitmap拓展" class="headerlink" title="Bitmap拓展"></a>Bitmap拓展</h4><p>位图（Bitmap）算法思想比较简单，但关键是如何确定十进制的数映射到二进制bit位的map图。</p>
<p><strong>优点：</strong></p>
<ol>
<li><p>运算效率高，不许进行比较和移位；</p>
</li>
<li><p>占用内存少，比如N=10000000；只需占用内存为N/8=1250000Byte=1.25M</p>
</li>
</ol>
<p><strong>缺点：</strong>所有的数据不能重复。即不可对重复的数据进行排序和查找。</p>
<p> 建立了Bit-Map之后，就可以方便的使用了。一般来说Bit-Map可作为数据的<strong>查找、去重、排序</strong>等操作。比如以下几个例子：</p>
<blockquote>
<p> 1、在3亿个整数中找出重复的整数个数，限制内存不足以容纳3亿个整数</p>
</blockquote>
<p>对于这种场景可以采用2-BitMap来解决，即为每个整数分配2bit，用不同的0、1组合来标识特殊意思，如00表示此整数没有出现过，01表示出现一次，11表示出现过多次，就可以找出重复的整数了，其需要的内存空间是正常BitMap的2倍，为：3亿*2/8/1024/1024=71.5MB。</p>
<p><strong>具体的过程如下：</strong>扫描着3亿个整数，组BitMap，先查看BitMap中的对应位置，如果00则变成01，是01则变成11，是11则保持不变，当将3亿个整数扫描完之后也就是说整个BitMap已经组装完毕。最后查看BitMap将对应位为11的整数输出即可。</p>
<blockquote>
<p> 2、对没有重复元素的整数进行排序</p>
</blockquote>
<p>对于非重复的整数排序BitMap有着天然的优势，它只需要将给出的无重复整数扫描完毕，组装成为BitMap之后，那么直接遍历一遍Bit区域就可以达到排序效果了。</p>
<p>举个例子：对整数4、3、1、7、6进行排序：</p>
<p><img src="/gallery/bitmap/37237-20160302215109220-1394239868.png" alt=""></p>
<p>直接按Bit位输出就可以得到排序结果了。</p>
<blockquote>
<p> 3、已知某个文件内包含一些电话号码，每个号码为8位数字，统计不同号码的个数</p>
</blockquote>
<p>8位最多99 999 999，大概需要99m个bit，大概10几m字节的内存即可。可以理解为从0-99 999 999的数字，每个数字对应一个Bit位，所以只需要99M个Bit==1.2MBytes，这样，就用了小小的1.2M左右的内存表示了所有的8位数的电话。</p>
<blockquote>
<p> 4、2.5亿个整数中找出不重复的整数的个数，内存空间不足以容纳这2.5亿个整数</p>
</blockquote>
<p>将bit-map扩展一下，用2bit表示一个数即可：0表示未出现；1表示出现一次；2表示出现2次及以上，即重复，在遍历这些数的时候，如果对应位置的值是0，则将其置为1；如果是1，将其置为2；如果是2，则保持不变。或者我们不用2bit来进行表示，我们用两个bit-map即可模拟实现这个2bit-map，都是一样的道理。</p>
<p>最后放一个使用Byte[]数组存储、读取bit位的示例代码，来自<a href="http://yacare.iteye.com/blog/1969931" target="_blank" rel="external">利用位映射原理对大数据排重</a>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BitmapTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY = <span class="number">1000000000</span>;<span class="comment">//数据容量</span></div><div class="line"></div><div class="line">    <span class="comment">// 定义一个byte数组缓存所有的数据</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] dataBytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1</span> &lt;&lt; <span class="number">29</span>];</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        BitmapTest ms = <span class="keyword">new</span> BitmapTest();</div><div class="line"></div><div class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">        Random random = <span class="keyword">new</span> Random();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; CAPACITY; i++) &#123;</div><div class="line">            <span class="keyword">int</span> num = random.nextInt();</div><div class="line">            System.out.println(<span class="string">"读取了第 "</span> + (i + <span class="number">1</span>) + <span class="string">"\t个数: "</span> + num);</div><div class="line">            bytes = ms.splitBigData(num);</div><div class="line">        &#125;</div><div class="line">        System.out.println(<span class="string">""</span>);</div><div class="line">        ms.output(bytes);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 读取数据，并将对应数数据的 到对应的bit中，并返回byte数组</div><div class="line">     * <span class="doctag">@param</span> num 读取的数据</div><div class="line">     * <span class="doctag">@return</span> byte数组  dataBytes</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] splitBigData(<span class="keyword">int</span> num) &#123;</div><div class="line"></div><div class="line">        <span class="keyword">long</span> bitIndex = num + (<span class="number">1l</span> &lt;&lt; <span class="number">31</span>);         <span class="comment">//获取num数据对应bit数组（虚拟）的索引</span></div><div class="line">        <span class="keyword">int</span> index = (<span class="keyword">int</span>) (bitIndex / <span class="number">8</span>);         <span class="comment">//bit数组（虚拟）在byte数组中的索引</span></div><div class="line">        <span class="keyword">int</span> innerIndex = (<span class="keyword">int</span>) (bitIndex % <span class="number">8</span>);    <span class="comment">//bitIndex 在byte[]数组索引index 中的具体位置</span></div><div class="line"></div><div class="line">        System.out.println(<span class="string">"byte["</span> + index + <span class="string">"] 中的索引："</span> + innerIndex);</div><div class="line"></div><div class="line">        dataBytes[index] = (<span class="keyword">byte</span>) (dataBytes[index] | (<span class="number">1</span> &lt;&lt; innerIndex));</div><div class="line">        <span class="keyword">return</span> dataBytes;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 输出数组中的数据</div><div class="line">     * <span class="doctag">@param</span> bytes byte数组</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">output</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bytes.length; i++) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j++) &#123;</div><div class="line">                <span class="keyword">if</span> (!(((bytes[i]) &amp; (<span class="number">1</span> &lt;&lt; j)) == <span class="number">0</span>)) &#123;</div><div class="line">                    count++;</div><div class="line">                    <span class="keyword">int</span> number = (<span class="keyword">int</span>) ((((<span class="keyword">long</span>) i * <span class="number">8</span> + j) - (<span class="number">1l</span> &lt;&lt; <span class="number">31</span>)));</div><div class="line">                    System.out.println(<span class="string">"取出的第  "</span> + count + <span class="string">"\t个数: "</span> +  number);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2、分治法"><a href="#2、分治法" class="headerlink" title="2、分治法"></a>2、分治法</h3><p>分治法目前看到的解决方案有<strong>哈希分桶（Hash Buckets）</strong>和<strong>归并排序</strong>两种方案。</p>
<p>哈希分桶的思想是先遍历一遍，按照hash分N桶（比如1000桶），映射到不同的文件中。这样平均每个文件就10MB，然后分别处理这1000个文件，找出没有重复的即可。一个相同的数字，绝对不会夸文件，<a href="https://maimai.cn/web/gossip_detail?src=app&amp;webid=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1IjozNDM5ODY0MiwiaWQiOjgzODU0NDR9.zf_21BO_wwAo0t1D8UdKAC9tKXv2TuphOhGnKtCq51E" target="_blank" rel="external">有hash做保证</a>。因为算法具体还不甚了解，这里先不做详细介绍。</p>
<p>归并排序的思想可以参考这篇文章：<a href="http://www.cnblogs.com/cnyao/archive/2009/11/09/interview7.html" target="_blank" rel="external">面试题之10亿正整数问题续–关于多通道排序的问题</a></p>
<hr>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="http://blog.csdn.net/v_july_v/article/details/6451990" target="_blank" rel="external">程序员编程艺术：第十章、如何给10^7个数据量的磁盘文件排序</a></li>
<li><a href="http://www.cnblogs.com/cnyao/archive/2009/11/09/interview7.html" target="_blank" rel="external">面试题之10亿正整数问题续–关于多通道排序的问题</a></li>
<li><a href="http://yacare.iteye.com/blog/1969931" target="_blank" rel="external">利用位映射原理对大数据排重</a></li>
<li><a href="http://blog.csdn.net/v_july_v/article/details/6279498" target="_blank" rel="external">十道海量数据处理面试题与十个方法大总结</a></li>
<li><a href="http://www.cnblogs.com/moonandstar08/p/5236539.html" target="_blank" rel="external">海量数据处理之BitMap</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;10亿int整型数，以及一台可用内存为1GB的机器，时间复杂度要求O(n)，统计只出现一次的数？&lt;/p&gt;
&lt;h2 id=&quot;分析&quot;&gt;&lt;a href=&quot;#分析&quot; class=&quot;headerlink&quot; title=&quot;分析&quot;&gt;&lt;/a&gt;分析&lt;/h2&gt;&lt;p&gt;首先分析多大的内存能够表示10亿的数呢？一个int型占4字节，10亿就是40亿字节（很明显就是4GB），也就是如果完全读入内存需要占用4GB，而题目只给1GB内存，显然不可能将所有数据读入内存。&lt;/p&gt;
&lt;p&gt;我们先不考虑时间复杂度，仅考虑解决问题。那么接下来的思路一般有两种。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;位图法&lt;/strong&gt;：用一个bit位来标识一个int整数。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;分治法&lt;/strong&gt;：分批处理这10亿的数。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;一种是位图法，如果各位老司机有经验的话很快会想到int整型数是4字节（Byte），也就是32位（bit），如果能用一个bit位来标识一个int整数那么存储空间将大大减少。另一种是分治法，内存有限，我想办法分批读取处理。下面大致分析一下两种思路。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://github.com/categories/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://github.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>遗传算法的基本概念和Java实现</title>
    <link href="http://github.com/2017/07/11/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8CJava%E5%AE%9E%E7%8E%B0/"/>
    <id>http://github.com/2017/07/11/遗传算法的基本概念和Java实现/</id>
    <published>2017-07-11T10:30:55.000Z</published>
    <updated>2017-07-11T10:57:00.982Z</updated>
    
    <content type="html"><![CDATA[<p>基因遗传算法是一种灵感源于达尔文自然进化理论的启发式搜索算法。该算法反映了自然选择的过程，即最适者被选定繁殖，并产生下一代。本文简要地介绍了遗传算法的基本概念和实现，希望能为读者展示启发式搜索的魅力。</p>
<p><img src="/gallery/genetic-algorithms/1-BYDJpa6M2rzWNSurvspf8Q.png" alt="如上图（左）所示，遗传算法的个体由多条染色体组成，每条染色体由多个基因组成。上图（右）展示了染色体分割和组合的方式。"></p>
<a id="more"></a>
<h3 id="遗传算法的概念"><a href="#遗传算法的概念" class="headerlink" title="遗传算法的概念"></a><strong>遗传算法的概念</strong></h3><p>自然选择的过程从选择群体中最适应环境的个体开始。后代继承了父母的特性，并且这些特性将添加到下一代中。如果父母具有更好的适应性，那么它们的后代将更易于存活。迭代地进行该自然选择的过程，最终，我们将得到由最适应环境的个体组成的一代。</p>
<p>这一概念可以被应用于搜索问题中。我们考虑一个问题的诸多解决方案，并从中搜寻出最佳方案。</p>
<p>遗传算法含以下五步：</p>
<ol>
<li>初始化</li>
<li>个体评价（计算适应度函数）</li>
<li>选择运算</li>
<li>交叉运算</li>
<li>变异运算</li>
</ol>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a><strong>初始化</strong></h4><p>该过程从种群的一组个体开始，且每一个体都是待解决问题的一个候选解。</p>
<p>个体以一组参数（变量）为特征，这些特征被称为基因，串联这些基因就可以组成染色体（问题的解）。</p>
<p>在遗传算法中，单个个体的基因组以字符串的方式呈现，通常我们可以使用二进制（1 和 0 的字符串）编码，即一个二进制串代表一条染色体串。因此可以说我们将基因串或候选解的特征编码在染色体中。</p>
<p><img src="/gallery/genetic-algorithms/1-vIrsxg12DSltpdWoO561yA.png" alt="*种群、染色体和基因*"></p>
<h4 id="个体评价（计算适应度函数）"><a href="#个体评价（计算适应度函数）" class="headerlink" title="个体评价（计算适应度函数）"></a><strong>个体评价（计算适应度函数）</strong></h4><p>个体评价利用适应度函数评估了该个体对环境的适应度（与其它个体竞争的能力）。每一个体都有适应度评分，个体被选中进行繁殖的可能性取决于其适应度评分。适应度函数值越大，解的质量就越高。适应度函数是遗传算法进化的驱动力，也是进行自然选择的唯一标准，它的设计应结合求解问题本身的要求而定。</p>
<h4 id="选择运算"><a href="#选择运算" class="headerlink" title="选择运算"></a><strong>选择运算</strong></h4><p>选择运算的目的是选出适应性最好的个体，并使它们将基因传到下一代中。基于其适应度评分，我们选择多对较优个体（父母）。适应度高的个体更易被选中繁殖，即将较优父母的基因传递到下一代。</p>
<h4 id="交叉运算"><a href="#交叉运算" class="headerlink" title="交叉运算"></a><strong>交叉运算</strong></h4><p>交叉运算是遗传算法中最重要的阶段。对每一对配对的父母，基因都存在随机选中的交叉点。</p>
<p>举个例子，下图的交叉点为 3：</p>
<p><img src="/gallery/genetic-algorithms/1-Wi6ou9jyMHdxrF2dgczz7g.png" alt="Crossover point"></p>
<p>父母间在交叉点之前交换基因，从而产生了后代。</p>
<p><img src="/gallery/genetic-algorithms/1-eQxFezBtdfdLxHsvSvBNGQ.png" alt="Exchanging genes among parents"></p>
<p>父母间交换基因，然后产生的新后代被添加到种群中。</p>
<p><img src="/gallery/genetic-algorithms/1-_Dl6Hwkay-UU24DJ_oVrLw.png" alt="New offspring"></p>
<h4 id="变异运算"><a href="#变异运算" class="headerlink" title="变异运算"></a><strong>变异运算</strong></h4><p>在某些形成的新后代中，它们的某些基因可能受到低概率变异因子的作用。这意味着二进制位串中的某些位可能会翻转。</p>
<p><img src="/gallery/genetic-algorithms/1-CGt_UhRqCjIDb7dqycmOAg.png" alt="变异运算前后"></p>
<p>变异运算可用于保持种群内的多样性，并防止过早收敛。</p>
<h4 id="终止"><a href="#终止" class="headerlink" title="终止"></a><strong>终止</strong></h4><p>在群体收敛的情况下（群体内不产生与前一代差异较大的后代）该算法终止。也就是说遗传算法提供了一组问题的解。</p>
<h3 id="案例实现"><a href="#案例实现" class="headerlink" title="案例实现"></a><strong>案例实现</strong></h3><p>种群的规模恒定。新一代形成时，适应度最差的个体凋亡，为后代留出空间。这些阶段的序列被不断重复，以产生优于先前的新一代。</p>
<p>这一迭代过程的伪代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">START</div><div class="line">Generate the initial population</div><div class="line">Compute fitness</div><div class="line">REPEAT</div><div class="line">    Selection</div><div class="line">    Crossover</div><div class="line">    Mutation</div><div class="line">    Compute fitness</div><div class="line">UNTIL population has converged</div><div class="line">STOP</div></pre></td></tr></table></figure>
<h4 id="Java-中的实例实现"><a href="#Java-中的实例实现" class="headerlink" title="Java 中的实例实现"></a><strong>Java 中的实例实现</strong></h4><p>以下展示的是遗传算法在 Java 中的示例实现，我们可以随意调试和修改这些代码。给定一组五个基因，每一个基因可以保存一个二进制值 0 或 1。这里的适应度是基因组中 1 的数量。如果基因组内共有五个 1，则该个体适应度达到最大值。如果基因组内没有 1，那么个体的适应度达到最小值。该遗传算法希望最大化适应度，并提供适应度达到最大的个体所组成的群体。注意：本例中，在交叉运算与突变运算之后，适应度最低的个体被新的，适应度最高的后代所替代。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Random;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> *</div><div class="line"> * <span class="doctag">@author</span> Vijini</div><div class="line"> */</div><div class="line"></div><div class="line"><span class="comment">//Main class</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleDemoGA</span> </span>&#123;</div><div class="line"></div><div class="line">    Population population = <span class="keyword">new</span> Population();</div><div class="line">    Individual fittest;</div><div class="line">    Individual secondFittest;</div><div class="line">    <span class="keyword">int</span> generationCount = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">        Random rn = <span class="keyword">new</span> Random();</div><div class="line">        </div><div class="line">        SimpleDemoGA demo = <span class="keyword">new</span> SimpleDemoGA();</div><div class="line">        </div><div class="line">        <span class="comment">//Initialize population</span></div><div class="line">        demo.population.initializePopulation(<span class="number">10</span>);</div><div class="line">        </div><div class="line">        <span class="comment">//Calculate fitness of each individual</span></div><div class="line">        demo.population.calculateFitness();</div><div class="line">        </div><div class="line">        System.out.println(<span class="string">"Generation: "</span> + demo.generationCount + <span class="string">" Fittest: "</span> + demo.population.fittest);</div><div class="line"></div><div class="line">        <span class="comment">//While population gets an individual with maximum fitness</span></div><div class="line">        <span class="keyword">while</span> (demo.population.fittest &lt; <span class="number">5</span>) &#123;</div><div class="line">            ++demo.generationCount;</div><div class="line">            </div><div class="line">            <span class="comment">//Do selection</span></div><div class="line">            demo.selection();</div><div class="line">            </div><div class="line">            <span class="comment">//Do crossover</span></div><div class="line">            demo.crossover();</div><div class="line">            </div><div class="line">            <span class="comment">//Do mutation under a random probability</span></div><div class="line">            <span class="keyword">if</span> (rn.nextInt()%<span class="number">7</span> &lt; <span class="number">5</span>) &#123;</div><div class="line">                demo.mutation();</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="comment">//Add fittest offspring to population</span></div><div class="line">            demo.addFittestOffspring();</div><div class="line">            </div><div class="line">            <span class="comment">//Calculate new fitness value </span></div><div class="line">            demo.population.calculateFitness();</div><div class="line">            </div><div class="line">            System.out.println(<span class="string">"Generation: "</span> + demo.generationCount + <span class="string">" Fittest: "</span> + demo.population.fittest);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        System.out.println(<span class="string">"\nSolution found in generation "</span> + demo.generationCount);</div><div class="line">        System.out.println(<span class="string">"Fitness: "</span>+demo.population.getFittest().fitness);</div><div class="line">        System.out.print(<span class="string">"Genes: "</span>);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line">            System.out.print(demo.population.getFittest().genes[i]);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        System.out.println(<span class="string">""</span>);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//Selection</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">selection</span><span class="params">()</span> </span>&#123;</div><div class="line">        </div><div class="line">        <span class="comment">//Select the most fittest individual</span></div><div class="line">        fittest = population.getFittest();</div><div class="line">        </div><div class="line">        <span class="comment">//Select the second most fittest individual</span></div><div class="line">        secondFittest = population.getSecondFittest();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//Crossover</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">crossover</span><span class="params">()</span> </span>&#123;</div><div class="line">        Random rn = <span class="keyword">new</span> Random();</div><div class="line">        </div><div class="line">        <span class="comment">//Select a random crossover point</span></div><div class="line">        <span class="keyword">int</span> crossOverPoint = rn.nextInt(population.individuals[<span class="number">0</span>].geneLength);</div><div class="line"></div><div class="line">        <span class="comment">//Swap values among parents</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; crossOverPoint; i++) &#123;</div><div class="line">            <span class="keyword">int</span> temp = fittest.genes[i];</div><div class="line">            fittest.genes[i] = secondFittest.genes[i];</div><div class="line">            secondFittest.genes[i] = temp;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//Mutation</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mutation</span><span class="params">()</span> </span>&#123;</div><div class="line">        Random rn = <span class="keyword">new</span> Random();</div><div class="line">        </div><div class="line">        <span class="comment">//Select a random mutation point</span></div><div class="line">        <span class="keyword">int</span> mutationPoint = rn.nextInt(population.individuals[<span class="number">0</span>].geneLength);</div><div class="line"></div><div class="line">        <span class="comment">//Flip values at the mutation point</span></div><div class="line">        <span class="keyword">if</span> (fittest.genes[mutationPoint] == <span class="number">0</span>) &#123;</div><div class="line">            fittest.genes[mutationPoint] = <span class="number">1</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            fittest.genes[mutationPoint] = <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        mutationPoint = rn.nextInt(population.individuals[<span class="number">0</span>].geneLength);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (secondFittest.genes[mutationPoint] == <span class="number">0</span>) &#123;</div><div class="line">            secondFittest.genes[mutationPoint] = <span class="number">1</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            secondFittest.genes[mutationPoint] = <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//Get fittest offspring</span></div><div class="line">    <span class="function">Individual <span class="title">getFittestOffspring</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (fittest.fitness &gt; secondFittest.fitness) &#123;</div><div class="line">            <span class="keyword">return</span> fittest;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> secondFittest;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">//Replace least fittest individual from most fittest offspring</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addFittestOffspring</span><span class="params">()</span> </span>&#123;</div><div class="line">        </div><div class="line">        <span class="comment">//Update fitness values of offspring</span></div><div class="line">        fittest.calcFitness();</div><div class="line">        secondFittest.calcFitness();</div><div class="line">        </div><div class="line">        <span class="comment">//Get index of least fit individual</span></div><div class="line">        <span class="keyword">int</span> leastFittestIndex = population.getLeastFittestIndex();</div><div class="line">        </div><div class="line">        <span class="comment">//Replace least fittest individual from most fittest offspring</span></div><div class="line">        population.individuals[leastFittestIndex] = getFittestOffspring();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//Individual class</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Individual</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> fitness = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span>[] genes = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</div><div class="line">    <span class="keyword">int</span> geneLength = <span class="number">5</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Individual</span><span class="params">()</span> </span>&#123;</div><div class="line">        Random rn = <span class="keyword">new</span> Random();</div><div class="line"></div><div class="line">        <span class="comment">//Set genes randomly for each individual</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; genes.length; i++) &#123;</div><div class="line">            genes[i] = rn.nextInt() % <span class="number">2</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        fitness = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//Calculate fitness</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">calcFitness</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">        fitness = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (genes[i] == <span class="number">1</span>) &#123;</div><div class="line">                ++fitness;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//Population class</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Population</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> popSize = <span class="number">10</span>;</div><div class="line">    Individual[] individuals = <span class="keyword">new</span> Individual[<span class="number">10</span>];</div><div class="line">    <span class="keyword">int</span> fittest = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">//Initialize population</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initializePopulation</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; individuals.length; i++) &#123;</div><div class="line">            individuals[i] = <span class="keyword">new</span> Individual();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//Get the fittest individual</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Individual <span class="title">getFittest</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> maxFit = Integer.MIN_VALUE;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; individuals.length; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (maxFit &lt;= individuals[i].fitness) &#123;</div><div class="line">                maxFit = i;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        fittest = individuals[maxFit].fitness;</div><div class="line">        <span class="keyword">return</span> individuals[maxFit];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//Get the second most fittest individual</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Individual <span class="title">getSecondFittest</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> maxFit1 = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> maxFit2 = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; individuals.length; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (individuals[i].fitness &gt; individuals[maxFit1].fitness) &#123;</div><div class="line">                maxFit2 = maxFit1;</div><div class="line">                maxFit1 = i;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (individuals[i].fitness &gt; individuals[maxFit2].fitness) &#123;</div><div class="line">                maxFit2 = i;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> individuals[maxFit2];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//Get index of least fittest individual</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLeastFittestIndex</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> minFit = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; individuals.length; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (minFit &gt;= individuals[i].fitness) &#123;</div><div class="line">                minFit = i;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> minFit;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//Calculate fitness of each individual</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">calculateFitness</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; individuals.length; i++) &#123;</div><div class="line">            individuals[i].calcFitness();</div><div class="line">        &#125;</div><div class="line">        getFittest();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>原文来自：<a href="https://medium.com/towards-data-science/introduction-to-genetic-algorithms-including-example-code-e396e98d8bf3" target="_blank" rel="external">Introduction to Genetic Algorithms — Including Example Code</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;基因遗传算法是一种灵感源于达尔文自然进化理论的启发式搜索算法。该算法反映了自然选择的过程，即最适者被选定繁殖，并产生下一代。本文简要地介绍了遗传算法的基本概念和实现，希望能为读者展示启发式搜索的魅力。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/gallery/genetic-algorithms/1-BYDJpa6M2rzWNSurvspf8Q.png&quot; alt=&quot;如上图（左）所示，遗传算法的个体由多条染色体组成，每条染色体由多个基因组成。上图（右）展示了染色体分割和组合的方式。&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://github.com/categories/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://github.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>【Java】Integer变量相等（==）比较问题</title>
    <link href="http://github.com/2017/07/11/%E3%80%90Java%E3%80%91Integer%E5%8F%98%E9%87%8F%E7%9B%B8%E7%AD%89%EF%BC%88==%EF%BC%89%E6%AF%94%E8%BE%83%E9%97%AE%E9%A2%98/"/>
    <id>http://github.com/2017/07/11/【Java】Integer变量相等（==）比较问题/</id>
    <published>2017-07-11T04:30:55.000Z</published>
    <updated>2017-07-11T05:12:03.274Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>这是关于一段令人疑惑的Java代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestIntegerCache</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        Integer i3 = <span class="number">100</span>;</div><div class="line">        Integer i4 = <span class="number">100</span>;</div><div class="line">        System.out.println(i3 == i4);</div><div class="line"></div><div class="line">        Integer i5 = <span class="number">1000</span>;</div><div class="line">        Integer i6 = <span class="number">1000</span>;</div><div class="line">        System.out.println(i5 == i6);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这么简单，执行结果是什么？</p>
<blockquote>
<p>true<br>false</p>
</blockquote>
<p>一个是true，一个是false！<br>这是为什么呢？为什么和大多数人心里想的不一样！</p>
<a id="more"></a>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>根据Java编译机制，<code>.java</code>文件在编译以后会生成.class文件给JVM加载执行，于是找到.class文件，反编译看了一下，发现编译器在编译我们的代码时，很调皮（聪明的）的在我们声明的变量加上了<code>valueOf</code>方法 ，代码变成了如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestIntegerCache</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        Integer i3 = Integer.valueOf(<span class="number">100</span>);</div><div class="line">        Integer i4 = Integer.valueOf(<span class="number">100</span>);</div><div class="line">        System.out.println(i3 == i4);</div><div class="line"></div><div class="line">        Integer i5 = Integer.valueOf(<span class="number">1000</span>);</div><div class="line">        Integer i6 = Integer.valueOf(<span class="number">1000</span>);</div><div class="line">        System.out.println(i5 == i6);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>valueOf()</code> 方法对它做了什么，我们看看源代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">     * Returns an &#123;<span class="doctag">@code</span> Integer&#125; instance representing the specified</div><div class="line">     * &#123;<span class="doctag">@code</span> int&#125; value.  If a new &#123;<span class="doctag">@code</span> Integer&#125; instance is not</div><div class="line">     * required, this method should generally be used in preference to</div><div class="line">     * the constructor &#123;<span class="doctag">@link</span> #Integer(int)&#125;, as this method is likely</div><div class="line">     * to yield significantly better space and time performance by</div><div class="line">     * caching frequently requested values.</div><div class="line">     *</div><div class="line">     * This method will always cache values in the range -128 to 127,</div><div class="line">     * inclusive, and may cache other values outside of this range.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span>  i an &#123;<span class="doctag">@code</span> int&#125; value.</div><div class="line">     * <span class="doctag">@return</span> an &#123;<span class="doctag">@code</span> Integer&#125; instance representing &#123;<span class="doctag">@code</span> i&#125;.</div><div class="line">     * <span class="doctag">@since</span>  1.5</div><div class="line">     */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)    <span class="comment">//我们看到这里有个缓存，在缓存区间就返回缓存里的</span></div><div class="line">            <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];   <span class="comment">//缓存数组相应的对象</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);    <span class="comment">//不在缓存数组区间就new一个对象</span></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>我们发现，Integer的作者在写这个类时，为了避免重复创建对象，对Integer值做了缓存，如果这个值在缓存范围内，直接返回缓存好的对象，否则new一个新的对象返回，那究竟这个缓存到底缓存了哪些内容呢？看一下<code>IntegerCache</code>这个类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">     * Cache to support the object identity semantics of autoboxing for values between</div><div class="line">     * -128 and 127 (inclusive) as required by JLS.</div><div class="line">     *</div><div class="line">     * The cache is initialized on first usage.  The size of the cache</div><div class="line">     * may be controlled by the &#123;<span class="doctag">@code</span> -XX:AutoBoxCacheMax=&lt;size&gt;&#125; option.</div><div class="line">     * During VM initialization, java.lang.Integer.IntegerCache.high property</div><div class="line">     * may be set and saved in the private system properties in the</div><div class="line">     * sun.misc.VM class.</div><div class="line">     */</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</div><div class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</div><div class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</div><div class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</div><div class="line"></div><div class="line">        <span class="keyword">static</span> &#123;</div><div class="line">	        <span class="comment">//检查虚拟机里是否有缓存区间配置项，如果有就赋成该值，没有就默认[-128, 127]</span></div><div class="line">            <span class="comment">// high value may be configured by property</span></div><div class="line">            <span class="keyword">int</span> h = <span class="number">127</span>;</div><div class="line">            String integerCacheHighPropValue =</div><div class="line">                sun.misc.VM.getSavedProperty(<span class="string">"java.lang.Integer.IntegerCache.high"</span>);</div><div class="line">            <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    <span class="keyword">int</span> i = parseInt(integerCacheHighPropValue);</div><div class="line">                    i = Math.max(i, <span class="number">127</span>);</div><div class="line">                    <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></div><div class="line">                    h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</div><div class="line">                &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</div><div class="line">                    <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            high = h;</div><div class="line"></div><div class="line">			<span class="comment">//创建缓存数组，并初始化（缓存值）</span></div><div class="line">            cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</div><div class="line">            <span class="keyword">int</span> j = low;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</div><div class="line">                cache[k] = <span class="keyword">new</span> Integer(j++);</div><div class="line"></div><div class="line">            <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></div><div class="line">            <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">private</span> <span class="title">IntegerCache</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这是一个内部静态类，该类只能在Integer这个类的内部访问，这个类在初始化的时候，会去加载JVM的配置，如果有值，就用配置的值初始化缓存数组，否则就缓存<strong><code>-128</code></strong>到<strong><code>127</code></strong>之间的值。<br>再来看看我们之前的代码：</p>
<p><img src="http://img.blog.csdn.net/20170711124934286" alt=""></p>
<p>看完这个，是不是明白了呢</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxMzQ3NzQ3Nw==&amp;mid=2654250496&amp;idx=1&amp;sn=dad9b1ade6dca4b57020b1bc091df5fb&amp;chksm=8061f50ab7167c1c2672456b1e9f9b4293f6cab49deb08970874f7ae03fd186461acad02e389&amp;mpshare=1&amp;scene=1&amp;srcid=0711yYY7UjcX2zsrDcna3QVp#rd" target="_blank" rel="external">让人疑惑的代码，竟成大多公司面试题热门！</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;这是关于一段令人疑惑的Java代码:&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;TestIntegerCache&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        Integer i3 = &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        Integer i4 = &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        System.out.println(i3 == i4);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        Integer i5 = &lt;span class=&quot;number&quot;&gt;1000&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        Integer i6 = &lt;span class=&quot;number&quot;&gt;1000&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        System.out.println(i5 == i6);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这么简单，执行结果是什么？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;true&lt;br&gt;false&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一个是true，一个是false！&lt;br&gt;这是为什么呢？为什么和大多数人心里想的不一样！&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://github.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://github.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java 8系列之重新认识HashMap</title>
    <link href="http://github.com/2017/06/16/Java%208%E7%B3%BB%E5%88%97%E4%B9%8B%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86HashMap/"/>
    <id>http://github.com/2017/06/16/Java 8系列之重新认识HashMap/</id>
    <published>2017-06-16T09:30:55.000Z</published>
    <updated>2017-06-19T10:28:36.941Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>本文来自美团点评技术团队： <a href="http://tech.meituan.com/java-hashmap.html" target="_blank" rel="external">Java 8系列之重新认识HashMap</a></p>
</blockquote>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a><strong>摘要</strong></h2><p>HashMap是Java程序员使用频率最高的用于映射(键值对)处理的数据类型。随着JDK（Java Developmet Kit）版本的更新，JDK1.8对HashMap底层的实现进行了优化，例如引入红黑树的数据结构和扩容的优化等。本文结合JDK1.7和JDK1.8的区别，深入探讨HashMap的结构实现和功能原理。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a><strong>简介</strong></h2><p>Java为数据结构中的映射定义了一个接口java.util.Map，此接口主要有四个常用的实现类，分别是<code>HashMap</code>、<code>Hashtable</code>、<code>LinkedHashMap</code>和<code>TreeMap</code>，类继承关系如下图所示：</p>
<p><img src="http://img.blog.csdn.net/20170616165413193" alt=""></p>
<a id="more"></a>
<p>下面针对各个实现类的特点做一些说明：</p>
<p>(1) <strong>HashMap</strong>：它根据键的hashCode值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。 HashMap最多只允许一条记录的键为null，允许多条记录的值为null。HashMap非线程安全，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致。如果需要满足线程安全，可以用 Collections的synchronizedMap方法使HashMap具有线程安全的能力，或者使用ConcurrentHashMap。</p>
<p>(2) <strong>Hashtable</strong>：Hashtable是遗留类，很多映射的常用功能与HashMap类似，不同的是它承自Dictionary类，并且是线程安全的，任一时间只有一个线程能写Hashtable，并发性不如ConcurrentHashMap，因为ConcurrentHashMap引入了分段锁。Hashtable不建议在新代码中使用，不需要线程安全的场合可以用HashMap替换，需要线程安全的场合可以用ConcurrentHashMap替换。</p>
<p>(3) <strong>LinkedHashMap</strong>：LinkedHashMap是HashMap的一个子类，保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序。</p>
<p>(4) <strong>TreeMap</strong>：TreeMap实现SortedMap接口，能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator遍历TreeMap时，得到的记录是排过序的。如果使用排序的映射，建议使用TreeMap。在使用TreeMap时，key必须实现Comparable接口或者在构造TreeMap传入自定义的Comparator，否则会在运行时抛出java.lang.ClassCastException类型的异常。</p>
<p>对于上述四种Map类型的类，要求映射中的key是不可变对象。不可变对象是该对象在创建后它的哈希值不会被改变。如果对象的哈希值发生变化，Map对象很可能就定位不到映射的位置了。</p>
<p>通过上面的比较，我们知道了HashMap是Java的Map家族中一个普通成员，鉴于它可以满足大多数场景的使用条件，所以是使用频度最高的一个。下文我们主要结合源码，从存储结构、常用方法分析、扩容以及安全性等方面深入讲解HashMap的工作原理。</p>
<h2 id="内部实现"><a href="#内部实现" class="headerlink" title="内部实现"></a><strong>内部实现</strong></h2><p>搞清楚HashMap，首先需要知道HashMap是什么，即它的存储结构-字段；其次弄明白它能干什么，即它的功能实现-方法。下面我们针对这两个方面详细展开讲解。</p>
<h3 id="存储结构-字段"><a href="#存储结构-字段" class="headerlink" title="存储结构-字段"></a>存储结构-字段</h3><p>从结构实现来讲，HashMap是数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的，如下如所示。</p>
<p><img src="http://img.blog.csdn.net/20170616165613975" alt=""></p>
<p>这里需要讲明白两个问题：数据底层具体存储的是什么？这样的存储方式有什么？优点呢？</p>
<p>(1) 从源码可知，HashMap类中有一个非常重要的字段，就是 <code>Node[] table</code>，即哈希桶数组，明显它是一个Node的数组。我们来看<code>Node</code>[JDK1.8]是何物。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;    <span class="comment">//用来定位数组索引位置</span></div><div class="line">        <span class="keyword">final</span> K key;</div><div class="line">        V value;</div><div class="line">        Node&lt;K,V&gt; next;   <span class="comment">//链表的下一个node</span></div><div class="line"></div><div class="line">        Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123; ... &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span></span>&#123; ... &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123; ... &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; ... &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123; ... &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123; ... &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123; ... &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Node是HashMap的一个内部类，实现了Map.Entry接口，本质是就是一个映射(键值对)。上图中的每个黑色圆点就是一个Node对象。</p>
<p>(2) HashMap就是使用哈希表来存储的。哈希表为解决冲突，可以采用开放地址法和链地址法等来解决问题，Java中HashMap采用了链地址法。链地址法，简单来说，就是数组加链表的结合。在每个数组元素上都一个链表结构，当数据被Hash后，得到数组下标，把数据放在对应下标元素的链表上。例如程序执行下面代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">map.put(<span class="string">"美团"</span>,<span class="string">"小美"</span>);</div></pre></td></tr></table></figure>
<p>系统将调用”美团”这个key的<code>hashCode()</code>方法得到其hashCode 值（该方法适用于每个Java对象），然后再通过Hash算法的后两步运算（高位运算和取模运算，下文有介绍）来定位该键值对的存储位置，有时两个key会定位到相同的位置，表示发生了Hash碰撞。当然Hash算法计算结果越分散均匀，Hash碰撞的概率就越小，map的存取效率就会越高。</p>
<p>如果哈希桶数组很大，即使较差的Hash算法也会比较分散，如果哈希桶数组数组很小，即使好的Hash算法也会出现较多碰撞，所以就需要在空间成本和时间成本之间权衡，其实就是在根据实际情况确定哈希桶数组的大小，并在此基础上设计好的hash算法减少Hash碰撞。那么通过什么方式来控制map使得Hash碰撞的概率又小，哈希桶数组（Node[] table）占用空间又少呢？答案就是好的Hash算法和扩容机制。</p>
<p>在理解Hash和扩容流程之前，我们得先了解下HashMap的几个字段。从HashMap的默认构造函数源码可知，构造函数就是对下面几个字段进行初始化，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> threshold;             <span class="comment">// 所能容纳的key-value对极限 </span></div><div class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;    <span class="comment">// 负载因子</span></div><div class="line"><span class="keyword">int</span> modCount;  </div><div class="line"><span class="keyword">int</span> size;</div></pre></td></tr></table></figure>
<p>首先，Node[] table的初始化长度length(默认值是16)，Load factor为负载因子(默认值是0.75)，threshold是HashMap所能容纳的最大数据量的Node(键值对)个数。threshold = length * Load factor。也就是说，在数组定义好长度之后，负载因子越大，所能容纳的键值对个数越多。</p>
<p>结合负载因子的定义公式可知，threshold就是在此Load factor和length(数组长度)对应下允许的最大元素数目，超过这个数目就重新resize(扩容)，扩容后的HashMap容量是之前容量的两倍。默认的负载因子0.75是对空间和时间效率的一个平衡选择，建议大家不要修改，除非在时间和空间比较特殊的情况下，如果内存空间很多而又对时间效率要求很高，可以降低负载因子Load factor的值；相反，如果内存空间紧张而对时间效率要求不高，可以增加负载因子loadFactor的值，这个值可以大于1。</p>
<p>size这个字段其实很好理解，就是HashMap中实际存在的键值对数量。注意和table的长度length、容纳最大键值对数量threshold的区别。而modCount字段主要用来记录HashMap内部结构发生变化的次数，主要用于迭代的快速失败。强调一点，内部结构发生变化指的是结构发生变化，例如put新键值对，但是某个key对应的value值被覆盖不属于结构变化。</p>
<p>在HashMap中，哈希桶数组table的长度length大小必须为2的n次方(一定是合数)，这是一种非常规的设计，常规的设计是把桶的大小设计为素数。相对来说素数导致冲突的概率要小于合数，具体证明可以参考<a href="http://blog.csdn.net/liuqiyao_01/article/details/14475159" target="_blank" rel="external">http://blog.csdn.net/liuqiyao_01/article/details/14475159</a> ，Hashtable初始化桶大小为11，就是桶大小设计为素数的应用（Hashtable扩容后不能保证还是素数）。HashMap采用这种非常规设计，主要是为了在取模和扩容时做优化，同时为了减少冲突，HashMap定位哈希桶索引位置时，也加入了高位参与运算的过程。</p>
<p>这里存在一个问题，即使负载因子和Hash算法设计的再合理，也免不了会出现拉链过长的情况，一旦出现拉链过长，则会严重影响HashMap的性能。于是，在JDK1.8版本中，对数据结构做了进一步的优化，引入了红黑树。而当链表长度太长（默认超过8）时，链表就转换为红黑树，利用红黑树快速增删改查的特点提高HashMap的性能，其中会用到红黑树的插入、删除、查找等算法。本文不再对红黑树展开讨论，想了解更多红黑树数据结构的工作原理可以参考<a href="http://blog.csdn.net/v_july_v/article/details/6105630" target="_blank" rel="external">http://blog.csdn.net/v_july_v/article/details/6105630</a> 。</p>
<h3 id="功能实现-方法"><a href="#功能实现-方法" class="headerlink" title="功能实现-方法"></a><strong>功能实现-方法</strong></h3><p>HashMap的内部功能实现很多，本文主要从根据key获取哈希桶数组索引位置、put方法的详细执行、扩容过程三个具有代表性的点深入展开讲解。</p>
<h4 id="1-确定哈希桶数组索引位置"><a href="#1-确定哈希桶数组索引位置" class="headerlink" title="1. 确定哈希桶数组索引位置"></a><strong>1. 确定哈希桶数组索引位置</strong></h4><p>不管增加、删除、查找键值对，定位到哈希桶数组的位置都是很关键的第一步。前面说过HashMap的数据结构是数组和链表的结合，所以我们当然希望这个HashMap里面的元素位置尽量分布均匀些，尽量使得每个位置上的元素数量只有一个，那么当我们用hash算法求得这个位置的时候，马上就可以知道对应位置的元素就是我们要的，不用遍历链表，大大优化了查询的效率。HashMap定位数组索引位置，直接决定了hash方法的离散性能。先看看源码的实现(方法一+方法二):</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">方法一：</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;   <span class="comment">//jdk1.8 &amp; jdk1.7</span></div><div class="line">     <span class="keyword">int</span> h;</div><div class="line">     <span class="comment">// h = key.hashCode() 为第一步 取hashCode值</span></div><div class="line">     <span class="comment">// h ^ (h &gt;&gt;&gt; 16)  为第二步 高位参与运算</span></div><div class="line">     <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</div><div class="line">&#125;</div><div class="line">方法二：</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;  <span class="comment">//jdk1.7的源码，jdk1.8没有这个方法，但是实现原理一样的</span></div><div class="line">     <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);  <span class="comment">//第三步 取模运算</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里的Hash算法本质上就是三步：<strong>取key的hashCode值</strong>、<strong>高位运算</strong>、<strong>取模运算</strong>。</p>
<p>对于任意给定的对象，只要它的hashCode()返回值相同，那么程序调用方法一所计算得到的Hash码值总是相同的。我们首先想到的就是把hash值对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的。但是，模运算的消耗还是比较大的，在HashMap中是这样做的：调用方法二来计算该对象应该保存在table数组的哪个索引处。</p>
<p>这个方法非常巧妙，它通过h &amp; (table.length -1)来得到该对象的保存位，而HashMap底层数组的长度总是2的n次方，这是HashMap在速度上的优化。当length总是2的n次方时，h&amp; (length-1)运算等价于对length取模，也就是h%length，但是&amp;比%具有更高的效率。</p>
<p>在JDK1.8的实现中，优化了高位运算的算法，通过hashCode()的高16位异或低16位实现的：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)，主要是从速度、功效、质量来考虑的，这么做可以在数组table的length比较小的时候，也能保证考虑到高低Bit都参与到Hash的计算中，同时不会有太大的开销。</p>
<p>下面举例说明下，n为table的长度。</p>
<p><img src="http://img.blog.csdn.net/20170616170559316" alt=""></p>
<h4 id="2-分析HashMap的put方法"><a href="#2-分析HashMap的put方法" class="headerlink" title="2. 分析HashMap的put方法"></a><strong>2. 分析HashMap的put方法</strong></h4><p>HashMap的put方法执行过程可以通过下图来理解，自己有兴趣可以去对比源码更清楚地研究学习。</p>
<p><img src="http://img.blog.csdn.net/20170616170655449" alt=""></p>
<p>①. 判断键值对数组table[i]是否为空或为null，否则执行resize()进行扩容；</p>
<p>②. 根据键值key计算hash值得到插入的数组索引i，如果table[i]==null，直接新建节点添加，转向⑥，如果table[i]不为空，转向③；</p>
<p>③. 判断table[i]的首个元素是否和key一样，如果相同直接覆盖value，否则转向④，这里的相同指的是hashCode以及equals；</p>
<p>④. 判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向⑤；</p>
<p>⑤. 遍历table[i]，判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可；</p>
<p>⑥. 插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，进行扩容。</p>
<p>JDK1.8HashMap的put方法源码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"> <span class="number">1</span> <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line"> <span class="number">2</span>     <span class="comment">// 对key的hashCode()做hash</span></div><div class="line"> <span class="number">3</span>     <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</div><div class="line"> <span class="number">4</span> &#125;</div><div class="line"> <span class="number">5</span> </div><div class="line"> <span class="number">6</span> <span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></div><div class="line"> <span class="number">7</span>                <span class="keyword">boolean</span> evict) &#123;</div><div class="line"> <span class="number">8</span>     Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</div><div class="line"> <span class="number">9</span>     <span class="comment">// 步骤①：tab为空则创建</span></div><div class="line"><span class="number">10</span>     <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</div><div class="line"><span class="number">11</span>         n = (tab = resize()).length;</div><div class="line"><span class="number">12</span>     <span class="comment">// 步骤②：计算index，并对null做处理 </span></div><div class="line"><span class="number">13</span>     <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>) </div><div class="line"><span class="number">14</span>         tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</div><div class="line"><span class="number">15</span>     <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">16</span>         Node&lt;K,V&gt; e; K k;</div><div class="line"><span class="number">17</span>         <span class="comment">// 步骤③：节点key存在，直接覆盖value</span></div><div class="line"><span class="number">18</span>         <span class="keyword">if</span> (p.hash == hash &amp;&amp;</div><div class="line"><span class="number">19</span>             ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line"><span class="number">20</span>             e = p;</div><div class="line"><span class="number">21</span>         <span class="comment">// 步骤④：判断该链为红黑树</span></div><div class="line"><span class="number">22</span>         <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</div><div class="line"><span class="number">23</span>             e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</div><div class="line"><span class="number">24</span>         <span class="comment">// 步骤⑤：该链为链表</span></div><div class="line"><span class="number">25</span>         <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">26</span>             <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</div><div class="line"><span class="number">27</span>                 <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">28</span>                     p.next = newNode(hash, key,value,<span class="keyword">null</span>);</div><div class="line">                        <span class="comment">//链表长度大于8转换为红黑树进行处理</span></div><div class="line"><span class="number">29</span>                     <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st  </span></div><div class="line"><span class="number">30</span>                         treeifyBin(tab, hash);</div><div class="line"><span class="number">31</span>                     <span class="keyword">break</span>;</div><div class="line"><span class="number">32</span>                 &#125;</div><div class="line">                    <span class="comment">// key已经存在直接覆盖value</span></div><div class="line"><span class="number">33</span>                 <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line"><span class="number">34</span>                     ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) </div><div class="line"><span class="number">35</span>                            <span class="keyword">break</span>;</div><div class="line"><span class="number">36</span>                 p = e;</div><div class="line"><span class="number">37</span>             &#125;</div><div class="line"><span class="number">38</span>         &#125;</div><div class="line"><span class="number">39</span>         </div><div class="line"><span class="number">40</span>         <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></div><div class="line"><span class="number">41</span>             V oldValue = e.value;</div><div class="line"><span class="number">42</span>             <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</div><div class="line"><span class="number">43</span>                 e.value = value;</div><div class="line"><span class="number">44</span>             afterNodeAccess(e);</div><div class="line"><span class="number">45</span>             <span class="keyword">return</span> oldValue;</div><div class="line"><span class="number">46</span>         &#125;</div><div class="line"><span class="number">47</span>     &#125;</div><div class="line"></div><div class="line"><span class="number">48</span>     ++modCount;</div><div class="line"><span class="number">49</span>     <span class="comment">// 步骤⑥：超过最大容量 就扩容</span></div><div class="line"><span class="number">50</span>     <span class="keyword">if</span> (++size &gt; threshold)</div><div class="line"><span class="number">51</span>         resize();</div><div class="line"><span class="number">52</span>     afterNodeInsertion(evict);</div><div class="line"><span class="number">53</span>     <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line"><span class="number">54</span> &#125;</div></pre></td></tr></table></figure>
<h4 id="3-扩容机制"><a href="#3-扩容机制" class="headerlink" title="3. 扩容机制"></a><strong>3. 扩容机制</strong></h4><p>扩容(resize)就是重新计算容量，向HashMap对象里不停的添加元素，而HashMap对象内部的数组无法装载更多的元素时，对象就需要扩大数组的长度，以便能装入更多的元素。当然Java里的数组是无法自动扩容的，方法是使用一个新的数组代替已有的容量小的数组，就像我们用一个小桶装水，如果想装更多的水，就得换大水桶。</p>
<p>我们分析下resize的源码，鉴于JDK1.8融入了红黑树，较复杂，为了便于理解我们仍然使用JDK1.7的代码，好理解一些，本质上区别不大，具体区别后文再说。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"> <span class="number">1</span> <span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;   <span class="comment">//传入新的容量</span></div><div class="line"> <span class="number">2</span>     Entry[] oldTable = table;    <span class="comment">//引用扩容前的Entry数组</span></div><div class="line"> <span class="number">3</span>     <span class="keyword">int</span> oldCapacity = oldTable.length;         </div><div class="line"> <span class="number">4</span>     <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;  <span class="comment">//扩容前的数组大小如果已经达到最大(2^30)了</span></div><div class="line"> <span class="number">5</span>         threshold = Integer.MAX_VALUE; <span class="comment">//修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了</span></div><div class="line"> <span class="number">6</span>         <span class="keyword">return</span>;</div><div class="line"> <span class="number">7</span>     &#125;</div><div class="line"> <span class="number">8</span>  </div><div class="line"> <span class="number">9</span>     Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];  <span class="comment">//初始化一个新的Entry数组</span></div><div class="line"><span class="number">10</span>     transfer(newTable);                         <span class="comment">//！！将数据转移到新的Entry数组里</span></div><div class="line"><span class="number">11</span>     table = newTable;                           <span class="comment">//HashMap的table属性引用新的Entry数组</span></div><div class="line"><span class="number">12</span>     threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);<span class="comment">//修改阈值</span></div><div class="line"><span class="number">13</span> &#125;</div></pre></td></tr></table></figure>
<p>这里就是使用一个容量更大的数组来代替已有的容量小的数组，transfer()方法将原有Entry数组的元素拷贝到新的Entry数组里。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"> <span class="number">1</span> <span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable)</span> </span>&#123;</div><div class="line"> <span class="number">2</span>     Entry[] src = table;                   <span class="comment">//src引用了旧的Entry数组</span></div><div class="line"> <span class="number">3</span>     <span class="keyword">int</span> newCapacity = newTable.length;</div><div class="line"> <span class="number">4</span>     <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; src.length; j++) &#123; <span class="comment">//遍历旧的Entry数组</span></div><div class="line"> <span class="number">5</span>         Entry&lt;K,V&gt; e = src[j];             <span class="comment">//取得旧Entry数组的每个元素</span></div><div class="line"> <span class="number">6</span>         <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</div><div class="line"> <span class="number">7</span>             src[j] = <span class="keyword">null</span>;<span class="comment">//释放旧Entry数组的对象引用（for循环后，旧的Entry数组不再引用任何对象）</span></div><div class="line"> <span class="number">8</span>             do &#123;</div><div class="line"> <span class="number">9</span>                 Entry&lt;K,V&gt; next = e.next;</div><div class="line"><span class="number">10</span>                 <span class="keyword">int</span> i = indexFor(e.hash, newCapacity); <span class="comment">//！！重新计算每个元素在数组中的位置</span></div><div class="line"><span class="number">11</span>                 e.next = newTable[i]; <span class="comment">//标记[1]</span></div><div class="line"><span class="number">12</span>                 newTable[i] = e;      <span class="comment">//将元素放在数组上</span></div><div class="line"><span class="number">13</span>                 e = next;             <span class="comment">//访问下一个Entry链上的元素</span></div><div class="line"><span class="number">14</span>             &#125; <span class="keyword">while</span> (e != <span class="keyword">null</span>);</div><div class="line"><span class="number">15</span>         &#125;</div><div class="line"><span class="number">16</span>     &#125;</div><div class="line"><span class="number">17</span> &#125;</div></pre></td></tr></table></figure>
<p>newTable[i]的引用赋给了e.next，也就是使用了单链表的头插入方式，同一位置上新元素总会被放在链表的头部位置；这样先放在一个索引上的元素终会被放到Entry链的尾部(如果发生了hash冲突的话），这一点和Jdk1.8有区别，下文详解。在旧数组中同一条Entry链上的元素，通过重新计算索引位置后，有可能被放到了新数组的不同位置上。</p>
<p>下面举个例子说明下扩容过程。假设了我们的hash算法就是简单的用key mod 一下表的大小（也就是数组的长度）。其中的哈希桶数组table的size=2， 所以key = 3、7、5，put顺序依次为 5、7、3。在mod 2以后都冲突在table[1]这里了。这里假设负载因子 loadFactor=1，即当键值对的实际大小size 大于 table的实际大小时进行扩容。接下来的三个步骤是哈希桶数组 resize成4，然后所有的Node重新rehash的过程。</p>
<p><img src="http://img.blog.csdn.net/20170616171207339" alt=""></p>
<p>下面我们讲解下JDK1.8做了哪些优化。经过观测可以发现，我们使用的是2次幂的扩展(指长度扩为原来2倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。看下图可以明白这句话的意思，n为table的长度，图（a）表示扩容前的key1和key2两种key确定索引位置的示例，图（b）表示扩容后key1和key2两种key确定索引位置的示例，其中hash1是key1对应的哈希与高位运算结果。</p>
<p><img src="http://img.blog.csdn.net/20170616171255934" alt=""></p>
<p>元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化：</p>
<p><img src="http://img.blog.csdn.net/20170616171330516" alt=""></p>
<p>因此，我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”，可以看看下图为16扩充为32的resize示意图：</p>
<p><img src="http://img.blog.csdn.net/20170616171352780" alt=""></p>
<p>这个设计确实非常的巧妙，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。这一块就是JDK1.8新增的优化点。有一点注意区别，JDK1.7中rehash的时候，旧链表迁移新链表的时候，如果在新表的数组索引位置相同，则链表元素会倒置，但是从上图可以看出，JDK1.8不会倒置。有兴趣的同学可以研究下JDK1.8的resize源码，写的很赞，如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div></pre></td><td class="code"><pre><div class="line"> <span class="number">1</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</div><div class="line"> <span class="number">2</span>     Node&lt;K,V&gt;[] oldTab = table;</div><div class="line"> <span class="number">3</span>     <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</div><div class="line"> <span class="number">4</span>     <span class="keyword">int</span> oldThr = threshold;</div><div class="line"> <span class="number">5</span>     <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</div><div class="line"> <span class="number">6</span>     <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</div><div class="line"> <span class="number">7</span>         <span class="comment">// 超过最大值就不再扩充了，就只好随你碰撞去吧</span></div><div class="line"> <span class="number">8</span>         <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</div><div class="line"> <span class="number">9</span>             threshold = Integer.MAX_VALUE;</div><div class="line"><span class="number">10</span>             <span class="keyword">return</span> oldTab;</div><div class="line"><span class="number">11</span>         &#125;</div><div class="line"><span class="number">12</span>         <span class="comment">// 没超过最大值，就扩充为原来的2倍</span></div><div class="line"><span class="number">13</span>         <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</div><div class="line"><span class="number">14</span>                  oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</div><div class="line"><span class="number">15</span>             newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></div><div class="line"><span class="number">16</span>     &#125;</div><div class="line"><span class="number">17</span>     <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></div><div class="line"><span class="number">18</span>         newCap = oldThr;</div><div class="line"><span class="number">19</span>     <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></div><div class="line"><span class="number">20</span>         newCap = DEFAULT_INITIAL_CAPACITY;</div><div class="line"><span class="number">21</span>         newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</div><div class="line"><span class="number">22</span>     &#125;</div><div class="line"><span class="number">23</span>     <span class="comment">// 计算新的resize上限</span></div><div class="line"><span class="number">24</span>     <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</div><div class="line"><span class="number">25</span> </div><div class="line"><span class="number">26</span>         <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</div><div class="line"><span class="number">27</span>         newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</div><div class="line"><span class="number">28</span>                   (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</div><div class="line"><span class="number">29</span>     &#125;</div><div class="line"><span class="number">30</span>     threshold = newThr;</div><div class="line"><span class="number">31</span>     <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>，<span class="string">"unchecked"</span>&#125;)</div><div class="line"><span class="number">32</span>         Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</div><div class="line"><span class="number">33</span>     table = newTab;</div><div class="line"><span class="number">34</span>     <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">35</span>         <span class="comment">// 把每个bucket都移动到新的buckets中</span></div><div class="line"><span class="number">36</span>         <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</div><div class="line"><span class="number">37</span>             Node&lt;K,V&gt; e;</div><div class="line"><span class="number">38</span>             <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">39</span>                 oldTab[j] = <span class="keyword">null</span>;</div><div class="line"><span class="number">40</span>                 <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</div><div class="line"><span class="number">41</span>                     newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</div><div class="line"><span class="number">42</span>                 <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</div><div class="line"><span class="number">43</span>                     ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</div><div class="line"><span class="number">44</span>                 <span class="keyword">else</span> &#123; <span class="comment">// 链表优化重hash的代码块</span></div><div class="line"><span class="number">45</span>                     Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</div><div class="line"><span class="number">46</span>                     Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</div><div class="line"><span class="number">47</span>                     Node&lt;K,V&gt; next;</div><div class="line"><span class="number">48</span>                     do &#123;</div><div class="line"><span class="number">49</span>                         next = e.next;</div><div class="line"><span class="number">50</span>                         <span class="comment">// 原索引</span></div><div class="line"><span class="number">51</span>                         <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</div><div class="line"><span class="number">52</span>                             <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</div><div class="line"><span class="number">53</span>                                 loHead = e;</div><div class="line"><span class="number">54</span>                             <span class="keyword">else</span></div><div class="line"><span class="number">55</span>                                 loTail.next = e;</div><div class="line"><span class="number">56</span>                             loTail = e;</div><div class="line"><span class="number">57</span>                         &#125;</div><div class="line"><span class="number">58</span>                         <span class="comment">// 原索引+oldCap</span></div><div class="line"><span class="number">59</span>                         <span class="keyword">else</span> &#123;</div><div class="line"><span class="number">60</span>                             <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</div><div class="line"><span class="number">61</span>                                 hiHead = e;</div><div class="line"><span class="number">62</span>                             <span class="keyword">else</span></div><div class="line"><span class="number">63</span>                                 hiTail.next = e;</div><div class="line"><span class="number">64</span>                             hiTail = e;</div><div class="line"><span class="number">65</span>                         &#125;</div><div class="line"><span class="number">66</span>                     &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</div><div class="line"><span class="number">67</span>                     <span class="comment">// 原索引放到bucket里</span></div><div class="line"><span class="number">68</span>                     <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">69</span>                         loTail.next = <span class="keyword">null</span>;</div><div class="line"><span class="number">70</span>                         newTab[j] = loHead;</div><div class="line"><span class="number">71</span>                     &#125;</div><div class="line"><span class="number">72</span>                     <span class="comment">// 原索引+oldCap放到bucket里</span></div><div class="line"><span class="number">73</span>                     <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</div><div class="line"><span class="number">74</span>                         hiTail.next = <span class="keyword">null</span>;</div><div class="line"><span class="number">75</span>                         newTab[j + oldCap] = hiHead;</div><div class="line"><span class="number">76</span>                     &#125;</div><div class="line"><span class="number">77</span>                 &#125;</div><div class="line"><span class="number">78</span>             &#125;</div><div class="line"><span class="number">79</span>         &#125;</div><div class="line"><span class="number">80</span>     &#125;</div><div class="line"><span class="number">81</span>     <span class="keyword">return</span> newTab;</div><div class="line"><span class="number">82</span> &#125;</div></pre></td></tr></table></figure>
<h2 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a><strong>线程安全性</strong></h2><p>在多线程使用场景中，应该尽量避免使用线程不安全的HashMap，而使用线程安全的ConcurrentHashMap。那么为什么说HashMap是线程不安全的，下面举例子说明在并发的多线程使用场景中使用HashMap可能造成死循环。代码例子如下(便于理解，仍然使用JDK1.7的环境)：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public class HashMapInfiniteLoop &#123;  </div><div class="line">    private static HashMap&lt;Integer,String&gt; map = new HashMap&lt;Integer,String&gt;(2, 0.75f);  </div><div class="line">    </div><div class="line">    public static void main(String[] args) &#123;  </div><div class="line">        map.put(5, "C");  </div><div class="line"></div><div class="line">        new Thread("Thread1") &#123;  </div><div class="line">            public void run() &#123;  </div><div class="line">                map.put(7, "B");  </div><div class="line">                System.out.println(map);  </div><div class="line">            &#125;;  </div><div class="line">        &#125;.start();  </div><div class="line">        new Thread("Thread2") &#123;  </div><div class="line">            public void run() &#123;  </div><div class="line">                map.put(3, "A);  </div><div class="line">                System.out.println(map);  </div><div class="line">            &#125;;  </div><div class="line">        &#125;.start();        </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中，map初始化为一个长度为2的数组，loadFactor=0.75，threshold=2*0.75=1，也就是说当put第二个key的时候，map就需要进行resize。</p>
<p>通过设置断点让线程1和线程2同时debug到transfer方法(3.3小节代码块)的首行。注意此时两个线程已经成功添加数据。放开thread1的断点至transfer方法的“Entry next = e.next;” 这一行；然后放开线程2的的断点，让线程2进行resize。结果如下图。</p>
<p><img src="http://img.blog.csdn.net/20170616171711863" alt=""></p>
<p>注意，Thread1的 e 指向了key(3)，而next指向了key(7)，其在线程二rehash后，指向了线程二重组后的链表。</p>
<p>线程一被调度回来执行，先是执行 newTalbe[i] = e， 然后是e = next，导致了e指向了key(7)，而下一次循环的next = e.next导致了next指向了key(3)。</p>
<p><img src="http://img.blog.csdn.net/20170616171741879" alt=""></p>
<p><img src="http://img.blog.csdn.net/20170616171859708" alt=""></p>
<p>e.next = newTable[i] 导致 key(3).next 指向了 key(7)。注意：此时的key(7).next 已经指向了key(3)， 环形链表就这样出现了。</p>
<p><img src="http://img.blog.csdn.net/20170616171810754" alt=""></p>
<p>于是，当我们用线程一调用map.get(11)时，悲剧就出现了——Infinite Loop。</p>
<h2 id="JDK1-8与JDK1-7的性能对比"><a href="#JDK1-8与JDK1-7的性能对比" class="headerlink" title="JDK1.8与JDK1.7的性能对比"></a><strong>JDK1.8与JDK1.7的性能对比</strong></h2><p>HashMap中，如果key经过hash算法得出的数组索引位置全部不相同，即Hash算法非常好，那样的话，getKey方法的时间复杂度就是O(1)，如果Hash算法技术的结果碰撞非常多，假如Hash算极其差，所有的Hash算法结果得出的索引位置一样，那样所有的键值对都集中到一个桶中，或者在一个链表中，或者在一个红黑树中，时间复杂度分别为O(n)和O(lgn)。 鉴于JDK1.8做了多方面的优化，总体性能优于JDK1.7，下面我们从两个方面用例子证明这一点。</p>
<h3 id="Hash较均匀的情况"><a href="#Hash较均匀的情况" class="headerlink" title="Hash较均匀的情况"></a><strong>Hash较均匀的情况</strong></h3><p>为了便于测试，我们先写一个类Key，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Key</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Key</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> value;</div><div class="line"></div><div class="line">    Key(<span class="keyword">int</span> value) &#123;</div><div class="line">        <span class="keyword">this</span>.value = value;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Key o)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> Integer.compare(<span class="keyword">this</span>.value, o.value);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass())</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        Key key = (Key) o;</div><div class="line">        <span class="keyword">return</span> value == key.value;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> value;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个类复写了equals方法，并且提供了相当好的hashCode函数，任何一个值的hashCode都不会相同，因为直接使用value当做hashcode。为了避免频繁的GC，我将不变的Key实例缓存了起来，而不是一遍一遍的创建它们。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Keys</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_KEY = <span class="number">10_000_000</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Key[] KEYS_CACHE = <span class="keyword">new</span> Key[MAX_KEY];</div><div class="line"></div><div class="line">    <span class="keyword">static</span> &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_KEY; ++i) &#123;</div><div class="line">            KEYS_CACHE[i] = <span class="keyword">new</span> Key(i);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Key <span class="title">of</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> KEYS_CACHE[value];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在开始我们的试验，测试需要做的仅仅是，创建不同size的HashMap（1、10、100、……10000000），屏蔽了扩容的情况，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> mapSize)</span> </span>&#123;</div><div class="line"></div><div class="line">     HashMap&lt;Key, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Key,Integer&gt;(mapSize);</div><div class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mapSize; ++i) &#123;</div><div class="line">         map.put(Keys.of(i), i);</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     <span class="keyword">long</span> beginTime = System.nanoTime(); <span class="comment">//获取纳秒</span></div><div class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mapSize; i++) &#123;</div><div class="line">         map.get(Keys.of(i));</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">long</span> endTime = System.nanoTime();</div><div class="line">     System.out.println(endTime - beginTime);</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">10</span>;i&lt;= <span class="number">1000</span> <span class="number">0000</span>;i*= <span class="number">10</span>)&#123;</div><div class="line">         test(i);</div><div class="line">     &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>在测试中会查找不同的值，然后度量花费的时间，为了计算getKey的平均时间，我们遍历所有的get方法，计算总的时间，除以key的数量，计算一个平均值，主要用来比较，绝对值可能会受很多环境因素的影响。结果如下：</p>
<p><img src="http://img.blog.csdn.net/20170616172058883" alt=""></p>
<p>通过观测测试结果可知，JDK1.8的性能要高于JDK1.7 15%以上，在某些size的区域上，甚至高于100%。由于Hash算法较均匀，JDK1.8引入的红黑树效果不明显，下面我们看看Hash不均匀的的情况。</p>
<h3 id="Hash极不均匀的情况"><a href="#Hash极不均匀的情况" class="headerlink" title="Hash极不均匀的情况"></a><strong>Hash极不均匀的情况</strong></h3><p>假设我们又一个非常差的Key，它们所有的实例都返回相同的hashCode值。这是使用HashMap最坏的情况。代码修改如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Key</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Key</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">//...</span></div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>仍然执行main方法，得出的结果如下表所示：</p>
<p><img src="http://img.blog.csdn.net/20170616172148396" alt=""></p>
<p>从表中结果中可知，随着size的变大，JDK1.7的花费时间是增长的趋势，而JDK1.8是明显的降低趋势，并且呈现对数增长稳定。当一个链表太长的时候，HashMap会动态的将它替换成一个红黑树，这话的话会将时间复杂度从O(n)降为O(logn)。hash算法均匀和不均匀所花费的时间明显也不相同，这两种情况的相对比较，可以说明一个好的hash算法的重要性。</p>
<pre><code>测试环境：处理器为2.2 GHz Intel Core i7，内存为16 GB 1600 MHz DDR3，SSD硬盘，使用默认的JVM参数，运行在64位的OS X 10.10.1上。
</code></pre><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a><strong>小结</strong></h2><p>(1) 扩容是一个特别耗性能的操作，所以当程序员在使用HashMap的时候，估算map的大小，初始化的时候给一个大致的数值，避免map进行频繁的扩容。</p>
<p>(2) 负载因子是可以修改的，也可以大于1，但是建议不要轻易修改，除非情况非常特殊。</p>
<p>(3) HashMap是线程不安全的，不要在并发的环境中同时操作HashMap，建议使用ConcurrentHashMap。</p>
<p>(4) JDK1.8引入红黑树大程度优化了HashMap的性能。</p>
<p>(5) 还没升级JDK1.8的，现在开始升级吧。HashMap的性能提升仅仅是JDK1.8的冰山一角。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a><strong>参考</strong></h2><ol>
<li>JDK1.7&amp;JDK1.8 源码。</li>
<li>酷壳COOLSHELL，<a href="http://coolshell.cn/articles/9606.html" target="_blank" rel="external">疫苗：JAVA HASHMAP的死循环</a>，2013</li>
<li>CSDN博客频道，<a href="http://blog.csdn.net/xuefeng0707/article/details/40797085" target="_blank" rel="external">HashMap多线程死循环问题</a>，2014。</li>
<li>红黑联盟，<a href="http://www.2cto.com/kf/201505/401433.html" target="_blank" rel="external">Java类集框架之HashMap(JDK1.8)源码剖析</a>，2015。</li>
<li>CSDN博客频道， <a href="http://blog.csdn.net/v_july_v/article/details/6105630" target="_blank" rel="external">教你初步了解红黑树</a>，2010。</li>
<li>Java Code Geeks，<a href="https://www.javacodegeeks.com/2014/04/hashmap-performance-improvements-in-java-8.html" target="_blank" rel="external">HashMap performance improvements in Java 8</a>，2014。</li>
<li>Importnew，<a href="http://www.importnew.com/13384.html" target="_blank" rel="external">危险！在HashMap中将可变对象用作Key</a>，2014。</li>
<li>CSDN博客频道，<a href="http://blog.csdn.net/liuqiyao_01/article/details/14475159" target="_blank" rel="external">为什么一般hashtable的桶数会取一个素数</a>，2013。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文来自美团点评技术团队： &lt;a href=&quot;http://tech.meituan.com/java-hashmap.html&quot;&gt;Java 8系列之重新认识HashMap&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;&lt;strong&gt;摘要&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;HashMap是Java程序员使用频率最高的用于映射(键值对)处理的数据类型。随着JDK（Java Developmet Kit）版本的更新，JDK1.8对HashMap底层的实现进行了优化，例如引入红黑树的数据结构和扩容的优化等。本文结合JDK1.7和JDK1.8的区别，深入探讨HashMap的结构实现和功能原理。&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;&lt;strong&gt;简介&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;Java为数据结构中的映射定义了一个接口java.util.Map，此接口主要有四个常用的实现类，分别是&lt;code&gt;HashMap&lt;/code&gt;、&lt;code&gt;Hashtable&lt;/code&gt;、&lt;code&gt;LinkedHashMap&lt;/code&gt;和&lt;code&gt;TreeMap&lt;/code&gt;，类继承关系如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20170616165413193&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://github.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://github.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>【面试题】Java String常量相等（==）问题</title>
    <link href="http://github.com/2017/06/15/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%98%E3%80%91Java%20String%E5%B8%B8%E9%87%8F%E7%9B%B8%E7%AD%89%EF%BC%88==%EF%BC%89%E9%97%AE%E9%A2%98/"/>
    <id>http://github.com/2017/06/15/【面试题】Java String常量相等（==）问题/</id>
    <published>2017-06-15T08:51:55.000Z</published>
    <updated>2017-06-15T09:03:38.720Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>以下三个结果分别输出（true or false）？别小看它，很多程序员因为上面问题出过生产bug</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">String s3 = <span class="string">"s"</span>;</div><div class="line">String s4 = <span class="string">"s"</span>;</div><div class="line">System.out.println(s3==s4);</div><div class="line"></div><div class="line"></div><div class="line">---</div><div class="line">String s5 = <span class="string">"hello"</span>;</div><div class="line">String s6 = <span class="string">"he"</span>+<span class="string">"llo"</span>;</div><div class="line">System.out.println(s5==s6);</div><div class="line"></div><div class="line"></div><div class="line">---</div><div class="line">Integer i = <span class="number">2017</span>;</div><div class="line">Integer j = <span class="number">2017</span>;</div><div class="line">System.out.println(i==j);</div><div class="line"></div><div class="line"></div><div class="line">---</div><div class="line">String s1 = <span class="keyword">new</span> String(<span class="string">"s"</span>);</div><div class="line">String s2 = <span class="keyword">new</span> String(<span class="string">"s"</span>);</div><div class="line">System.out.println(s1==s2);</div><div class="line">System.out.println(s1.intern()==s2.intern());</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>真正执行结果如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">String s3 = <span class="string">"s"</span>;</div><div class="line">String s4 = <span class="string">"s"</span>;</div><div class="line">System.out.println(s3==s4);   <span class="comment">//true</span></div><div class="line"></div><div class="line"></div><div class="line">---</div><div class="line">String s5 = <span class="string">"hello"</span>;</div><div class="line">String s6 = <span class="string">"he"</span>+<span class="string">"llo"</span>;</div><div class="line">System.out.println(s5==s6);   <span class="comment">//true</span></div><div class="line"></div><div class="line"></div><div class="line">---</div><div class="line">Integer i = <span class="number">2017</span>;</div><div class="line">Integer j = <span class="number">2017</span>;</div><div class="line">System.out.println(i==j);   <span class="comment">//false</span></div><div class="line"></div><div class="line"></div><div class="line">---</div><div class="line">String s1 = <span class="keyword">new</span> String(<span class="string">"s"</span>);</div><div class="line">String s2 = <span class="keyword">new</span> String(<span class="string">"s"</span>);</div><div class="line">System.out.println(s1==s2);   <span class="comment">//false</span></div><div class="line">System.out.println(s1.intern()==s2.intern());   <span class="comment">//true</span></div></pre></td></tr></table></figure>
<h1 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h1><ol>
<li><p>看看Integer的源代码就知道Integer 把-128-127之间的每个值建立了缓存池，所以Integer i =127，Integer j =127，他们是true，超出就是false。</p>
</li>
<li><p>String s = “s” 是常量池中创建一个对象”s”，所以是true。而String s = new String（”s”）在堆上面分配内存创建一个String对象，栈放了对象引用。如下图：</p>
</li>
</ol>
<p><img src="http://img.blog.csdn.net/20170615170007540" alt=""></p>
<p>但在调用s.intern()方法的时候，会将共享池中的字符串与外部的字符串(s）进行比较,如果共享池存在，返回它，如果不同则将外部字符串放入共享池中，并返回其字符串的引用，这样做的好处就是能够节约空间。</p>
<p>String 的<code>intern()</code>方法的官方解释如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">  * Returns an interned string equal to this string. The VM maintains an internal set of</div><div class="line">  * unique strings. All string literals found in loaded classes'</div><div class="line">  * constant pools are automatically interned. Manually-interned strings are only weakly</div><div class="line">  * referenced, so calling &#123;<span class="doctag">@code</span> intern&#125; won't lead to unwanted retention.</div><div class="line">  *</div><div class="line">  * &lt;p&gt;Interning is typically used because it guarantees that for interned strings</div><div class="line">  * &#123;<span class="doctag">@code</span> a&#125; and &#123;<span class="doctag">@code</span> b&#125;, &#123;<span class="doctag">@code</span> a.equals(b)&#125; can be simplified to</div><div class="line">  * &#123;<span class="doctag">@code</span> a == b&#125;. (This is not true of non-interned strings.)</div><div class="line">  *</div><div class="line">  * &lt;p&gt;Many applications find it simpler and more convenient to use an explicit</div><div class="line">  * &#123;<span class="doctag">@link</span> java.util.HashMap&#125; to implement their own pools.</div><div class="line">  */</div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> String <span class="title">intern</span><span class="params">()</span></span>;</div></pre></td></tr></table></figure>
<p>s.intern()作用还是很多，比如for循环创建String对象，因为代码事先不并不知道是否存在”hello”或者其他字符串的实例。这样可以节约很多内存空间。</p>
<p>参考资料：</p>
<p>1、<a href="https://www.zhihu.com/question/60949531/answer/182458705" target="_blank" rel="external">你遇到过哪些质量很高的 Java 面试？</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h1&gt;&lt;p&gt;以下三个结果分别输出（true or false）？别小看它，很多程序员因为上面问题出过生产bug&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;String s3 = &lt;span class=&quot;string&quot;&gt;&quot;s&quot;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;String s4 = &lt;span class=&quot;string&quot;&gt;&quot;s&quot;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;System.out.println(s3==s4);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;---&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;String s5 = &lt;span class=&quot;string&quot;&gt;&quot;hello&quot;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;String s6 = &lt;span class=&quot;string&quot;&gt;&quot;he&quot;&lt;/span&gt;+&lt;span class=&quot;string&quot;&gt;&quot;llo&quot;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;System.out.println(s5==s6);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;---&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Integer i = &lt;span class=&quot;number&quot;&gt;2017&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Integer j = &lt;span class=&quot;number&quot;&gt;2017&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;System.out.println(i==j);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;---&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;String s1 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; String(&lt;span class=&quot;string&quot;&gt;&quot;s&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;String s2 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; String(&lt;span class=&quot;string&quot;&gt;&quot;s&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;System.out.println(s1==s2);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;System.out.println(s1.intern()==s2.intern());&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Java" scheme="http://github.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://github.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>详解Java类的生命周期</title>
    <link href="http://github.com/2017/06/02/%E8%AF%A6%E8%A7%A3Java%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>http://github.com/2017/06/02/详解Java类的生命周期/</id>
    <published>2017-06-02T03:36:55.000Z</published>
    <updated>2017-06-02T03:51:10.331Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a><strong>引言</strong></h2><p>最近有位细心的朋友在阅读笔者的文章时，对Java类的生命周期问题有一些疑惑，笔者打开百度搜了一下相关的问题，看到网上的资料很少有把这个问题讲明白的，主要是因为目前国内Java方面的教材大多只是告诉你“怎样做”，但至于“为什么这样做”却不多说，所以造成大家在基础和原理方面的知识比较匮乏，所以笔者今天就斗胆来讲一下这个问题，权当抛砖引玉，希望对在这个问题上有疑惑的朋友有所帮助，文中有说的不对的地方，也希望各路高手前来指正。</p>
<p>首先来了解一下jvm（java虚拟机）中的几个比较重要的内存区域，这几个区域在java类的生命周期中扮演着比较重要的角色：</p>
<ul>
<li><strong>方法区</strong>：在java的虚拟机中有一块专门用来存放已经加载的类信息、常量、静态变量以及方法代码的内存区域，叫做方法区。</li>
<li><strong>常量池</strong>：常量池是方法区的一部分，主要用来存放常量和类中的符号引用等信息。</li>
<li><strong>堆区</strong>：用于存放类的对象实例。</li>
<li><strong>栈区</strong>：也叫java虚拟机栈，是由一个一个的栈帧组成的后进先出的栈式结构，栈桢中存放方法运行时产生的局部变量、方法出口等信息。当调用一个方法时，虚拟机栈中就会创建一个栈帧存放这些数据，当方法调用完成时，栈帧消失，如果方法中调用了其他方法，则继续在栈顶创建新的栈桢。</li>
</ul>
<a id="more"></a>
<p>除了以上四个内存区域之外，jvm中的运行时内存区域还包括<strong>本地方法栈</strong>和<strong>程序计数器</strong>，这两个区域与java类的生命周期关系不是很大，在这里就不说了，感兴趣的朋友可以自己百度一下。</p>
<h2 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a><strong>类的生命周期</strong></h2><p>当我们编写一个java的源文件后，经过编译会生成一个后缀名为class的文件，这种文件叫做字节码文件，只有这种字节码文件才能够在java虚拟机中运行，java类的生命周期就是指一个class文件从加载到卸载的全过程。</p>
<p>一个java类的完整的生命周期会经历<strong>加载、连接、初始化、使用、</strong>和<strong>卸载</strong>五个阶段，当然也有在加载或者连接之后没有被初始化就直接被使用的情况，如图所示：</p>
<p><img src="http://img.blog.csdn.net/20170602113030666" alt=""></p>
<p>下面我们就依次来说一说这五个阶段。</p>
<h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a><strong>加载</strong></h3><p>在java中，我们经常会接触到一个词——<strong>类加载</strong>，它和这里的加载并不是一回事，通常我们说类加载指的是类的生命周期中加载、连接、初始化三个阶段。在加载阶段，java虚拟机会做什么工作呢？其实很简单，就是找到需要加载的类并把类的信息加载到jvm的方法区中，然后在堆区中实例化一个java.lang.Class对象，作为方法区中这个类的信息的入口。</p>
<p>类的加载方式比较灵活，我们最常用的加载方式有两种，一种是根据类的全路径名找到相应的class文件，然后从class文件中读取文件内容；另一种是从jar文件中读取。另外，还有下面几种方式也比较常用：</p>
<ul>
<li><p>从网络中获取：比如10年前十分流行的Applet。</p>
</li>
<li><p>根据一定的规则实时生成，比如设计模式中的动态代理模式，就是根据相应的类自动生成它的代理类。</p>
</li>
<li><p>从非class文件中获取，其实这与直接从class文件中获取的方式本质上是一样的，这些非class文件在jvm中运行之前会被转换为可被jvm所识别的字节码文件。</p>
</li>
</ul>
<p>对于加载的时机，各个虚拟机的做法并不一样，但是有一个原则，就是当jvm“预期”到一个类将要被使用时，就会在使用它之前对这个类进行加载。比如说，在一段代码中出现了一个类的名字，jvm在执行这段代码之前并不能确定这个类是否会被使用到，于是，有些jvm会在执行前就加载这个类，而有些则在真正需要用的时候才会去加载它，这取决于具体的jvm实现。我们常用的hotspot虚拟机是采用的后者，就是说当真正用到一个类的时候才对它进行加载。</p>
<p>加载阶段是类的生命周期中的第一个阶段，加载阶段之后，是连接阶段。有一点需要注意，就是有时连接阶段并不会等加载阶段完全完成之后才开始，而是交叉进行，可能一个类只加载了一部分之后，连接阶段就已经开始了。但是这两个阶段总的开始时间和完成时间总是固定的：加载阶段总是在连接阶段之前开始，连接阶段总是在加载阶段完成之后完成。</p>
<h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a><strong>连接</strong></h3><p>连接阶段比较复杂，一般会跟加载阶段和初始化阶段交叉进行，这个阶段的主要任务就是做一些加载后的验证工作以及一些初始化前的准备工作，可以细分为三个步骤：验证、准备和解析。</p>
<ol>
<li><p><strong>验证</strong>：当一个类被加载之后，必须要验证一下这个类是否合法，比如这个类是不是符合字节码的格式、变量与方法是不是有重复、数据类型是不是有效、继承与实现是否合乎标准等等。总之，这个阶段的目的就是保证加载的类是能够被jvm所运行。</p>
</li>
<li><p><strong>准备</strong>：准备阶段的工作就是为类的静态变量分配内存并设为jvm默认的初值，对于非静态的变量，则不会为它们分配内存。有一点需要注意，这时候，静态变量的初值为jvm默认的初值，而不是我们在程序中设定的初值。jvm默认的初值是这样的：</p>
<ul>
<li><strong>基本类型</strong>：（int、long、short、char、byte、boolean、float、double）的默认值为0。</li>
<li><strong>引用类型</strong>：默认值为null。</li>
<li><strong>常量</strong>：默认值为我们程序中设定的值，比如我们在程序中定义final static int a = 100，则准备阶段中a的初值就是100。</li>
</ul>
</li>
<li><p><strong>解析</strong>：这一阶段的任务就是把常量池中的符号引用转换为直接引用。那么什么是符号引用，什么又是直接引用呢？我们来举个例子：我们要找一个人，我们现有的信息是这个人的身份证号是1234567890。只有这个信息我们显然找不到这个人，但是通过公安局的身份系统，我们输入1234567890这个号之后，就会得到它的全部信息：比如安徽省黄山市余暇村18号张三，通过这个信息我们就能找到这个人了。这里，123456790就好比是一个符号引用，而安徽省黄山市余暇村18号张三就是直接引用。在内存中也是一样，比如我们要在内存中找一个类里面的一个叫做show的方法，显然是找不到。但是在解析阶段，jvm就会把show这个名字转换为指向方法区的的一块内存地址，比如c17164，通过c17164就可以找到show这个方法具体分配在内存的哪一个区域了。这里show就是符号引用，而c17164就是直接引用。在解析阶段，jvm会将所有的类或接口名、字段名、方法名转换为具体的内存地址。</p>
</li>
</ol>
<p>连接阶段完成之后会根据使用的情况（直接引用还是被动引用）来选择是否对类进行初始化。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a><strong>初始化</strong></h3><p>如果一个类被直接引用，就会触发类的初始化。在java中，直接引用的情况有：</p>
<ul>
<li>通过new关键字实例化对象、读取或设置类的静态变量、调用类的静态方法。</li>
<li>通过反射方式执行以上三种行为。</li>
<li>初始化子类的时候，会触发父类的初始化。</li>
<li>作为程序入口直接运行时（也就是直接调用main方法）。</li>
</ul>
<p>除了以上四种情况，其他使用类的方式叫做被动引用，而被动引用不会触发类的初始化。请看主动引用的示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.lang.reflect.Field;  </div><div class="line"><span class="keyword">import</span> java.lang.reflect.Method;  </div><div class="line">  </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">InitClass</span></span>&#123;  </div><div class="line">    <span class="keyword">static</span> &#123;  </div><div class="line">        System.out.println(<span class="string">"初始化InitClass"</span>);  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String a = <span class="keyword">null</span>;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;&#125;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubInitClass</span> <span class="keyword">extends</span> <span class="title">InitClass</span></span>&#123;&#125;  </div><div class="line">  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;  </div><div class="line">  </div><div class="line">    <span class="comment">/** </span></div><div class="line">     * 主动引用引起类的初始化的第四种情况就是运行Test1的main方法时 </div><div class="line">     * 导致Test1初始化，这一点很好理解，就不特别演示了。 </div><div class="line">     * 本代码演示了前三种情况，以下代码都会引起InitClass的初始化， </div><div class="line">     * 但由于初始化只会进行一次，运行时请将注解去掉，依次运行查看结果。 </div><div class="line">     * <span class="doctag">@param</span> args </div><div class="line">     * <span class="doctag">@throws</span> Exception </div><div class="line">     */  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;  </div><div class="line">    <span class="comment">//  主动引用引起类的初始化一: new对象、读取或设置类的静态变量、调用类的静态方法。  </span></div><div class="line">    <span class="comment">//  new InitClass();  </span></div><div class="line">    <span class="comment">//  InitClass.a = "";  </span></div><div class="line">    <span class="comment">//  String a = InitClass.a;  </span></div><div class="line">    <span class="comment">//  InitClass.method();  </span></div><div class="line">          </div><div class="line">    <span class="comment">//  主动引用引起类的初始化二：通过反射实例化对象、读取或设置类的静态变量、调用类的静态方法。  </span></div><div class="line">    <span class="comment">//  Class cls = InitClass.class;  </span></div><div class="line">    <span class="comment">//  cls.newInstance();  </span></div><div class="line">          </div><div class="line">    <span class="comment">//  Field f = cls.getDeclaredField("a");  </span></div><div class="line">    <span class="comment">//  f.get(null);  </span></div><div class="line">    <span class="comment">//  f.set(null, "s");  </span></div><div class="line">      </div><div class="line">    <span class="comment">//  Method md = cls.getDeclaredMethod("method");  </span></div><div class="line">    <span class="comment">//  md.invoke(null, null);  </span></div><div class="line">              </div><div class="line">    <span class="comment">//  主动引用引起类的初始化三：实例化子类，引起父类初始化。  </span></div><div class="line">    <span class="comment">//  new SubInitClass();  </span></div><div class="line">  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的程序演示了主动引用触发类的初始化的四种情况。</p>
<p>类的初始化过程是这样的：<strong>按照顺序自上而下运行类中的变量赋值语句和静态语句，如果有父类，则首先按照顺序运行父类中的变量赋值语句和静态语句。</strong>先看一个例子，首先建两个类用来显示赋值操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Field1</span></span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Field1</span><span class="params">()</span></span>&#123;  </div><div class="line">        System.out.println(<span class="string">"Field1构造方法"</span>);  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Field2</span></span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Field2</span><span class="params">()</span></span>&#123;  </div><div class="line">        System.out.println(<span class="string">"Field2构造方法"</span>);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面是演示初始化顺序的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">InitClass2</span></span>&#123;  </div><div class="line">    <span class="keyword">static</span>&#123;  </div><div class="line">        System.out.println(<span class="string">"运行父类静态代码"</span>);  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Field1 f1 = <span class="keyword">new</span> Field1();  </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Field1 f2;   </div><div class="line">&#125;  </div><div class="line">  </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubInitClass2</span> <span class="keyword">extends</span> <span class="title">InitClass2</span></span>&#123;  </div><div class="line">    <span class="keyword">static</span>&#123;  </div><div class="line">        System.out.println(<span class="string">"运行子类静态代码"</span>);  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Field2 f2 = <span class="keyword">new</span> Field2();  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException</span>&#123;  </div><div class="line">        <span class="keyword">new</span> SubInitClass2();  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的代码中，初始化的顺序是：第03行，第05行，第11行，第13行。第04行是声明操作，没有赋值，所以不会被运行。而下面的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">InitClass2</span></span>&#123;  </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Field1 f1 = <span class="keyword">new</span> Field1();  </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Field1 f2;  </div><div class="line">    <span class="keyword">static</span>&#123;  </div><div class="line">        System.out.println(<span class="string">"运行父类静态代码"</span>);  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubInitClass2</span> <span class="keyword">extends</span> <span class="title">InitClass2</span></span>&#123;  </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Field2 f2 = <span class="keyword">new</span> Field2();  </div><div class="line">    <span class="keyword">static</span>&#123;  </div><div class="line">        System.out.println(<span class="string">"运行子类静态代码"</span>);  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException</span>&#123;  </div><div class="line">        <span class="keyword">new</span> SubInitClass2();  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 初始化顺序为：第02行、第05行、第10行、第12行，各位可以运行程序查看结果。</p>
<p><strong>在类的初始化阶段，只会初始化与类相关的静态赋值语句和静态语句，也就是有static关键字修饰的信息，而没有static修饰的赋值语句和执行语句在实例化对象的时候才会运行。</strong></p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a><strong>使用</strong></h3><p>类的使用包括主动引用和被动引用，主动引用在初始化的章节中已经说过了，下面我们主要来说一下被动引用：</p>
<ul>
<li>引用父类的静态字段，只会引起父类的初始化，而不会引起子类的初始化。</li>
<li>定义类数组，不会引起类的初始化。</li>
<li>引用类的常量，不会引起类的初始化。</li>
</ul>
<p>被动引用的示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">InitClass</span></span>&#123;  </div><div class="line">    <span class="keyword">static</span> &#123;  </div><div class="line">        System.out.println(<span class="string">"初始化InitClass"</span>);  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String a = <span class="keyword">null</span>;  </div><div class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String b = <span class="string">"b"</span>;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;&#125;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubInitClass</span> <span class="keyword">extends</span> <span class="title">InitClass</span></span>&#123;  </div><div class="line">    <span class="keyword">static</span> &#123;  </div><div class="line">        System.out.println(<span class="string">"初始化SubInitClass"</span>);  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test4</span> </span>&#123;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;  </div><div class="line">    <span class="comment">//  String a = SubInitClass.a;// 引用父类的静态字段，只会引起父类初始化，而不会引起子类的初始化  </span></div><div class="line">    <span class="comment">//  String b = InitClass.b;// 使用类的常量不会引起类的初始化  </span></div><div class="line">        SubInitClass[] sc = <span class="keyword">new</span> SubInitClass[<span class="number">10</span>];<span class="comment">// 定义类数组不会引起类的初始化  </span></div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后总结一下使用阶段：<strong>使用阶段包括主动引用和被动引用，主动饮用会引起类的初始化，而被动引用不会引起类的初始化。</strong></p>
<p>当使用阶段完成之后，java类就进入了卸载阶段。</p>
<h3 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a><strong>卸载</strong></h3><p>关于类的卸载，笔者在<a href="http://blog.csdn.net/zhengzhb/article/details/7331354" target="_blank" rel="external"><strong>单例模式讨论篇：单例模式与垃圾回收</strong></a>一文中有过描述，在类使用完之后，如果满足下面的情况，类就会被卸载：</p>
<ul>
<li>该类所有的实例都已经被回收，也就是java堆中不存在该类的任何实例。</li>
<li>加载该类的ClassLoader已经被回收。</li>
<li>该类对应的java.lang.Class对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
</ul>
<p>如果以上三个条件全部满足，jvm就会在方法区垃圾回收的时候对类进行卸载，类的卸载过程其实就是在方法区中清空类信息，java类的整个生命周期就结束了。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>做java的朋友对于对象的生命周期可能都比较熟悉，对象基本上都是在jvm的堆区中创建，在创建对象之前，会触发类加载（加载、连接、初始化），当类初始化完成后，根据类信息在堆区中实例化类对象，初始化非静态变量、非静态代码以及默认构造方法，当对象使用完之后会在合适的时候被jvm垃圾收集器回收。读完本文后我们知道，对象的生命周期只是类的生命周期中使用阶段的主动引用的一种情况（即实例化类对象）。而类的整个生命周期则要比对象的生命周期长的多。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://segmentfault.com/a/1190000002579346" target="_blank" rel="external">JVM 的 工作原理，层次结构 以及 GC工作原理</a></p>
<blockquote>
<p>本文转载自 <a href="http://blog.csdn.net/zhengzhb/article/details/7517213" target="_blank" rel="external">详解java类的生命周期 - 卡奴达摩的专栏</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;&lt;strong&gt;引言&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;最近有位细心的朋友在阅读笔者的文章时，对Java类的生命周期问题有一些疑惑，笔者打开百度搜了一下相关的问题，看到网上的资料很少有把这个问题讲明白的，主要是因为目前国内Java方面的教材大多只是告诉你“怎样做”，但至于“为什么这样做”却不多说，所以造成大家在基础和原理方面的知识比较匮乏，所以笔者今天就斗胆来讲一下这个问题，权当抛砖引玉，希望对在这个问题上有疑惑的朋友有所帮助，文中有说的不对的地方，也希望各路高手前来指正。&lt;/p&gt;
&lt;p&gt;首先来了解一下jvm（java虚拟机）中的几个比较重要的内存区域，这几个区域在java类的生命周期中扮演着比较重要的角色：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;方法区&lt;/strong&gt;：在java的虚拟机中有一块专门用来存放已经加载的类信息、常量、静态变量以及方法代码的内存区域，叫做方法区。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;常量池&lt;/strong&gt;：常量池是方法区的一部分，主要用来存放常量和类中的符号引用等信息。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;堆区&lt;/strong&gt;：用于存放类的对象实例。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;栈区&lt;/strong&gt;：也叫java虚拟机栈，是由一个一个的栈帧组成的后进先出的栈式结构，栈桢中存放方法运行时产生的局部变量、方法出口等信息。当调用一个方法时，虚拟机栈中就会创建一个栈帧存放这些数据，当方法调用完成时，栈帧消失，如果方法中调用了其他方法，则继续在栈顶创建新的栈桢。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Java" scheme="http://github.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://github.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>【Android】Audio音频输出通道切换 - 蓝牙、外放</title>
    <link href="http://github.com/2017/05/18/%E3%80%90Android%E3%80%91Audio%E9%9F%B3%E9%A2%91%E8%BE%93%E5%87%BA%E9%80%9A%E9%81%93%E5%88%87%E6%8D%A2%20-%20%E8%93%9D%E7%89%99%E3%80%81%E5%A4%96%E6%94%BE/"/>
    <id>http://github.com/2017/05/18/【Android】Audio音频输出通道切换 - 蓝牙、外放/</id>
    <published>2017-05-18T03:40:00.000Z</published>
    <updated>2017-05-19T08:38:32.402Z</updated>
    
    <content type="html"><![CDATA[<p>手机音频的输出有外放（Speaker）、听筒（Telephone Receiver）、有线耳机（WiredHeadset）、蓝牙音箱（Bluetooth A2DP）等输出设备。在平时，电话免提、插拔耳机、连接断开蓝牙设备等操作系统都会自动切换Audio音频到相应的输出设备上。比如电话免提就是从听筒切换到外放扬声器，插入耳机就是从外放切换到耳机。</p>
<h2 id="场景需求"><a href="#场景需求" class="headerlink" title="场景需求"></a><strong>场景需求</strong></h2><p>Android系统自动切换的这些策略，并不能全部满足我们的产品需求，比如音乐App需要对听歌时拔出耳机的操作进行阻止（暂停播放），防止突然切换到外放导致尴尬。</p>
<p>最近项目需求希望<strong><code>即使在连接蓝牙音箱的情况下，仍旧使用手机外放播放音频</code></strong>。这就需要强制切换Audio输出通道，打破系统原有的策略。</p>
<p>查阅资料，看到了Android中可以通过<code>AudioManager</code>查询、切换当前Audio输出通道，并且在Audio输出发生变化时，捕获并处理这种变化。</p>
<a id="more"></a>
<p>首先提醒下大家，使用下面的方法时，需要添加权限：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.MODIFY_AUDIO_SETTINGS"</span> /&gt;</span></div></pre></td></tr></table></figure>
<h2 id="Audio输出状态查询"><a href="#Audio输出状态查询" class="headerlink" title="Audio输出状态查询"></a><strong>Audio输出状态查询</strong></h2><p>AudioManager 提供的下列方法可以用来查询当前Audio输出的状态：</p>
<ul>
<li><p><strong><code>isBluetoothA2dpOn()</code></strong>：检查A2DPAudio音频输出是否通过蓝牙耳机；</p>
</li>
<li><p><strong><code>isSpeakerphoneOn()</code></strong>：检查扬声器是否打开；</p>
</li>
<li><p><strong><code>isWiredHeadsetOn()</code></strong>：检查线控耳机是否连着；注意这个方法只是用来判断耳机是否是插入状态，并不能用它的结果来判定当前的Audio是通过耳机输出的，这还依赖于其他条件。</p>
</li>
<li><p><strong><code>setSpeakerphoneOn(boolean on)</code></strong>：直接选择外放扬声器发声；</p>
</li>
<li><p><strong><code>setBluetoothScoOn(boolean on)</code></strong>：要求使用蓝牙SCO耳机进行通讯；</p>
</li>
</ul>
<p>此处<a href="http://blog.csdn.net/ec_boy_hl/article/details/45112493" target="_blank" rel="external">根据这篇文章</a>简单地介绍一下蓝牙耳机的两种链路，A2DP及SCO。android的api表明：</p>
<ul>
<li><strong>A2DP</strong>：是一种单向的高品质音频数据传输链路，<strong>通常用于播放立体声音乐</strong>；</li>
<li><strong>SCO</strong>： 则是一种双向的音频数据的传输链路，该链路只支持8K及16K单声道的音频数据，<strong>只能用于普通语音的传输</strong>，若用于播放音乐那就只能呵呵了。</li>
</ul>
<p>两者的主要区别是：<strong>A2DP只能播放，默认是打开的，而SCO既能录音也能播放，默认是关闭的。</strong> 如果要录音肯定要打开sco啦，因此调用上面的<code>setBluetoothScoOn(boolean on)</code>就可以通过蓝牙耳机录音、播放音频了，录完、播放完记得要关闭。</p>
<p>另外，在Android系统中通过<code>AudioManager.setMode()</code>方法来管理播放模式。在<code>setMode()</code>方法中有以下几种对应不同的播放模式:</p>
<ul>
<li><code>MODE_NORMAL</code> : 普通模式，既不是铃声模式也不是通话模式</li>
<li><code>MODE_RINGTONE</code> : 铃声模式</li>
<li><code>MODE_IN_CALL</code> : 通话模式</li>
<li><code>MODE_IN_COMMUNICATION</code> : 通信模式，包括音/视频,VoIP通话.(3.0加入的，与通话模式类似)</li>
</ul>
<p>在设置播放模式的时候，需要考虑流类型，我在这里使用的流类型是 <code>STREAM_MUSIC</code> ，所以切换播放设备的时候就需要设置为<strong><code>MODE_IN_COMMUNICATION</code></strong> 模式而不是 <code>MODE_NORMAL</code> 模式。可以参考<a href="http://stackoverflow.com/questions/31871328/android-5-0-audiomanager-setmode-not-working" target="_blank" rel="external"><strong>这个问题</strong></a>。</p>
<h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a><strong>解决问题</strong></h2><p>使用以下方法切换音频Audio输出，参考<a href="http://stackoverflow.com/questions/22770321/android-switching-audio-between-bluetooth-and-phone-speaker-is-inconsistent" target="_blank" rel="external">Android : Switching audio between Bluetooth and Phone Speaker is inconsistent</a>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">AudioManager audioManager = (AudioManager) context.getSystemService(Context.AUDIO_SERVICE);</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 切换到外放</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeToSpeaker</span><span class="params">()</span></span>&#123;</div><div class="line">	<span class="comment">//注意此处，蓝牙未断开时使用MODE_IN_COMMUNICATION而不是MODE_NORMAL</span></div><div class="line">    mAudioManager.setMode(bluetoothIsConnected ? AudioManager.MODE_IN_COMMUNICATION : AudioManager.MODE_NORMAL);    </div><div class="line">	mAudioManager.stopBluetoothSco();</div><div class="line">	mAudioManager.setBluetoothScoOn(<span class="keyword">false</span>);</div><div class="line">	mAudioManager.setSpeakerphoneOn(<span class="keyword">true</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 切换到蓝牙音箱</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeToHeadset</span><span class="params">()</span></span>&#123;</div><div class="line">    mAudioManager.setMode(AudioManager.MODE_IN_COMMUNICATION);</div><div class="line">	mAudioManager.startBluetoothSco();</div><div class="line">	mAudioManager.setBluetoothScoOn(<span class="keyword">true</span>);</div><div class="line">	mAudioManager.setSpeakerphoneOn(<span class="keyword">false</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/************************************************************/</span></div><div class="line"><span class="comment">//注意：以下两个方法还未验证</span></div><div class="line"><span class="comment">/************************************************************/</span></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 切换到耳机模式</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeToHeadset</span><span class="params">()</span></span>&#123;</div><div class="line">    mAudioManager.setMode(AudioManager.MODE_IN_COMMUNICATION);</div><div class="line">	mAudioManager.stopBluetoothSco();</div><div class="line">	mAudioManager.setBluetoothScoOn(<span class="keyword">false</span>);</div><div class="line">	mAudioManager.setSpeakerphoneOn(<span class="keyword">false</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 切换到听筒</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeToReceiver</span><span class="params">()</span></span>&#123;</div><div class="line">    audioManager.setSpeakerphoneOn(<span class="keyword">false</span>);</div><div class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.HONEYCOMB)&#123;</div><div class="line">        audioManager.setMode(AudioManager.MODE_IN_COMMUNICATION);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        audioManager.setMode(AudioManager.MODE_IN_CALL);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>直接切换输出通道的方法我们已经知道了。剩下需要解决的问题是，<strong>当蓝牙设备断开、连接的时候，我们希望可以自动切换到用户原本设置的输出通道上</strong>，比如在蓝牙未连接时，用户设置的是希望通过蓝牙播报，所以应该在蓝牙一旦连接以后，就把音频切换到蓝牙设备上。</p>
<p>下面我们就看看如何监听蓝牙设备的连接状态。</p>
<h2 id="监听蓝牙连接状态"><a href="#监听蓝牙连接状态" class="headerlink" title="监听蓝牙连接状态"></a><strong>监听蓝牙连接状态</strong></h2><p>首先注意使用前需要以下权限：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.BLUETOOTH_ADMIN"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.BLUETOOTH"</span> /&gt;</span></div></pre></td></tr></table></figure>
<p>根据<a href="http://blog.csdn.net/l627859442/article/details/7918597" target="_blank" rel="external">这篇文章</a>，我们发现可以使用 <a href="https://developer.android.com/reference/android/media/AudioManager.html#ACTION_AUDIO_BECOMING_NOISY" target="_blank" rel="external"><code>AudioManager.ACTION_AUDIO_BECOMING_NOISY</code></a> 这个Intent Action来监听蓝牙断开、耳机插拔的广播，但是测试发现，它也只能收到蓝牙断开的广播，无法接收到蓝牙连接的广播，所以不是我们想要的。</p>
<p>进一步找到这篇文章：<a href="http://blog.csdn.net/xiaoqiaozhongcai/article/details/52857910" target="_blank" rel="external">关于蓝牙开发，必须注意的广播</a>，总结了以下蓝牙广播。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 有注释的广播，蓝牙连接时都会用到</div><div class="line"> */</div><div class="line">intentFilter.addAction(BluetoothDevice.ACTION_FOUND); <span class="comment">//搜索蓝压设备，每搜到一个设备发送一条广播</span></div><div class="line">intentFilter.addAction(BluetoothDevice.ACTION_BOND_STATE_CHANGED); <span class="comment">//配对开始时，配对成功时</span></div><div class="line">intentFilter.addAction(BluetoothDevice.ACTION_ACL_CONNECTED); <span class="comment">//配对时，发起连接</span></div><div class="line">intentFilter.addAction(BluetoothDevice.ACTION_ACL_DISCONNECT_REQUESTED);</div><div class="line">intentFilter.addAction(BluetoothDevice.ACTION_ACL_DISCONNECTED); <span class="comment">//配对结束时，断开连接</span></div><div class="line">intentFilter.addAction(PAIRING_REQUEST); <span class="comment">//配对请求（Android.bluetooth.device.action.PAIRING_REQUEST）</span></div><div class="line"></div><div class="line">intentFilter.addAction(BluetoothAdapter.ACTION_DISCOVERY_STARTED); <span class="comment">//开始搜索</span></div><div class="line">intentFilter.addAction(BluetoothAdapter.ACTION_DISCOVERY_FINISHED); <span class="comment">//搜索结束。重新搜索时，会先终止搜索</span></div><div class="line">intentFilter.addAction(BluetoothAdapter.ACTION_REQUEST_DISCOVERABLE);</div><div class="line">intentFilter.addAction(BluetoothAdapter.ACTION_STATE_CHANGED); <span class="comment">//本机开启、关闭蓝牙开关 </span></div><div class="line">intentFilter.addAction(BluetoothAdapter.ACTION_CONNECTION_STATE_CHANGED); <span class="comment">//蓝牙设备连接或断开</span></div><div class="line">intentFilter.addAction(BluetoothAdapter.ACTION_LOCAL_NAME_CHANGED); <span class="comment">//更改蓝牙名称，打开蓝牙时，可能会调用多次</span></div><div class="line">intentFilter.addAction(BluetoothAdapter.ACTION_REQUEST_DISCOVERABLE);</div><div class="line">intentFilter.addAction(BluetoothAdapter.ACTION_REQUEST_ENABLE);</div><div class="line">intentFilter.addAction(BluetoothAdapter.ACTION_SCAN_MODE_CHANGED); <span class="comment">//搜索模式改变</span></div></pre></td></tr></table></figure>
<p>我们发现了<a href="https://developer.android.com/reference/android/bluetooth/BluetoothAdapter.html#ACTION_CONNECTION_STATE_CHANGED" target="_blank" rel="external"><code>BluetoothAdapter.ACTION_CONNECTION_STATE_CHANGED</code></a> 和 <a href="https://developer.android.com/reference/android/bluetooth/BluetoothAdapter.html#ACTION_STATE_CHANGED" target="_blank" rel="external"><code>BluetoothAdapter.ACTION_STATE_CHANGED</code></a> 这两个Intent广播。</p>
<p>那么这两个广播Intent的区别是什么呢？只用其中一个可以吗？查看Google文档发现</p>
<ul>
<li><p><strong><code>BluetoothAdapter.ACTION_CONNECTION_STATE_CHANGED</code></strong> ：指的是本地蓝牙适配器的<strong>连接状态</strong>的发生改变（比如没有关闭本机蓝牙开关时，另外一个配对设备自己把连接断开）</p>
</li>
<li><p><strong><code>BluetoothAdapter.ACTION_STATE_CHANGED</code></strong> ：指的是本地蓝牙适配器的<strong>状态</strong>已更改。 例如，蓝牙开关打开或关闭。</p>
</li>
</ul>
<p>换句话说，一个是用于连接状态的变化，另一个用于蓝牙适配器本身的状态变化。经过测试发现，如果只使用<code>BluetoothAdapter.ACTION_CONNECTION_STATE_CHANGED</code> 监听广播，则会接收不到“主动关闭本机蓝牙开关”的广播事件。但只是用<code>BluetoothAdapter.ACTION_STATE_CHANGED</code> 的话，很明显这时候蓝牙设备并未真正配对。</p>
<p>动态注册蓝牙连接、断开广播的方式如下：</p>
<ul>
<li>动态注册广播</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BluetoothConnectionReceiver</span> <span class="keyword">extends</span> <span class="title">BroadcastReceiver</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span> (BluetoothAdapter.ACTION_CONNECTION_STATE_CHANGED.equals(intent.getAction())) &#123;		<span class="comment">//蓝牙连接状态</span></div><div class="line">			<span class="keyword">int</span> state = intent.getIntExtra(BluetoothAdapter.EXTRA_CONNECTION_STATE, -<span class="number">1</span>);</div><div class="line">			<span class="keyword">if</span> (state == BluetoothAdapter.STATE_CONNECTED || state == BluetoothAdapter.STATE_DISCONNECTED) &#123;</div><div class="line">				<span class="comment">//连接或失联，切换音频输出（到蓝牙、或者强制仍然扬声器外放）</span></div><div class="line">			&#125;</div><div class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (BluetoothAdapter.ACTION_STATE_CHANGED.equals(intent.getAction()))&#123;	<span class="comment">//本地蓝牙打开或关闭</span></div><div class="line">			<span class="keyword">int</span> state = intent.getIntExtra(BluetoothAdapter.EXTRA_STATE, -<span class="number">1</span>);</div><div class="line">			<span class="keyword">if</span> (state == BluetoothAdapter.STATE_OFF || state == BluetoothAdapter.STATE_TURNING_OFF) &#123;</div><div class="line">				 <span class="comment">//断开，切换音频输出</span></div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">BluetoothConnectionReceiver audioNoisyReceiver = <span class="keyword">new</span> BluetoothConnectionReceiver();</div><div class="line"></div><div class="line"><span class="comment">//蓝牙状态广播监听</span></div><div class="line">IntentFilter audioFilter = <span class="keyword">new</span> IntentFilter();</div><div class="line">audioFilter.addAction(BluetoothAdapter.ACTION_CONNECTION_STATE_CHANGED);</div><div class="line">audioFilter.addAction(BluetoothAdapter.ACTION_STATE_CHANGED);</div><div class="line">mContext.registerReceiver(audioNoisyReceiver, audioFilter);</div></pre></td></tr></table></figure>
<p>之后，我们就可以根据上面切换音频输出通道的代码来实现蓝牙设备连接、断开以后<strong>强制打破操作系统原有的输出通道切换策略</strong>，来实现我们自己想要的切换功能了。</p>
<h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p>1、<a href="http://blog.csdn.net/l627859442/article/details/7918597" target="_blank" rel="external">Android中的Audio播放：控制Audio输出通道切换 </a><br>2、<a href="http://www.devwiki.net/2015/09/20/Android-Music-Play-Mode/" target="_blank" rel="external">Android音乐播放模式切换-外放、听筒、耳机</a><br>3、<a href="http://stackoverflow.com/questions/22770321/android-switching-audio-between-bluetooth-and-phone-speaker-is-inconsistent" target="_blank" rel="external">Android : Switching audio between Bluetooth and Phone Speaker is inconsistent</a><br>4、<a href="http://www.b2cloud.com.au/tutorial/listening-to-bluetooth-connections/" target="_blank" rel="external">Listening to bluetooth connections</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;手机音频的输出有外放（Speaker）、听筒（Telephone Receiver）、有线耳机（WiredHeadset）、蓝牙音箱（Bluetooth A2DP）等输出设备。在平时，电话免提、插拔耳机、连接断开蓝牙设备等操作系统都会自动切换Audio音频到相应的输出设备上。比如电话免提就是从听筒切换到外放扬声器，插入耳机就是从外放切换到耳机。&lt;/p&gt;
&lt;h2 id=&quot;场景需求&quot;&gt;&lt;a href=&quot;#场景需求&quot; class=&quot;headerlink&quot; title=&quot;场景需求&quot;&gt;&lt;/a&gt;&lt;strong&gt;场景需求&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;Android系统自动切换的这些策略，并不能全部满足我们的产品需求，比如音乐App需要对听歌时拔出耳机的操作进行阻止（暂停播放），防止突然切换到外放导致尴尬。&lt;/p&gt;
&lt;p&gt;最近项目需求希望&lt;strong&gt;&lt;code&gt;即使在连接蓝牙音箱的情况下，仍旧使用手机外放播放音频&lt;/code&gt;&lt;/strong&gt;。这就需要强制切换Audio输出通道，打破系统原有的策略。&lt;/p&gt;
&lt;p&gt;查阅资料，看到了Android中可以通过&lt;code&gt;AudioManager&lt;/code&gt;查询、切换当前Audio输出通道，并且在Audio输出发生变化时，捕获并处理这种变化。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://github.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://github.com/tags/Android/"/>
    
      <category term="Audio" scheme="http://github.com/tags/Audio/"/>
    
  </entry>
  
  <entry>
    <title>Google 面试题 | 判断字符串是否可由重复子字符串组成</title>
    <link href="http://github.com/2017/05/05/Google%20%E9%9D%A2%E8%AF%95%E9%A2%98%20-%20%E5%88%A4%E6%96%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%98%AF%E5%90%A6%E5%8F%AF%E7%94%B1%E9%87%8D%E5%A4%8D%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BB%84%E6%88%90/"/>
    <id>http://github.com/2017/05/05/Google 面试题 - 判断字符串是否可由重复子字符串组成/</id>
    <published>2017-05-05T09:20:55.000Z</published>
    <updated>2017-07-14T05:42:59.043Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h2><p>对于一个非空字符串，判断其是否可由一个子字符串重复多次组成。字符串只包含小写字母且长度不超过10000。</p>
<h3 id="样例1"><a href="#样例1" class="headerlink" title="样例1"></a>样例1</h3><blockquote>
<ul>
<li><strong>输入</strong>： “abab”</li>
<li><strong>输出</strong>： True</li>
<li><strong>样例解释</strong>： 输入可由”ab”重复两次组成</li>
</ul>
</blockquote>
<h3 id="样例-2"><a href="#样例-2" class="headerlink" title="样例 2"></a>样例 2</h3><blockquote>
<ul>
<li><strong>输入</strong>： “aba”</li>
<li><strong>输出</strong>： False</li>
</ul>
</blockquote>
<h3 id="样例-3"><a href="#样例-3" class="headerlink" title="样例 3"></a>样例 3</h3><blockquote>
<ul>
<li><strong>输入</strong>： “abcabcabcabc”</li>
<li><strong>输出</strong>： True</li>
<li><strong>样例解释</strong>：输入可由”abc”重复四次组成</li>
</ul>
</blockquote>
<a id="more"></a>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><strong>解题思路</strong></h2><h3 id="1-一个简单的思路"><a href="#1-一个简单的思路" class="headerlink" title="1. 一个简单的思路"></a><strong>1. 一个简单的思路</strong></h3><p>枚举子字符串的长度lenSub &lt; len(len为原字符串长度)，将原字符串分成多个子字符串，每个子字符串长度为lenSub（由此可见，lenSub整除len），再判断这些子字符串是否全部相等，若全部相等，则返回True，如果对于所有lenSub均不满足该条件，则返回False。时间复杂度为O(len*v(len))，其中v(len)为len的因数个数（因为我们只需要对整除len的lenSub进行进一步判断）。</p>
<h3 id="2-下面再说一种神奇的方法"><a href="#2-下面再说一种神奇的方法" class="headerlink" title="2. 下面再说一种神奇的方法"></a><strong>2. 下面再说一种神奇的方法</strong></h3><p>由kmp算法中的next数组实现。</p>
<ol>
<li><p>字符串s的下标从0到n-1，n为字符串长度，记s(i)表示s的第i位字符，s(i,j)表示从s的第i位到第j位的子字符串，若i&gt;j，则s(i,j)=””(空串）。</p>
</li>
<li><p>next数组的定义为：next(i)=p，表示p为小于i且满足s(0 , p) = s(i-p , i)的最大的p，如果不存在这样的p，则next(i) = -1，显然next(0) = -1。我们可以用O(n)的时间计算出next数组。假设我们已知next(0)，next(1)，……，next(i-1) ，现在要求next(i)，不妨设next(i-1) = j0，则由next数组定义可知s(0 , j0) = s(i-1-j0 , i-1)。</p>
<ul>
<li><p>若s(j0+1) = s(i)，则结合s(0 , j0) = s(i-1-j0 , i-1)可知s(0 , j0+1) = s(i - (j0+1) , i)，由此可知，next(i)=j0+1。</p>
</li>
<li><p>若s(j0+1)!=s(i)但s(next(j0)+1)=s(i)，记j1=next(j0)，则s(j1+1)=s(i)，由next数组的定义，s(0 , j1) = s(j0 - j1 , j0) = s(i - 1 - j1 , i - 1)，即s(0，j1) = s(i - 1 - j1 , i - 1)，由假设s(j1+1) = s(i)，则s(0 , j1+1) = s(i - (j1+1) , i)，故next(i) = j1+1。</p>
</li>
<li><p>同前两步的分析，如果我们能找到一个k，使得对于所有小于k的k0，s(j(k0)+1)!=s(i)，但有s(j(k)+1) = s(i)，则由next数组的定义可以得到next(i)=j(k)+1，否则需进一步考虑j(k+1) = next(j(k))，如果我们找不到这样的k，则next(i)=-1。</p>
</li>
</ul>
</li>
<li><p>对于字符串s，如果j满足，0&lt;=j&lt;=n-1，且s(0，j) = s(n-1-j，n-1)，令k=n-1-j，若k整除n，不妨设n=mk，则s(0，(m-1)k - 1) = s(k，mk - 1)，即s(0，k-1) = s(k，2k-1) = …… = s((m-1)k - 1，mk - 1)，即s满足题设条件。故要判断s是否为重复子串组成，只需找到满足上述条件的j，且k整除n，即说明s满足条件，否则不满足。</p>
</li>
<li><p>利用已算出的next(n-1)，令k=n-1-next(n-1)，由c可知，若k整除n，且k &lt; n，则s满足条件，否则不满足。上述算法的复杂度可证明为O(n)。</p>
</li>
</ol>
<h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a><strong>参考代码</strong></h2><p>参考代码给出了利用next数组求解的代码。来自<a href="http://www.jiuzhang.com/solutions/repeated-substring-pattern/" target="_blank" rel="external"><strong>九章算法答案</strong></a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">repeatedSubstringPattern</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> l = s.length();</div><div class="line">        <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[l];</div><div class="line">        next[<span class="number">0</span>] = -<span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> i, j = -<span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; l; i++) &#123;</div><div class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; s.charAt(i) != s.charAt(j + <span class="number">1</span>)) &#123;</div><div class="line">                j = next[j];</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (s.charAt(i) == s.charAt(j + <span class="number">1</span>)) &#123;</div><div class="line">                j++;</div><div class="line">            &#125;</div><div class="line">            next[i] = j;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> lenSub = l - <span class="number">1</span> - next[l - <span class="number">1</span>];</div><div class="line">        <span class="keyword">return</span> lenSub != l &amp;&amp; l % lenSub ==<span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="面试官角度分析"><a href="#面试官角度分析" class="headerlink" title="面试官角度分析"></a><strong>面试官角度分析</strong></h2><p>这道题的第一种解法比较简单，考察穷举和字符串处理的能力，给出第一种方法并正确分析时间复杂度基本可以达到hire；如果面试者对KMP算法有了解，可以给出第二种next数组的算法可以达到strong hire。</p>
<p>本文来自九章算法公众号 <a href="http://mp.weixin.qq.com/s?__biz=MzA5MzE4MjgyMw==&amp;mid=2649457295&amp;idx=1&amp;sn=e2f9448ff2b83c36f2abc343936125b8&amp;chksm=887eec87bf096591aa2ae39c12003e786e9ffbf738d2784d26f70f9db6fe1a57099eb5cb129d&amp;mpshare=1&amp;scene=1&amp;srcid=05059UsS011ChQckeShTIQX4#rd" target="_blank" rel="external">Google 面试题 | 重复子字符串模式</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;对于一个非空字符串，判断其是否可由一个子字符串重复多次组成。字符串只包含小写字母且长度不超过10000。&lt;/p&gt;
&lt;h3 id=&quot;样例1&quot;&gt;&lt;a href=&quot;#样例1&quot; class=&quot;headerlink&quot; title=&quot;样例1&quot;&gt;&lt;/a&gt;样例1&lt;/h3&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;输入&lt;/strong&gt;： “abab”&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;输出&lt;/strong&gt;： True&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;样例解释&lt;/strong&gt;： 输入可由”ab”重复两次组成&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;样例-2&quot;&gt;&lt;a href=&quot;#样例-2&quot; class=&quot;headerlink&quot; title=&quot;样例 2&quot;&gt;&lt;/a&gt;样例 2&lt;/h3&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;输入&lt;/strong&gt;： “aba”&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;输出&lt;/strong&gt;： False&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;样例-3&quot;&gt;&lt;a href=&quot;#样例-3&quot; class=&quot;headerlink&quot; title=&quot;样例 3&quot;&gt;&lt;/a&gt;样例 3&lt;/h3&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;输入&lt;/strong&gt;： “abcabcabcabc”&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;输出&lt;/strong&gt;： True&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;样例解释&lt;/strong&gt;：输入可由”abc”重复四次组成&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://github.com/categories/Algorithm/"/>
    
    
      <category term="Google" scheme="http://github.com/tags/Google/"/>
    
  </entry>
  
  <entry>
    <title>【Android】判断应用Application、Activity是否处于活动状态</title>
    <link href="http://github.com/2017/05/03/%E3%80%90Android%E3%80%91%E5%88%A4%E6%96%AD%E5%BA%94%E7%94%A8Application%E3%80%81Activity%E6%98%AF%E5%90%A6%E5%A4%84%E4%BA%8E%E6%B4%BB%E5%8A%A8%E7%8A%B6%E6%80%81/"/>
    <id>http://github.com/2017/05/03/【Android】判断应用Application、Activity是否处于活动状态/</id>
    <published>2017-05-03T07:03:00.000Z</published>
    <updated>2017-05-18T04:53:22.073Z</updated>
    
    <content type="html"><![CDATA[<p>通过<strong><code>ActivityManager</code></strong>我们可以获得系统里正在运行的activities，包括进程(Process)等、应用程序/包、服务(Service)、任务(Task)信息。</p>
<h2 id="1、判断应用App是否活动"><a href="#1、判断应用App是否活动" class="headerlink" title="1、判断应用App是否活动"></a><strong>1、判断应用App是否活动</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 判断应用是否已经启动</div><div class="line"> * <span class="doctag">@param</span> context 一个context</div><div class="line"> * <span class="doctag">@param</span> packageName 要判断应用的包名</div><div class="line"> * <span class="doctag">@return</span> boolean</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isAppAlive</span><span class="params">(Context context, String packageName)</span></span>&#123;</div><div class="line">   ActivityManager activityManager =</div><div class="line">           (ActivityManager)context.getSystemService(Context.ACTIVITY_SERVICE);</div><div class="line">   List&lt;ActivityManager.RunningAppProcessInfo&gt; processInfos</div><div class="line">           = activityManager.getRunningAppProcesses();</div><div class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; processInfos.size(); i++)&#123;</div><div class="line">       <span class="keyword">if</span>(processInfos.get(i).processName.equals(packageName))&#123;</div><div class="line">           Log.i(<span class="string">"NotificationLaunch"</span>,</div><div class="line">                   String.format(<span class="string">"the %s is running, isAppAlive return true"</span>, packageName));</div><div class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   Log.i(<span class="string">"NotificationLaunch"</span>,</div><div class="line">           String.format(<span class="string">"the %s is not running, isAppAlive return false"</span>, packageName));</div><div class="line">   <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="2、判断Activity是否活动"><a href="#2、判断Activity是否活动" class="headerlink" title="2、判断Activity是否活动"></a><strong>2、判断Activity是否活动</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 判断MainActivity是否活动</div><div class="line"> * <span class="doctag">@param</span> context 一个context</div><div class="line"> * <span class="doctag">@param</span> activityName 要判断Activity</div><div class="line"> * <span class="doctag">@return</span> boolean</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isMainActivityAlive</span><span class="params">(Context context, String activityName)</span></span>&#123;</div><div class="line">   ActivityManager am = (ActivityManager)context.getSystemService(Context.ACTIVITY_SERVICE);</div><div class="line">   List&lt;ActivityManager.RunningTaskInfo&gt; list = am.getRunningTasks(<span class="number">100</span>);</div><div class="line">   <span class="keyword">for</span> (ActivityManager.RunningTaskInfo info : list) &#123;</div><div class="line">       <span class="comment">// 注意这里的 topActivity 包含 packageName和className，可以打印出来看看</span></div><div class="line">       <span class="keyword">if</span> (info.topActivity.toString().equals(activityName) || info.baseActivity.toString().equals(activityName)) &#123;</div><div class="line">           Log.i(TAG,info.topActivity.getPackageName() + <span class="string">" info.baseActivity.getPackageName()="</span>+info.baseActivity.getPackageName());</div><div class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="3、Activity是否显示在前台"><a href="#3、Activity是否显示在前台" class="headerlink" title="3、Activity是否显示在前台"></a><strong>3、Activity是否显示在前台</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 检测某Activity是否在当前Task的栈顶</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isTopActivity</span><span class="params">(String activityName)</span></span>&#123;</div><div class="line">	ActivityManager manager = (ActivityManager) mContext.getSystemService(ACTIVITY_SERVICE);</div><div class="line">	List&lt;ActivityManager.RunningTaskInfo&gt; runningTaskInfos = manager.getRunningTasks(<span class="number">1</span>);</div><div class="line">	String cmpNameTemp = <span class="keyword">null</span>;</div><div class="line">	<span class="keyword">if</span>(runningTaskInfos != <span class="keyword">null</span>)&#123;</div><div class="line">		cmpNameTemp = runningTaskInfos.get(<span class="number">0</span>).topActivity.toString();</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span>(cmpNameTemp == <span class="keyword">null</span>)&#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> cmpNameTemp.equals(activityName);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="4、Service是否在运行"><a href="#4、Service是否在运行" class="headerlink" title="4、Service是否在运行"></a><strong>4、Service是否在运行</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**  </span></div><div class="line"> * 用来判断服务是否运行.  </div><div class="line"> * <span class="doctag">@param</span> context  </div><div class="line"> * <span class="doctag">@param</span> className 判断的服务名字  </div><div class="line"> * <span class="doctag">@return</span> true 在运行 false 不在运行  </div><div class="line"> */  </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isServiceRunning</span><span class="params">(Context mContext,String className)</span> </span>&#123;   </div><div class="line">    <span class="keyword">boolean</span> isRunning = <span class="keyword">false</span>;   </div><div class="line">    ActivityManager activityManager = (ActivityManager)   </div><div class="line">                                 mContext.getSystemService(Context.ACTIVITY_SERVICE);    </div><div class="line">    List&lt;ActivityManager.RunningServiceInfo&gt; serviceList = activityManager.getRunningServices(<span class="number">30</span>);   </div><div class="line">    <span class="keyword">if</span> (!(serviceList.size()&gt;<span class="number">0</span>)) &#123;   </div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;   </div><div class="line">    &#125;   </div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;serviceList.size(); i++) &#123;   </div><div class="line">        <span class="keyword">if</span> (serviceList.get(i).service.getClassName().equals(className) == <span class="keyword">true</span>) &#123;   </div><div class="line">            isRunning = <span class="keyword">true</span>;   </div><div class="line">            <span class="keyword">break</span>;   </div><div class="line">        &#125;   </div><div class="line">    &#125;   </div><div class="line">    <span class="keyword">return</span> isRunning;   </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>1、<a href="http://blog.csdn.net/hp910315/article/details/49908203" target="_blank" rel="external">Android中ActivityManager的使用案例</a><br>2、<a href="https://github.com/slimhippo/androidcode/blob/master/NotificationLaunch/app/src/main/java/com/liangzili/notificationlaunch/SystemUtils.java">Android实现点击通知栏后，先启动应用再打开目标Activity的一个小demo</a><br>3、<a href="https://my.oschina.net/ososchina/blog/350498" target="_blank" rel="external">Android ActivityManager 检测Service与Activity是否正在运行</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;通过&lt;strong&gt;&lt;code&gt;ActivityManager&lt;/code&gt;&lt;/strong&gt;我们可以获得系统里正在运行的activities，包括进程(Process)等、应用程序/包、服务(Service)、任务(Task)信息。&lt;/p&gt;
&lt;h2 id=&quot;1、判断应用App是否活动&quot;&gt;&lt;a href=&quot;#1、判断应用App是否活动&quot; class=&quot;headerlink&quot; title=&quot;1、判断应用App是否活动&quot;&gt;&lt;/a&gt;&lt;strong&gt;1、判断应用App是否活动&lt;/strong&gt;&lt;/h2&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; * 判断应用是否已经启动&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; * &lt;span class=&quot;doctag&quot;&gt;@param&lt;/span&gt; context 一个context&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; * &lt;span class=&quot;doctag&quot;&gt;@param&lt;/span&gt; packageName 要判断应用的包名&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; * &lt;span class=&quot;doctag&quot;&gt;@return&lt;/span&gt; boolean&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;isAppAlive&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Context context, String packageName)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   ActivityManager activityManager =&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;           (ActivityManager)context.getSystemService(Context.ACTIVITY_SERVICE);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   List&amp;lt;ActivityManager.RunningAppProcessInfo&amp;gt; processInfos&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;           = activityManager.getRunningAppProcesses();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; processInfos.size(); i++)&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;       &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(processInfos.get(i).processName.equals(packageName))&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;           Log.i(&lt;span class=&quot;string&quot;&gt;&quot;NotificationLaunch&quot;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                   String.format(&lt;span class=&quot;string&quot;&gt;&quot;the %s is running, isAppAlive return true&quot;&lt;/span&gt;, packageName));&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;           &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;       &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   Log.i(&lt;span class=&quot;string&quot;&gt;&quot;NotificationLaunch&quot;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;           String.format(&lt;span class=&quot;string&quot;&gt;&quot;the %s is not running, isAppAlive return false&quot;&lt;/span&gt;, packageName));&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Android" scheme="http://github.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://github.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>【Android】使用UncaughtExceptionHandler捕获全局异常</title>
    <link href="http://github.com/2017/04/20/%E3%80%90Android%E3%80%91%E4%BD%BF%E7%94%A8UncaughtExceptionHandler%E6%8D%95%E8%8E%B7%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8/"/>
    <id>http://github.com/2017/04/20/【Android】使用UncaughtExceptionHandler捕获全局异常/</id>
    <published>2017-04-20T06:10:55.000Z</published>
    <updated>2017-04-20T06:21:50.191Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a><strong>简介</strong></h2><p>当程序崩溃（Crash）的时候，默认是不对异常信息做处理的。如果想要把异常信息保存到本地文件中，或上传的服务器。那么就要借助<strong><code>UncaughtExceptionHandler</code></strong>这个类。</p>
<a id="more"></a>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a><strong>使用方法</strong></h2><h3 id="一、实例化"><a href="#一、实例化" class="headerlink" title="一、实例化"></a>一、实例化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CrashLogCatch</span> </span>&#123;</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String THREAD_NAME_MAIN = <span class="string">"com.example.ABC"</span>;   <span class="comment">//主线程名称</span></div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String THREAD_NAME_REMOTE = <span class="string">"com.example.ABC:remote_service"</span>;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initCrashLog</span><span class="params">(<span class="keyword">final</span> Context context)</span> </span>&#123;</div><div class="line">		<span class="keyword">final</span> Thread.UncaughtExceptionHandler oriHandler = Thread.getDefaultUncaughtExceptionHandler();</div><div class="line">		Thread.setDefaultUncaughtExceptionHandler(<span class="keyword">new</span> Thread.UncaughtExceptionHandler() &#123;</div><div class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread thread, Throwable e)</span> </span>&#123;</div><div class="line">				<span class="keyword">try</span> &#123;</div><div class="line">					StringBuilder buffer = <span class="keyword">new</span> StringBuilder();</div><div class="line">					buffer.append(getCurProcessName(context) + <span class="string">"\n"</span>);</div><div class="line">					buffer.append(<span class="string">"uncaught exception at "</span>)</div><div class="line">							.append(<span class="keyword">new</span> Date(System.currentTimeMillis()))</div><div class="line">							.append(<span class="string">"\n"</span>);</div><div class="line">					buffer.append(ExceptionUtils.formatException(e));</div><div class="line">	</div><div class="line">					String log = HttpLogController.getInstance().makeCrashLog(buffer.toString());</div><div class="line">					<span class="comment">//发送崩溃日志</span></div><div class="line">					sendExceptionLog(log);</div><div class="line">					SdLog.dFileAlways(<span class="string">"crash"</span> + System.currentTimeMillis() + <span class="string">".log"</span>, log);</div><div class="line">					</div><div class="line">					<span class="keyword">if</span> (Global.DEBUG) &#123;</div><div class="line">						oriHandler.uncaughtException(thread, e);  <span class="comment">//debug模式，默认抛出异常</span></div><div class="line">					&#125; <span class="keyword">else</span> &#123;</div><div class="line">						String threadName = thread.getName();</div><div class="line">						</div><div class="line">						<span class="keyword">if</span> (threadName.equals(THREAD_NAME_REMOTE)) &#123;</div><div class="line">							android.os.Process.killProcess(android.os.Process.myPid());  <span class="comment">//如果是service直接kill掉</span></div><div class="line">						&#125; <span class="keyword">else</span> <span class="keyword">if</span> (threadName.equals(THREAD_NAME_MAIN)) &#123;</div><div class="line">							oriHandler.uncaughtException(thread, e);  <span class="comment">//如果是主线程，抛出异常</span></div><div class="line">						&#125;</div><div class="line">					&#125;</div><div class="line">				&#125; <span class="keyword">catch</span> (Exception ex) &#123;&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="comment">/**</span></div><div class="line">	* 获取当前进程名</div><div class="line">	*/</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getCurProcessName</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			<span class="keyword">int</span> pid = android.os.Process.myPid();</div><div class="line">			ActivityManager mActivityManager = (ActivityManager)context.getSystemService(Context.ACTIVITY_SERVICE);</div><div class="line">			<span class="keyword">for</span> (ActivityManager.RunningAppProcessInfo appProcess : mActivityManager.getRunningAppProcesses()) &#123;</div><div class="line">				<span class="keyword">if</span> (appProcess.pid == pid)&#123;</div><div class="line">					<span class="keyword">return</span> appProcess.processName;</div><div class="line">				&#125;</div><div class="line">			&#125; </div><div class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> <span class="string">""</span>;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="comment">/**</span></div><div class="line">	* 发送崩溃日志</div><div class="line">	*/</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sendExceptionLog</span><span class="params">(String log)</span> </span>&#123;</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			JSONObject jsonObject = <span class="keyword">new</span> JSONObject(log);</div><div class="line">			Iterator keyIter = jsonObject.keys();</div><div class="line">			String key;</div><div class="line">			Object value;</div><div class="line">			HashMap&lt;String, Object&gt; valueMap = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</div><div class="line">			<span class="keyword">while</span> (keyIter.hasNext()) &#123;</div><div class="line">				key = (String) keyIter.next();</div><div class="line">				value = jsonObject.get(key);</div><div class="line">				valueMap.put(key, value);</div><div class="line">			&#125;</div><div class="line">			<span class="comment">// 把异常信息发送到服务器 </span></div><div class="line">			ComponentHolder.getLogController().sendLog(valueMap, LogType.EXCEPTION);</div><div class="line">		&#125; <span class="keyword">catch</span> (JSONException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="二、调用"><a href="#二、调用" class="headerlink" title="二、调用"></a>二、调用</h3><h4 id="1、对于整个Application"><a href="#1、对于整个Application" class="headerlink" title="1、对于整个Application"></a><strong>1、对于整个Application</strong></h4><p>只要在指定的Application类的onCreate()回调中，把UncaughtExceptionHandler和Application的实例绑定在一起就可以了。关键代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</div><div class="line">		CrashLogCatch.initCrashLog(<span class="keyword">this</span>);   <span class="comment">//注意这里</span></div><div class="line">		<span class="keyword">super</span>.onCreate();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样，如果程序崩溃，错误日志就会被上传到服务器。</p>
<h4 id="2、绑定Service-实例"><a href="#2、绑定Service-实例" class="headerlink" title="2、绑定Service 实例"></a><strong>2、绑定Service 实例</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</div><div class="line">	    Thread.currentThread().setName(CrashLogCatch.THREAD_NAME_REMOTE);  <span class="comment">//线程名称</span></div><div class="line">		CrashLogCatch.initCrashLog(<span class="keyword">this</span>);   <span class="comment">//注意这里</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="3、绑定BroadcastReceiver实例"><a href="#3、绑定BroadcastReceiver实例" class="headerlink" title="3、绑定BroadcastReceiver实例"></a><strong>3、绑定BroadcastReceiver实例</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LaunchReceiver</span> <span class="keyword">extends</span> <span class="title">BroadcastReceiver</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</div><div class="line">		Thread.currentThread().setName(CrashLogCatch.THREAD_NAME_REMOTE);  <span class="comment">//线程名称</span></div><div class="line">		CrashLogCatch.initCrashLog(context);   <span class="comment">//注意这里</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><strong>参考资料</strong></h2><ul>
<li><a href="http://blog.csdn.net/manoel/article/details/39479101" target="_blank" rel="external">【移动开发】捕获异常信息_UncaughtExceptionHandler</a></li>
<li><a href="http://blog.csdn.net/hehe9737/article/details/7662123" target="_blank" rel="external">Android使用UncaughtExceptionHandler捕获全局异常</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;&lt;strong&gt;简介&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;当程序崩溃（Crash）的时候，默认是不对异常信息做处理的。如果想要把异常信息保存到本地文件中，或上传的服务器。那么就要借助&lt;strong&gt;&lt;code&gt;UncaughtExceptionHandler&lt;/code&gt;&lt;/strong&gt;这个类。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://github.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://github.com/tags/Android/"/>
    
      <category term="Exception" scheme="http://github.com/tags/Exception/"/>
    
  </entry>
  
  <entry>
    <title>【Android 】硬件加速原理与实现简介</title>
    <link href="http://github.com/2017/03/30/%E3%80%90Android%20%E3%80%91%E7%A1%AC%E4%BB%B6%E5%8A%A0%E9%80%9F%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AE%80%E4%BB%8B/"/>
    <id>http://github.com/2017/03/30/【Android 】硬件加速原理与实现简介/</id>
    <published>2017-03-30T07:29:55.000Z</published>
    <updated>2017-03-30T07:39:20.311Z</updated>
    
    <content type="html"><![CDATA[<p>在手机客户端尤其是Android应用的开发过程中，我们经常会接触到“硬件加速”这个词。由于操作系统对底层软硬件封装非常完善，上层软件开发者往往对硬件加速的底层原理了解很少，也不清楚了解底层原理的意义，因此常会有一些误解，如硬件加速是不是通过特殊算法实现页面渲染加速，或是通过硬件提高CPU/GPU运算速率实现渲染加速。</p>
<p>本文尝试从底层硬件原理，一直到上层代码实现，对硬件加速技术进行简单介绍，其中上层实现基于Android 6.0。</p>
<a id="more"></a>
<h2 id="了解硬件加速对App开发的意义"><a href="#了解硬件加速对App开发的意义" class="headerlink" title="了解硬件加速对App开发的意义"></a>了解硬件加速对App开发的意义</h2><p>对于App开发者，简单了解硬件加速原理及上层API实现，开发时就可以充分利用硬件加速提高页面的性能。以Android举例，实现一个圆角矩形按钮通常有两种方案：使用PNG图片；使用代码（XML/Java）实现。简单对比两种方案如下。</p>
<table>
<thead>
<tr>
<th>方案</th>
<th>原理</th>
<th>特点</th>
</tr>
</thead>
<tbody>
<tr>
<td>使用PNG图片（BitmapDrawable）</td>
<td>解码PNG图片生成Bitmap，传到底层，由GPU渲染</td>
<td>图片解码消耗CPU运算资源，Bitmap占用内存大，绘制慢</td>
</tr>
<tr>
<td>使用XML或Java代码实现（ShapeDrawable）</td>
<td>直接将Shape信息传到底层，由GPU渲染</td>
<td>消耗CPU资源少，占用内存小，绘制快</td>
</tr>
</tbody>
</table>
<h2 id="页面渲染背景知识"><a href="#页面渲染背景知识" class="headerlink" title="页面渲染背景知识"></a>页面渲染背景知识</h2><ul>
<li>页面渲染时，被绘制的元素最终要转换成矩阵像素点（即多维数组形式，类似安卓中的Bitmap），才能被显示器显示。</li>
<li>页面由各种基本元素组成，例如圆形、圆角矩形、线段、文字、矢量图（常用贝塞尔曲线组成）、Bitmap等。</li>
<li>元素绘制时尤其是动画绘制过程中，经常涉及插值、缩放、旋转、透明度变化、动画过渡、毛玻璃模糊，甚至包括3D变换、物理运动（例如游戏中常见的抛物线运动）、多媒体文件解码（主要在桌面机中有应用，移动设备一般不用GPU做解码）等运算。</li>
<li>绘制过程经常需要进行逻辑较简单、但数据量庞大的浮点运算。</li>
</ul>
<h2 id="CPU与GPU结构对比"><a href="#CPU与GPU结构对比" class="headerlink" title="CPU与GPU结构对比"></a>CPU与GPU结构对比</h2><p>CPU（Central Processing Unit，中央处理器）是计算机设备核心器件，用于执行程序代码，软件开发者对此都很熟悉；GPU（Graphics Processing Unit，图形处理器）主要用于处理图形运算，通常所说“显卡”的核心部件就是GPU。</p>
<p>下面是CPU和GPU的结构对比图。其中：</p>
<ul>
<li>黄色的Control为控制器，用于协调控制整个CPU的运行，包括取出指令、控制其他模块的运行等；</li>
<li>绿色的ALU（Arithmetic Logic Unit）是算术逻辑单元，用于进行数学、逻辑运算；</li>
<li>橙色的Cache和DRAM分别为缓存和RAM，用于存储信息。</li>
</ul>
<p><img src="/gallery/hardware-accelerate/cpu-gpu.png" alt=""></p>
<ul>
<li><p>从结构图可以看出，CPU的控制器较为复杂，而ALU数量较少。因此CPU擅长各种复杂的逻辑运算，但不擅长数学尤其是浮点运算。</p>
<ul>
<li>以8086为例，一百多条汇编指令大部分都是逻辑指令，数学计算相关的主要是16位加减乘除和移位运算。一次整型和逻辑运算一般需要1~3个机器周期，而浮点运算要转换成整数计算，一次运算可能消耗上百个机器周期。</li>
<li>更简单的CPU甚至只有加法指令，减法用补码加法实现，乘法用累加实现，除法用减法循环实现。</li>
<li>现代CPU一般都带有硬件浮点运算器（FPU），但主要适用于数据量不大的情况。</li>
</ul>
</li>
<li><p>CPU是串行结构。以计算100个数字为例，对于CPU的一个核，每次只能计算两个数的和，结果逐步累加。</p>
</li>
<li><p>和CPU不同的是，GPU就是为实现大量数学运算设计的。从结构图中可以看到，GPU的控制器比较简单，但包含了大量ALU。GPU中的ALU使用了并行设计，且具有较多浮点运算单元。</p>
</li>
<li><p>硬件加速的主要原理，就是通过底层软件代码，将CPU不擅长的图形计算转换成GPU专用指令，由GPU完成。</p>
<p>​</p>
</li>
</ul>
<blockquote>
<p>扩展：很多计算机中的GPU有自己独立的显存；没有独立显存则使用共享内存的形式，从内存中划分一块区域作为显存。显存可以保存GPU指令等信息。</p>
</blockquote>
<h2 id="并行结构举例：级联加法器"><a href="#并行结构举例：级联加法器" class="headerlink" title="并行结构举例：级联加法器"></a>并行结构举例：级联加法器</h2><p>为了方便理解，这里先从底层电路结构的角度举一个例子。如下图为一个加法器，对应实际的数字电路结构。</p>
<ul>
<li>A、B为输入，C为输出，且A、B、C均为总线，以32位CPU为例，则每根总线实际由32根导线组成，每根导线用不同的电压表示一个二进制的0或1。</li>
<li>Clock为时钟信号线，每个固定的时钟周期可向其输入一个特定的电压信号，每当一个时钟信号到来时，A和B的和就会输出到C。</li>
</ul>
<p><img src="/gallery/hardware-accelerate/cascade-adder-1.png" alt=""></p>
<p>现在我们要计算8个整数的和。</p>
<p>对于CPU这种串行结构，代码编写很简单，用for循环把所有数字逐个相加即可。串行结构只有一个加法器，需要7次求和运算；每次计算完部分和，还要将其再转移到加法器的输入端，做下一次计算。整个过程至少要消耗十几个机器周期。</p>
<p>而对于并行结构，一种常见的设计是级联加法器，如下图，其中所有的clock连在一起。当需要相加的8个数据在输入端A1~B4准备好后，经过三个时钟周期，求和操作就完成了。如果数据量更大、级联的层级更大，则并行结构的优势更明显。</p>
<p>由于电路的限制，不容易通过提高时钟频率、减小时钟周期的方式提高运算速度。并行结构通过增加电路规模、并行处理，来实现更快的运算。但并行结构不容易实现复杂逻辑，因为同时考虑多个支路的输出结果，并协调同步处理的过程很复杂（有点像多线程编程）。</p>
<p><img src="/gallery/hardware-accelerate/cascade-adder-2.png" alt=""></p>
<h2 id="GPU并行计算举例"><a href="#GPU并行计算举例" class="headerlink" title="GPU并行计算举例"></a>GPU并行计算举例</h2><p>假设我们有如下图像处理任务，给每个像素值加1。GPU并行计算的方式简单粗暴，在资源允许的情况下，可以为每个像素开一个GPU线程，由其进行加1操作。数学运算量越大，这种并行方式性能优势越明显。</p>
<p><img src="/gallery/hardware-accelerate/render-task.png" alt=""></p>
<h2 id="Android中的硬件加速"><a href="#Android中的硬件加速" class="headerlink" title="Android中的硬件加速"></a>Android中的硬件加速</h2><p>在Android中，大多数应用的界面都是利用常规的View来构建的（除了游戏、视频、图像等应用可能直接使用OpenGL ES）。下面根据Android 6.0原生系统的Java层代码，对View的软件和硬件加速渲染做一些分析和对比。</p>
<h3 id="DisplayList"><a href="#DisplayList" class="headerlink" title="DisplayList"></a>DisplayList</h3><p>DisplayList是一个基本绘制元素，包含元素原始属性（位置、尺寸、角度、透明度等），对应Canvas的drawXxx()方法（如下图）。</p>
<p>信息传递流程：Canvas(Java API) —&gt; OpenGL(C/C++ Lib) —&gt; 驱动程序 —&gt; GPU。</p>
<p>在Android 4.1及以上版本，DisplayList支持属性，如果View的一些属性发生变化（比如Scale、Alpha、Translate），只需把属性更新给GPU，不需要生成新的DisplayList。</p>
<h3 id="RenderNode"><a href="#RenderNode" class="headerlink" title="RenderNode"></a>RenderNode</h3><p>一个RenderNode包含若干个DisplayList，通常一个RenderNode对应一个View，包含View自身及其子View的所有DisplayList。</p>
<p><img src="/gallery/hardware-accelerate/canvas-draw.png" alt=""></p>
<h2 id="Android绘制流程（Android-6-0）"><a href="#Android绘制流程（Android-6-0）" class="headerlink" title="Android绘制流程（Android 6.0）"></a>Android绘制流程（Android 6.0）</h2><p>下面是安卓View完整的绘制流程图，主要通过阅读源码和调试得出，虚线箭头表示递归调用。</p>
<ul>
<li><p>从<code>ViewRootImpl.performTraversals</code>到<code>PhoneWindow.DecroView.drawChild</code>是每次遍历View树的固定流程，首先根据标志位判断是否需要重新布局并执行布局；然后进行Canvas的创建等操作开始绘制。</p>
<ul>
<li>如果硬件加速不支持或者被关闭，则使用软件绘制，生成的Canvas即<code>Canvas.class</code>的对象；</li>
<li>如果支持硬件加速，则生成的是<code>DisplayListCanvas.class</code>的对象；</li>
<li>两者的<code>isHardwareAccelerated()</code>方法返回的值分别为false、true，View根据这个值判断是否使用硬件加速。</li>
</ul>
</li>
<li><p>View中的<code>draw(canvas,parent,drawingTime)</code> - <code>draw(canvas)</code> - <code>onDraw</code> - <code>dispachDraw</code> - <code>drawChild</code>这条递归路径（下文简称<strong>Draw路径</strong>），调用了<code>Canvas.drawXxx()</code>方法，在软件渲染时用于实际绘制；在硬件加速时，用于构建DisplayList。</p>
</li>
<li><p>View中的<code>updateDisplayListIfDirty</code> - <code>dispatchGetDisplayList</code> - <code>recreateChildDisplayList</code>这条递归路径（下文简称<strong>DisplayList路径</strong>），仅在硬件加速时会经过，用于在遍历View树绘制的过程中更新DisplayList属性，并快速跳过不需要重建DisplayList的View。</p>
<blockquote>
<p>Android 6.0中，和DisplayList相关的API目前仍被标记为“@hide”不可访问，表示还不成熟，后续版本可能开放。</p>
</blockquote>
</li>
<li><p>硬件加速情况下，draw流程执行结束后DisplayList构建完成，然后通过<code>ThreadedRenderer.nSyncAndDrawFrame()</code>利用GPU绘制DisplayList到屏幕上。</p>
</li>
</ul>
<p><img src="/gallery/hardware-accelerate/render-func.png" alt=""></p>
<h2 id="纯软件绘制-VS-硬件加速（Android-6-0）"><a href="#纯软件绘制-VS-硬件加速（Android-6-0）" class="headerlink" title="纯软件绘制 VS 硬件加速（Android 6.0）"></a>纯软件绘制 VS 硬件加速（Android 6.0）</h2><p>下面根据具体的几种场景，具体分析一下硬件加速前后的流程与加速效果。</p>
<table>
<thead>
<tr>
<th>渲染场景</th>
<th>纯软件绘制</th>
<th>硬件加速</th>
<th>加速效果分析</th>
</tr>
</thead>
<tbody>
<tr>
<td>页面初始化</td>
<td>绘制所有View</td>
<td>创建所有DisplayList</td>
<td>GPU分担了复杂计算任务</td>
</tr>
<tr>
<td>在一个复杂页面调用背景透明TextView的setText()，且调用后其尺寸位置不变</td>
<td>重绘脏区所有View</td>
<td>TextView及每一级父View重建DisplayList</td>
<td>重叠的兄弟节点不需CPU重绘，GPU会自行处理</td>
</tr>
<tr>
<td>TextView逐帧播放Alpha / Translation / Scale动画</td>
<td>每帧都要重绘脏区所有View</td>
<td>除第一帧同场景2，之后每帧只更新TextView对应RenderNode的属性</td>
<td>刷新一帧性能极大提高，动画流畅度提高</td>
</tr>
<tr>
<td>修改TextView透明度</td>
<td>重绘脏区所有View</td>
<td>直接调用RenderNode.setAlpha()更新</td>
<td>加速前需全页面遍历，并重绘很多View；加速后只触发DecorView.updateDisplayListIfDirty，不再往下遍历，CPU执行时间可忽略不计</td>
</tr>
</tbody>
</table>
<ul>
<li>场景1中，无论是否加速，遍历View树并都会走Draw路径。硬件加速后Draw路径不做实际绘制工作，只是构建DisplayList，复杂的绘制计算任务被GPU分担，已经有了较大的加速效果。</li>
<li>场景2中，TextView设置前后尺寸位置不变，不会触发重新Layout。<ul>
<li>软件绘制时，TextView所在区域即为脏区。由于TextView有透明区域，遍历View树的过程中，和脏区重叠的多数View都要重绘，包括与之重叠的兄弟节点和他们的父节点（详见后面的介绍），不需要绘制的View在<code>draw(canvas,parent,drawingTime)</code>方法中判断直接返回。</li>
<li>硬件加速后，也需要遍历View树，但只有TextView及其每一层父节点需要重建DisplayList，走的是Draw路径，其他View直接走了DisplayList路径，剩下的工作都交给GPU处理。页面越复杂，两者性能差距越明显。</li>
</ul>
</li>
<li>场景3中，软件绘制每一帧都要做大量绘制工作，很容易导致动画卡顿。硬件加速后，动画过程直接走DisplayList路径更新DisplayList的属性，动画流畅度能得到极大提高。</li>
<li>场景4中，两者的性能差距更明显。简单修改透明度，软件绘制仍然要做很多工作；硬件加速后一般直接更新RenderNode的属性，不需要触发invalidate，也不会遍历View树（除了少数View可能要对Alpha做特殊响应并在<code>onSetAlpha()</code>返回true，代码如下）。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">View</span> </span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAlpha</span><span class="params">(@FloatRange(from=<span class="number">0.0</span>, to=<span class="number">1.0</span>)</span> <span class="keyword">float</span> alpha) </span>&#123;</div><div class="line">        ensureTransformationInfo();</div><div class="line">        <span class="keyword">if</span> (mTransformationInfo.mAlpha != alpha) &#123;</div><div class="line">            mTransformationInfo.mAlpha = alpha;</div><div class="line">            <span class="keyword">if</span> (onSetAlpha((<span class="keyword">int</span>) (alpha * <span class="number">255</span>))) &#123;</div><div class="line">                <span class="comment">// ...</span></div><div class="line">                invalidate(<span class="keyword">true</span>);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// ...</span></div><div class="line">                mRenderNode.setAlpha(getFinalAlpha());</div><div class="line">                <span class="comment">// ...</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">onSetAlpha</span><span class="params">(<span class="keyword">int</span> alpha)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="软件绘制刷新逻辑简介"><a href="#软件绘制刷新逻辑简介" class="headerlink" title="软件绘制刷新逻辑简介"></a>软件绘制刷新逻辑简介</h2><p>实际阅读源码并实验，得出通常情况下的软件绘制刷新逻辑：</p>
<ul>
<li>默认情况下，View的clipChildren属性为true，即每个View绘制区域不能超出其父View的范围。如果设置一个页面根布局的clipChildren属性为false，则子View可以超出父View的绘制区域。</li>
<li>当一个View触发invalidate，且没有播放动画、没有触发layout的情况下：<ul>
<li>对于全不透明的View，其自身会设置标志位<code>PFLAG_DIRTY</code>，其父View会设置标志位<code>PFLAG_DIRTY_OPAQUE</code>。在<code>draw(canvas)</code>方法中，只有这个View自身重绘。</li>
<li>对于可能有透明区域的View，其自身和父View都会设置标志位<code>PFLAG_DIRTY</code>。<ul>
<li>clipChildren为true时，脏区会被转换成ViewRoot中的Rect，刷新时层层向下判断，当View与脏区有重叠则重绘。如果一个View超出父View范围且与脏区重叠，但其父View不与脏区重叠，这个子View不会重绘。</li>
<li>clipChildren为false时，<code>ViewGroup.invalidateChildInParent()</code>中会把脏区扩大到自身整个区域，于是与这个区域重叠的所有View都会重绘。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，硬件加速相关的内容就介绍完了，这里做个简单总结：</p>
<ul>
<li>CPU更擅长复杂逻辑控制，而GPU得益于大量ALU和并行结构设计，更擅长数学运算。</li>
<li>页面由各种基础元素（DisplayList）构成，渲染时需要进行大量浮点运算。</li>
<li>硬件加速条件下，CPU用于控制复杂绘制逻辑、构建或更新DisplayList；GPU用于完成图形计算、渲染DisplayList。</li>
<li>硬件加速条件下，刷新界面尤其是播放动画时，CPU只重建或更新必要的DisplayList，进一步提高渲染效率。</li>
<li>实现同样效果，应尽量使用更简单的DisplayList，从而达到更好的性能（Shape代替Bitmap等）。</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://www.cnblogs.com/LBSer/p/4592862.html" target="_blank" rel="external">GPU—并行计算利器</a></li>
<li><a href="http://www.eechina.com/thread-176224-1-1.html" target="_blank" rel="external">显示卡的“心脏”GPU工作原理介绍</a></li>
<li><a href="http://hust.cf/matlab/2016/05/15/Matlab%E7%9A%84GPU%E5%8A%A0%E9%80%9F.html" target="_blank" rel="external">Matlab的GPU加速</a></li>
<li><a href="http://blog.csdn.net/yang_yulei/article/details/22529437" target="_blank" rel="external">处理器体系结构：了解CPU的基本运行原理</a></li>
<li><a href="http://blog.chinaunix.net/uid-23069658-id-3563960.html" target="_blank" rel="external">CPU的内部架构和工作原理</a></li>
<li><a href="http://xilinx.eetrend.com/article/10087" target="_blank" rel="external">什么是异构多处理系统，为什么需要异构多处理系统</a></li>
<li><a href="http://blog.csdn.net/luoshengyang/article/details/45943255" target="_blank" rel="external">Android应用程序UI硬件加速渲染的Display List构建过程分析</a></li>
<li><a href="http://blog.csdn.net/luoshengyang/article/details/46281499" target="_blank" rel="external">Android应用程序UI硬件加速渲染的Display List渲染过程分析</a></li>
<li><a href="http://www.jianshu.com/p/996bca12eb1d" target="_blank" rel="external">Android Choreographer源码分析</a></li>
<li><a href="http://blog.csdn.net/innost/article/details/8272867" target="_blank" rel="external">Android Project Butter分析</a></li>
</ul>
<blockquote>
<p>本文来自美团点评技术团队：<a href="http://tech.meituan.com/hardware-accelerate.html" target="_blank" rel="external"><strong>Android硬件加速原理与实现简介</strong></a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在手机客户端尤其是Android应用的开发过程中，我们经常会接触到“硬件加速”这个词。由于操作系统对底层软硬件封装非常完善，上层软件开发者往往对硬件加速的底层原理了解很少，也不清楚了解底层原理的意义，因此常会有一些误解，如硬件加速是不是通过特殊算法实现页面渲染加速，或是通过硬件提高CPU/GPU运算速率实现渲染加速。&lt;/p&gt;
&lt;p&gt;本文尝试从底层硬件原理，一直到上层代码实现，对硬件加速技术进行简单介绍，其中上层实现基于Android 6.0。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://github.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://github.com/tags/Android/"/>
    
      <category term="GPU" scheme="http://github.com/tags/GPU/"/>
    
  </entry>
  
  <entry>
    <title>【Gradle】Android Studio中Gradle重复依赖的问题</title>
    <link href="http://github.com/2017/02/23/%E3%80%90Gradle%E3%80%91Android%20Studio%E4%B8%ADGradle%E9%87%8D%E5%A4%8D%E4%BE%9D%E8%B5%96%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://github.com/2017/02/23/【Gradle】Android Studio中Gradle重复依赖的问题/</id>
    <published>2017-02-23T05:03:00.000Z</published>
    <updated>2017-02-23T05:24:23.064Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a><strong>问题</strong></h2><p>项目中有个Module需要解析json所以选用了依赖Gson，但是编译时报错如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Error:Execution failed for task &apos;:app:transformClassesWithJarMergingForAutoioDebug&apos;.</div><div class="line">&gt; com.android.build.api.transform.TransformException: java.util.zip.ZipException: duplicate entry: com/google/gson/annotations/Expose.class</div></pre></td></tr></table></figure>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a><strong>分析</strong></h2><p>看到错误中的这个<strong>duplicate</strong>，第一反应和平常一样，难道是得先清理一下Clean project ? 反复试了几次都不行，上网查才发现是重复依赖Gson库的问题，导致项目中有了两个重复的<code>Expose.class</code> 类。</p>
<p>使用快捷键（Shift + Ctrl + T）查看项目中的<code>Expose.class</code> 类，发现是和passport-1.4.2.jar这个本地jar包冲突了，它也依赖了gson库所以导致了重复依赖。</p>
<p><img src="http://img.blog.csdn.net/20170223114733531?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDk4Mzg4MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<a id="more"></a>
<h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><p>在往下面分析之前，需要先根据项目结构说明一下问题的本质，就是Module</p>
<p><img src="http://img.blog.csdn.net/20170223124701598?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDk4Mzg4MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<h3 id="踩过的坑"><a href="#踩过的坑" class="headerlink" title="踩过的坑"></a>踩过的坑</h3><p>第一个查到的解决办法是这个<a href="http://blog.csdn.net/cx1229/article/details/52786168" target="_blank" rel="external"><strong>Android Studio中如何解决重复依赖导致的app:transformClassesWithJarMergingForDebug</strong></a>，但是他的问题是依赖另外一个库retrofit，她用了下面的办法：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">compile</span> (<span class="string">'com.squareup.retrofit2:converter-gson:2.1.0'</span>)&#123;</div><div class="line">	<span class="keyword">exclude</span> <span class="keyword">group</span>: <span class="string">'com.google.code.gson'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所以我也尝试仿照他的方法，在我的Speech模块下的build.gradle文件里修改</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//注意：下面的方法是错的</span></div><div class="line"><span class="keyword">dependencies</span> &#123;</div><div class="line">    <span class="keyword">compile</span> <span class="keyword">fileTree</span>(<span class="keyword">include</span>: <span class="string">'*.jar'</span>, dir: <span class="string">'libs'</span>)&#123;    <span class="comment">//错的</span></div><div class="line">        <span class="keyword">exclude</span> <span class="keyword">group</span>: <span class="string">'com.google.code.gson'</span>, module: <span class="string">'gson'</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>报错如下，显然这么写是不对的，对于依赖本地jar文件这么写是不对的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Error:Could not find method exclude() for arguments [&#123;group=com.google.code.gson, module=gson&#125;] on directory &apos;&#123;include=*.jar, dir=libs&#125;&apos; of type org.gradle.api.internal.file.collections.DefaultConfigurableFileTree.</div></pre></td></tr></table></figure>
<p>但是，他们的解决思路是对的，就是<strong>想办法屏蔽其中一个Gson库</strong>。既然如此，我们可以多尝试各个引入它们的地方。</p>
<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a><strong>解决办法</strong></h2><p>最后试来试去，才发现exclude需要写在App <strong>主Module</strong> 的build.gradle文件中才能生效，而且注意 project(‘:Speech’) 外面那层括号：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">apply plugin: <span class="string">'com.android.application'</span>		<span class="comment">//注意这是主Module</span></div><div class="line"></div><div class="line"><span class="keyword">repositories</span> &#123;</div><div class="line">    mavenCentral()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">dependencies</span> &#123;</div><div class="line">    <span class="comment">// Module dependency</span></div><div class="line">    <span class="keyword">compile</span> <span class="keyword">project</span>(<span class="string">':passportSDKLib'</span>)</div><div class="line">    <span class="keyword">compile</span> (<span class="keyword">project</span>(<span class="string">':Speech'</span>))&#123;</div><div class="line">	    <span class="comment">//解决Gson重复依赖问题，与passport-1.4.2.jar有冲突</span></div><div class="line">        <span class="keyword">exclude</span> <span class="keyword">group</span>: <span class="string">'com.google.code.gson'</span>, module: <span class="string">'gson'</span>       </div><div class="line">    &#125;</div><div class="line">    <span class="keyword">compile</span> <span class="keyword">project</span>(<span class="string">':Skin'</span>)</div><div class="line">    <span class="keyword">compile</span> <span class="keyword">fileTree</span>(<span class="keyword">include</span>: <span class="string">'*.jar'</span>, dir: <span class="string">'src/main/libs'</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>唉，世界终于清静了</p>
<hr>
<h3 id="【参考资料】："><a href="#【参考资料】：" class="headerlink" title="【参考资料】："></a>【参考资料】：</h3><p>1、<a href="http://blog.csdn.net/cx1229/article/details/52786168" target="_blank" rel="external"><strong>AndroidStudio中如何解决重复依赖导致的app:transformClassesWithJarMergingForDebug</strong></a><br>2、<a href="http://blog.csdn.net/yisizhu/article/details/49952841" target="_blank" rel="external">  <strong>AndroidStudio的Gradle添加重复依赖的问题</strong> </a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;&lt;strong&gt;问题&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;项目中有个Module需要解析json所以选用了依赖Gson，但是编译时报错如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;Error:Execution failed for task &amp;apos;:app:transformClassesWithJarMergingForAutoioDebug&amp;apos;.&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;gt; com.android.build.api.transform.TransformException: java.util.zip.ZipException: duplicate entry: com/google/gson/annotations/Expose.class&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;分析&quot;&gt;&lt;a href=&quot;#分析&quot; class=&quot;headerlink&quot; title=&quot;分析&quot;&gt;&lt;/a&gt;&lt;strong&gt;分析&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;看到错误中的这个&lt;strong&gt;duplicate&lt;/strong&gt;，第一反应和平常一样，难道是得先清理一下Clean project ? 反复试了几次都不行，上网查才发现是重复依赖Gson库的问题，导致项目中有了两个重复的&lt;code&gt;Expose.class&lt;/code&gt; 类。&lt;/p&gt;
&lt;p&gt;使用快捷键（Shift + Ctrl + T）查看项目中的&lt;code&gt;Expose.class&lt;/code&gt; 类，发现是和passport-1.4.2.jar这个本地jar包冲突了，它也依赖了gson库所以导致了重复依赖。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20170223114733531?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDk4Mzg4MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Gradle" scheme="http://github.com/categories/Gradle/"/>
    
    
      <category term="Gradle" scheme="http://github.com/tags/Gradle/"/>
    
  </entry>
  
  <entry>
    <title>【Android】内存泄漏分析心得</title>
    <link href="http://github.com/2017/02/13/%E3%80%90Android%E3%80%91%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%88%86%E6%9E%90%E5%BF%83%E5%BE%97/"/>
    <id>http://github.com/2017/02/13/【Android】内存泄漏分析心得/</id>
    <published>2017-02-13T08:03:00.000Z</published>
    <updated>2017-02-15T05:07:07.401Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>本文来源：<a href="http://mp.weixin.qq.com/s?__biz=MzI1MTA1MzM2Nw==&amp;mid=2649796884&amp;idx=1&amp;sn=92b4e344060362128e4a86d6132c3736&amp;chksm=f1fcc54cc68b4c5add08371265320163381ea81333daea5664b94e9a12246a34cfaa31e6f0b3&amp;mpshare=1&amp;scene=1&amp;srcid=0213Ssp5geOThmtF6tg9Bz7U#rd" target="_blank" rel="external">QQ空间终端开发团队公众号</a></p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>对于C++来说，内存泄漏就是new出来的对象没有delete，俗称野指针；<br>对于Java来说，就是new出来的Object 放在Heap上无法被GC回收；</p>
<p><img src="http://img.blog.csdn.net/20170213160148023?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDk4Mzg4MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>本文通过QQ和Qzone中内存泄漏实例来讲android中内存泄漏分析解法和编写代码应注意的事项。</p>
<h2 id="Java-中的内存分配"><a href="#Java-中的内存分配" class="headerlink" title="Java 中的内存分配"></a><strong>Java 中的内存分配</strong></h2><ul>
<li><p><strong>静态储存区</strong>：编译时就分配好，在程序整个运行期间都存在。它主要存放静态数据和常量；</p>
</li>
<li><p><strong>栈区</strong>：当方法执行时，会在栈区内存中创建方法体内部的局部变量，方法结束后自动释放内存；</p>
</li>
<li><p><strong>堆区</strong>：通常存放 new 出来的对象。由 Java 垃圾回收器回收。</p>
</li>
</ul>
<a id="more"></a>
<h2 id="四种引用类型的介绍"><a href="#四种引用类型的介绍" class="headerlink" title="四种引用类型的介绍"></a><strong>四种引用类型的介绍</strong></h2><ul>
<li><p><strong>强引用</strong>(StrongReference)：JVM 宁可抛出 OOM ，也不会让 GC 回收具有强引用的对象；</p>
</li>
<li><p><strong>软引用</strong>(SoftReference)：只有在内存空间不足时，才会被回的对象；</p>
</li>
<li><p><strong>弱引用</strong>(WeakReference)：在 GC 时，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存；</p>
</li>
<li><p><strong>虚引用</strong>(PhantomReference)：任何时候都可以被GC回收，当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否存在该对象的虚引用，来了解这个对象是否将要被回收。可以用来作为GC回收Object的标志。</p>
</li>
</ul>
<p><strong>我们常说的内存泄漏是指new出来的Object无法被GC回收，即为强引用：</strong></p>
<p><img src="http://img.blog.csdn.net/20170213160412727?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDk4Mzg4MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>内存泄漏发生时的主要表现为内存抖动，可用内存慢慢变少：</p>
<p><img src="http://img.blog.csdn.net/20170213160508309?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDk4Mzg4MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<h2 id="Andriod-中分析内存泄漏的工具MAT"><a href="#Andriod-中分析内存泄漏的工具MAT" class="headerlink" title="Andriod 中分析内存泄漏的工具MAT"></a><strong>Andriod 中分析内存泄漏的工具MAT</strong></h2><p>MAT（Memory Analyzer Tools）是一个 Eclipse 插件，它是一个快速、功能丰富的JAVA heap分析工具，它可以帮助我们查找内存泄漏和减少内存消耗。</p>
<p>MAT 插件的下载地址：</p>
<p><a href="http://www.eclipse.org/mat/" target="_blank" rel="external">Eclipse Memory Analyzer Open Source Project</a></p>
<h2 id="QQ-和-Qzone内存泄漏如何监控"><a href="#QQ-和-Qzone内存泄漏如何监控" class="headerlink" title="QQ 和 Qzone内存泄漏如何监控"></a><strong>QQ 和 Qzone内存泄漏如何监控</strong></h2><p><img src="http://img.blog.csdn.net/20170213160729938?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDk4Mzg4MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>QQ和Qzone 的内存泄漏采用SNGAPM解决方案，SNGAPM是一个性能监控、分析的统一解决方案，它从终端收集性能信息，上报到一个后台，后台将监控类信息聚合展示为图表，将分析类信息进行分析并提单，通知开发者；</p>
<ol>
<li><p>SNGAPM由App（MagnifierApp）和 web server（MagnifierServer）两部分组成；</p>
</li>
<li><p>MagnifierApp在自动内存泄漏检测中是一个衔接检测组件（LeakInspector）和自动化云分析（MagnifierCloud）的中间性平台，它从LeakInspector的内存dump自动化上传MagnifierServer；</p>
</li>
<li><p>MagnifierServer后台会定时提交分析任务到MagnifierCloud；</p>
</li>
<li><p>MagnifierCloud分析结束之后会更新数据到magnifier web上，同时以bug单形式通知开发者。</p>
</li>
</ol>
<h2 id="常见的内存泄漏案例"><a href="#常见的内存泄漏案例" class="headerlink" title="常见的内存泄漏案例"></a><strong>常见的内存泄漏案例</strong></h2><h3 id="case-1-单例造成的内存泄露"><a href="#case-1-单例造成的内存泄露" class="headerlink" title="case 1. 单例造成的内存泄露"></a><strong>case 1. 单例造成的内存泄露</strong></h3><p>单例的静态特性导致其生命周期同应用一样长。</p>
<p>解决方案：</p>
<blockquote>
<p>1、将该属性的引用方式改为弱引用;<br>2、如果传入Context，使用ApplicationContext;</p>
</blockquote>
<p>泄漏代码片段 example：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> ScrollHelper mInstance;    </div><div class="line"><span class="function"><span class="keyword">private</span> <span class="title">ScrollHelper</span><span class="params">()</span> </span>&#123;</div><div class="line">&#125;    </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScrollHelper <span class="title">getInstance</span><span class="params">()</span> </span>&#123;        </div><div class="line">    <span class="keyword">if</span> (mInstance == <span class="keyword">null</span>) &#123;           </div><div class="line">       <span class="keyword">synchronized</span> (ScrollHelper.class) &#123;                </div><div class="line">            <span class="keyword">if</span> (mInstance == <span class="keyword">null</span>) &#123;</div><div class="line">                mInstance = <span class="keyword">new</span> ScrollHelper();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;        </div><div class="line">                </div><div class="line">    <span class="keyword">return</span> mInstance;</div><div class="line">&#125;    </div><div class="line"><span class="comment">/**</span></div><div class="line"> * 被点击的view</div><div class="line"> */</div><div class="line"><span class="keyword">private</span> View mScrolledView = <span class="keyword">null</span>;    </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setScrolledView</span><span class="params">(View scrolledView)</span> </span>&#123;</div><div class="line">    mScrolledView = scrolledView;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Solution：使用WeakReference</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> ScrollHelper mInstance;    </div><div class="line"><span class="function"><span class="keyword">private</span> <span class="title">ScrollHelper</span><span class="params">()</span> </span>&#123;</div><div class="line">&#125;    </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScrollHelper <span class="title">getInstance</span><span class="params">()</span> </span>&#123;        </div><div class="line">    <span class="keyword">if</span> (mInstance == <span class="keyword">null</span>) &#123;            </div><div class="line">        <span class="keyword">synchronized</span> (ScrollHelper.class) &#123;                </div><div class="line">            <span class="keyword">if</span> (mInstance == <span class="keyword">null</span>) &#123;</div><div class="line">                mInstance = <span class="keyword">new</span> ScrollHelper();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;        </div><div class="line">        </div><div class="line">    <span class="keyword">return</span> mInstance;</div><div class="line">&#125;    </div><div class="line"><span class="comment">/**</span></div><div class="line"> * 被点击的view</div><div class="line"> */</div><div class="line"><span class="keyword">private</span> WeakReference&lt;View&gt; mScrolledViewWeakRef = <span class="keyword">null</span>;    </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setScrolledView</span><span class="params">(View scrolledView)</span> </span>&#123;</div><div class="line">    mScrolledViewWeakRef = <span class="keyword">new</span> WeakReference&lt;View&gt;(scrolledView);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="case-2-InnerClass匿名内部类"><a href="#case-2-InnerClass匿名内部类" class="headerlink" title="case 2. InnerClass匿名内部类"></a><strong>case 2. InnerClass匿名内部类</strong></h3><p>在Java中，非静态内部类 和 匿名类 都会潜在的引用它们所属的外部类，但是，静态内部类却不会。如果这个非静态内部类实例做了一些耗时的操作，就会造成外围对象不会被回收，从而导致内存泄漏。</p>
<p>解决方案：</p>
<blockquote>
<p>1、将内部类变成静态内部类;<br>2、如果有强引用Activity中的属性，则将该属性的引用方式改为弱引用;<br>3、在业务允许的情况下，当Activity执行onDestory时，结束这些耗时任务;</p>
</blockquote>
<p>example：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeakAct</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;  </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;    </div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.aty_leak);</div><div class="line">        test();</div><div class="line">    &#125; </div><div class="line">    <span class="comment">//这儿发生泄漏    </span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;    </div><div class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;      </div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;        </div><div class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;          </div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        Thread.sleep(<span class="number">1000</span>);</div><div class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                        e.printStackTrace();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;).start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Solution：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeakAct</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;  </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;    </div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.aty_leak);</div><div class="line">        test();</div><div class="line">    &#125;  </div><div class="line">    <span class="comment">//加上static，变成静态匿名内部类</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;    </div><div class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;     </div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;        </div><div class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;          </div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        Thread.sleep(<span class="number">1000</span>);</div><div class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                        e.printStackTrace();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;).start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="case-3-Activity-Context-的不正确使用"><a href="#case-3-Activity-Context-的不正确使用" class="headerlink" title="case 3. Activity Context 的不正确使用"></a><strong>case 3. Activity Context 的不正确使用</strong></h3><p>在Android应用程序中通常可以使用两种Context对象：Activity和Application。当类或方法需要Context对象的时候常见的做法是使用第一个作为Context参数。这样就意味着View对象对整个Activity保持引用，因此也就保持对Activty的所有的引用。</p>
<p>假设一个场景，当应用程序有个比较大的Bitmap类型的图片，每次旋转是都重新加载图片所用的时间较多。为了提高屏幕旋转是Activity的创建速度，最简单的方法时将这个Bitmap对象使用Static修饰。 当一个Drawable绑定在View上，实际上这个View对象就会成为这份Drawable的一个Callback成员变量。而静态变量的生命周期要长于Activity。导致了当旋转屏幕时，Activity无法被回收，而造成内存泄露。</p>
<p>解决方案：</p>
<blockquote>
<p> 1、使用ApplicationContext代替ActivityContext，因为ApplicationContext会随着应用程序的存在而存在，而不依赖于activity的生命周期；</p>
<p> 2、对Context的引用不要超过它本身的生命周期，慎重的对Context使用“static”关键字。Context里如果有线程，一定要在onDestroy()里及时停掉。</p>
</blockquote>
<p>example：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> Drawable sBackground;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle state)</span> </span>&#123;  </div><div class="line">    <span class="keyword">super</span>.onCreate(state);</div><div class="line">    TextView label = <span class="keyword">new</span> TextView(<span class="keyword">this</span>);</div><div class="line">    label.setText(<span class="string">"Leaks are bad"</span>);  </div><div class="line">    <span class="keyword">if</span> (sBackground == <span class="keyword">null</span>) &#123;</div><div class="line">        sBackground = getDrawable(R.drawable.large_bitmap);</div><div class="line">    &#125;</div><div class="line">    label.setBackgroundDrawable(sBackground);</div><div class="line">    setContentView(label);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Solution：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> Drawable sBackground;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle state)</span> </span>&#123;  </div><div class="line">    <span class="keyword">super</span>.onCreate(state);</div><div class="line">    TextView label = <span class="keyword">new</span> TextView(<span class="keyword">this</span>);</div><div class="line">    label.setText(<span class="string">"Leaks are bad"</span>);  </div><div class="line">    <span class="keyword">if</span> (sBackground == <span class="keyword">null</span>) &#123;</div><div class="line">        sBackground = getApplicationContext().getDrawable(R.drawable.large_bitmap);</div><div class="line">    &#125;</div><div class="line">    label.setBackgroundDrawable(sBackground);</div><div class="line">    setContentView(label);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="case-4-Handler引起的内存泄漏"><a href="#case-4-Handler引起的内存泄漏" class="headerlink" title="case 4. Handler引起的内存泄漏"></a><strong>case 4. Handler引起的内存泄漏</strong></h3><p>当Handler中有延迟的的任务或是等待执行的任务队列过长，由于消息持有对Handler的引用，而Handler又持有对其外部类的潜在引用，这条引用关系会一直保持到消息得到处理，而导致了Activity无法被垃圾回收器回收，而导致了内存泄露。</p>
<p>解决方案：</p>
<blockquote>
<p>1、可以把Handler类放在单独的类文件中，或者使用静态内部类便可以避免泄露;<br>2、如果想在Handler内部去调用所在的Activity,那么可以在handler内部使用弱引用的方式去指向所在Activity.使用Static + WeakReference的方式来达到断开Handler与Activity之间存在引用关系的目的。</p>
</blockquote>
<p>Solution</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doOnDestroy</span><span class="params">()</span> </span>&#123;        </div><div class="line">    <span class="keyword">super</span>.doOnDestroy();        </div><div class="line">    <span class="keyword">if</span> (mHandler != <span class="keyword">null</span>) &#123;</div><div class="line">        mHandler.removeCallbacksAndMessages(<span class="keyword">null</span>);</div><div class="line">    &#125;</div><div class="line">    mHandler = <span class="keyword">null</span>;</div><div class="line">    mRenderCallback = <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="case-5-注册监听器的泄漏"><a href="#case-5-注册监听器的泄漏" class="headerlink" title="case 5. 注册监听器的泄漏"></a><strong>case 5. 注册监听器的泄漏</strong></h3><p>系统服务可以通过Context.getSystemService 获取，它们负责执行某些后台任务，或者为硬件访问提供接口。如果Context 对象想要在服务内部的事件发生时被通知，那就需要把自己注册到服务的监听器中。然而，这会让服务持有Activity 的引用，如果在Activity onDestory时没有释放掉引用就会内存泄漏。</p>
<p>解决方案：</p>
<blockquote>
<ol>
<li><p>使用ApplicationContext代替ActivityContext;</p>
</li>
<li><p>在Activity执行onDestory时，调用反注册;</p>
</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mSensorManager = (SensorManager) <span class="keyword">this</span>.getSystemService(Context.SENSOR_SERVICE);</div></pre></td></tr></table></figure>
<p>Solution：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mSensorManager = (SensorManager) getApplicationContext().getSystemService(Context.SENSOR_SERVICE);</div></pre></td></tr></table></figure>
<p>下面是容易造成内存泄漏的系统服务：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">InputMethodManager imm = (InputMethodManager) context.getApplicationContext().getSystemService(Context.INPUT_METHOD_SERVICE);</div></pre></td></tr></table></figure>
<p>Solution</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDetachedFromWindow</span><span class="params">()</span> </span>&#123;        </div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.mActionShell != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">this</span>.mActionShell.setOnClickListener((OnAreaClickListener)<span class="keyword">null</span>);</div><div class="line">    &#125;        </div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.mButtonShell != <span class="keyword">null</span>) &#123; </div><div class="line">        <span class="keyword">this</span>.mButtonShell.setOnClickListener((OnAreaClickListener)<span class="keyword">null</span>);</div><div class="line">    &#125;        </div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.mCountShell != <span class="keyword">this</span>.mCountShell) &#123;</div><div class="line">        <span class="keyword">this</span>.mCountShell.setOnClickListener((OnAreaClickListener)<span class="keyword">null</span>);</div><div class="line">    &#125;        </div><div class="line">    <span class="keyword">super</span>.onDetachedFromWindow();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="case-6-Cursor，Stream没有close，View没有recyle"><a href="#case-6-Cursor，Stream没有close，View没有recyle" class="headerlink" title="case 6. Cursor，Stream没有close，View没有recyle"></a><strong>case 6. Cursor，Stream没有close，View没有recyle</strong></h3><p>资源性对象比如(Cursor，File文件等)往往都用了一些缓冲，我们在不使用的时候，应该及时关闭它们，以便它们的缓冲及时回收内存。它们的缓冲不仅存在于 java虚拟机内，还存在于java虚拟机外。如果我们仅仅是把它的引用设置为null,而不关闭它们，往往会造成内存泄漏。因为有些资源性对象，比如SQLiteCursor(在析构函数finalize(),如果我们没有关闭它，它自己会调close()关闭)，如果我们没有关闭它，系统在回收它时也会关闭它，但是这样的效率太低了。因此对于资源性对象在不使用的时候，应该调用它的close()函数，将其关闭掉，然后才置为null. 在我们的程序退出时一定要确保我们的资源性对象已经关闭。</p>
<p>Solution：</p>
<blockquote>
<p>调用onRecycled()</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onRecycled</span><span class="params">()</span> </span>&#123;</div><div class="line">    reset();</div><div class="line">    mSinglePicArea.onRecycled();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在View中调用reset()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (mHasRecyled) &#123;            </div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">...</div><div class="line">    SubAreaShell.recycle(mActionBtnShell);</div><div class="line">    mActionBtnShell = <span class="keyword">null</span>;</div><div class="line">...</div><div class="line">    mIsDoingAvatartRedPocketAnim = <span class="keyword">false</span>;        </div><div class="line">    <span class="keyword">if</span> (mAvatarArea != <span class="keyword">null</span>) &#123;</div><div class="line">            mAvatarArea.reset();</div><div class="line">    &#125;        </div><div class="line">    <span class="keyword">if</span> (mNickNameArea != <span class="keyword">null</span>) &#123;</div><div class="line">        mNickNameArea.reset();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="case-7-集合中对象没清理造成的内存泄漏"><a href="#case-7-集合中对象没清理造成的内存泄漏" class="headerlink" title="case 7. 集合中对象没清理造成的内存泄漏"></a><strong>case 7. 集合中对象没清理造成的内存泄漏</strong></h3><p>我们通常把一些对象的引用加入到了集合容器（比如ArrayList）中，当我们不需要该对象时，并没有把它的引用从集合中清理掉，这样这个集合就会越来越大。如果这个集合是static的话，那情况就更严重了。<br>所以要在退出程序之前，将集合里的东西clear，然后置为null，再退出程序。</p>
<p>解决方案：</p>
<blockquote>
<p>在Activity退出之前，将集合里的东西clear，然后置为null，再退出程序。</p>
</blockquote>
<p>Solution</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> List&lt;EmotionPanelInfo&gt; data;    </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestory</span><span class="params">()</span> </span>&#123;        </div><div class="line">    <span class="keyword">if</span> (data != <span class="keyword">null</span>) &#123;</div><div class="line">        data.clear();</div><div class="line">        data = <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="case-8-WebView造成的泄露"><a href="#case-8-WebView造成的泄露" class="headerlink" title="case 8. WebView造成的泄露"></a><strong>case 8. WebView造成的泄露</strong></h3><p>当我们不要使用WebView对象时，应该调用它的destory()函数来销毁它，并释放其占用的内存，否则其占用的内存长期也不能被回收，从而造成内存泄露。</p>
<p>解决方案：</p>
<blockquote>
<p>为webView开启另外一个进程，通过AIDL与主线程进行通信，WebView所在的进程可以根据业务的需要选择合适的时机进行销毁，从而达到内存的完整释放。</p>
</blockquote>
<h3 id="case-9-构造Adapter时，没有使用缓存的ConvertView"><a href="#case-9-构造Adapter时，没有使用缓存的ConvertView" class="headerlink" title="case 9. 构造Adapter时，没有使用缓存的ConvertView"></a><strong>case 9. 构造Adapter时，没有使用缓存的ConvertView</strong></h3><p>初始时ListView会从Adapter中根据当前的屏幕布局实例化一定数量的View对象，同时ListView会将这些View对象 缓存起来。</p>
<p>当向上滚动ListView时，原先位于最上面的List Item的View对象会被回收，然后被用来构造新出现的最下面的List Item。</p>
<p>这个构造过程就是由getView()方法完成的，getView()的第二个形参View ConvertView就是被缓存起来的List Item的View对象(初始化时缓存中没有View对象则ConvertView是null)。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文来源：&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1MTA1MzM2Nw==&amp;amp;mid=2649796884&amp;amp;idx=1&amp;amp;sn=92b4e344060362128e4a86d6132c3736&amp;amp;chksm=f1fcc54cc68b4c5add08371265320163381ea81333daea5664b94e9a12246a34cfaa31e6f0b3&amp;amp;mpshare=1&amp;amp;scene=1&amp;amp;srcid=0213Ssp5geOThmtF6tg9Bz7U#rd&quot;&gt;QQ空间终端开发团队公众号&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;对于C++来说，内存泄漏就是new出来的对象没有delete，俗称野指针；&lt;br&gt;对于Java来说，就是new出来的Object 放在Heap上无法被GC回收；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20170213160148023?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDk4Mzg4MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;本文通过QQ和Qzone中内存泄漏实例来讲android中内存泄漏分析解法和编写代码应注意的事项。&lt;/p&gt;
&lt;h2 id=&quot;Java-中的内存分配&quot;&gt;&lt;a href=&quot;#Java-中的内存分配&quot; class=&quot;headerlink&quot; title=&quot;Java 中的内存分配&quot;&gt;&lt;/a&gt;&lt;strong&gt;Java 中的内存分配&lt;/strong&gt;&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;静态储存区&lt;/strong&gt;：编译时就分配好，在程序整个运行期间都存在。它主要存放静态数据和常量；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;栈区&lt;/strong&gt;：当方法执行时，会在栈区内存中创建方法体内部的局部变量，方法结束后自动释放内存；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;堆区&lt;/strong&gt;：通常存放 new 出来的对象。由 Java 垃圾回收器回收。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Android" scheme="http://github.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://github.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>【算法】反转单链表，两两反转</title>
    <link href="http://github.com/2017/01/31/%E3%80%90%E7%AE%97%E6%B3%95%E3%80%91%E5%8D%95%E9%93%BE%E8%A1%A8%E5%8F%8D%E8%BD%AC%EF%BC%8C%E4%B8%A4%E4%B8%A4%E5%8F%8D%E8%BD%AC/"/>
    <id>http://github.com/2017/01/31/【算法】单链表反转，两两反转/</id>
    <published>2017-01-31T09:20:55.000Z</published>
    <updated>2017-08-02T05:22:32.593Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题一、反转单链表"><a href="#问题一、反转单链表" class="headerlink" title="问题一、反转单链表"></a>问题一、反转单链表</h2><p>题目：定义一个函数，输入一个链表的头结点，反转该链表并输出反转后链表的头结点。</p>
<p><img src="/gallery/reverse-linklist.jpg" alt=""></p>
<p>链表结点定义如下，这里使用的是Java描述：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> val;</div><div class="line">    ListNode next;</div><div class="line">    ListNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>如何把一个单链表进行反转？</p>
<ul>
<li>方法1：将单链表储存为数组，然后按照数组的索引逆序进行反转。</li>
<li>方法2：用头插法新建链表。我们知道创建链表的两种方式：<strong>头插法</strong>和<strong>尾插法</strong>，头结点插入法形成的链表是和输入顺序相反的，尾节点插入法形成的链表是和输入顺序相同的，所以其中一种方法是，遍历原链表，然后用原链表的输出元素顺序用头结点插入法新建链表，这样新建的链表就是反转后的链表。</li>
<li>方法3：就地反转链表。使用3个指针遍历单链表，逐个链接点进行反转。</li>
</ul>
<h4 id="1、借助数组逆序反转"><a href="#1、借助数组逆序反转" class="headerlink" title="1、借助数组逆序反转"></a>1、借助数组逆序反转</h4><p>由于题目并没有要求必须原地反转，因此可以借助外部空间实现。这里可以将单链表储存为数组，然后按照数组的索引逆序进行反转。但是，<strong>此方式比较浪费空间，而且需要两次遍历，效率不占优势</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 使用数组拷贝的方式反转单链表</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">reverseList1</span><span class="params">(ListNode head)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    <span class="comment">//转移到数组存储(这里用ArrayList方便些)</span></div><div class="line">    List&lt;ListNode&gt; nodeList = <span class="keyword">new</span> ArrayList&lt;ListNode&gt;();</div><div class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</div><div class="line">        nodeList.add(head);</div><div class="line">        head = head.next;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> startIndex = nodeList.size() - <span class="number">1</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = startIndex; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">        ListNode node = nodeList.get(i);</div><div class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</div><div class="line">            node.next = <span class="keyword">null</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            node.next = nodeList.get(i - <span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 现在头结点是原来的尾节点</span></div><div class="line">    head = nodeList.get(startIndex);</div><div class="line">    <span class="keyword">return</span> head;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="2、头插法新建链表来反转"><a href="#2、头插法新建链表来反转" class="headerlink" title="2、头插法新建链表来反转"></a>2、头插法新建链表来反转</h4><p>这个方法和第一个借助数组一样，需要额外一倍的空间来存储生成的新链表</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 头插法建立新链表，达到反转目的</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">reverseList2</span><span class="params">(ListNode head)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    ListNode previous = <span class="keyword">null</span>;   <span class="comment">//记录上个节点</span></div><div class="line">    ListNode newHead = <span class="keyword">null</span>;    <span class="comment">//头插法的新头节点</span></div><div class="line"></div><div class="line">    <span class="keyword">while</span>(head != <span class="keyword">null</span>)&#123;</div><div class="line">        newHead = <span class="keyword">new</span> ListNode(head.val);   <span class="comment">//新建头结点</span></div><div class="line">        newHead.next = previous;</div><div class="line"></div><div class="line">        previous = newHead;</div><div class="line">        head = head.next;   <span class="comment">//下一个节点</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> newHead;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="3、三个指针就地反转"><a href="#3、三个指针就地反转" class="headerlink" title="3、三个指针就地反转"></a>3、三个指针就地反转</h4><p>使用三个指针指向：当前节点A，下个节点B，以及下下个节点C。</p>
<p>遍历时，如下首先记录下下个节点C，然后节点B的指针断开并指向A。然后移动进入下一组。</p>
<p>A -&gt; B -&gt; C -&gt;D -&gt; E</p>
<p><strong>A &lt;- B</strong>        <strong>C</strong> -&gt;D -&gt; E</p>
<p>整个过程只需遍历链表一次，效率提高不少，且需要的外部空间也较第一种方法要少很多，实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 使用三个指针原地反转单链表</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    ListNode a = head;      <span class="comment">//当前节点A</span></div><div class="line">    ListNode b = head.next; <span class="comment">//下个节点B</span></div><div class="line">    ListNode temp;          <span class="comment">//下下个节点C</span></div><div class="line"></div><div class="line">    <span class="comment">//头结点的指针先清空</span></div><div class="line">    head.next = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    <span class="comment">//有可能链表只有一个节点，所以需要看b是否为null</span></div><div class="line">    <span class="keyword">while</span>(b != <span class="keyword">null</span>)&#123;</div><div class="line">        temp = b.next;  <span class="comment">// 记录C节点</span></div><div class="line">        b.next = a;     <span class="comment">// a-&gt;b 反向</span></div><div class="line"></div><div class="line">        <span class="keyword">if</span>(temp == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        a = b;      <span class="comment">//移动到下一个节点</span></div><div class="line">        b = temp;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> b == <span class="keyword">null</span> ? a : b;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><p>测试代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        ListNode a1 = <span class="keyword">new</span> ListNode(<span class="number">5</span>);</div><div class="line">        ListNode a2 = <span class="keyword">new</span> ListNode(<span class="number">4</span>);</div><div class="line">        ListNode a3 = <span class="keyword">new</span> ListNode(<span class="number">30</span>);</div><div class="line">        ListNode a4 = <span class="keyword">new</span> ListNode(<span class="number">78</span>);</div><div class="line">        ListNode a5 = <span class="keyword">new</span> ListNode(<span class="number">99</span>);</div><div class="line"></div><div class="line">        a1.next = a2;</div><div class="line">        a2.next = a3;</div><div class="line">        a3.next = a4;</div><div class="line">        a4.next = a5;</div><div class="line"></div><div class="line">        <span class="comment">//反转单链表</span></div><div class="line">        ListNode node = reverseList(a1);</div><div class="line"></div><div class="line">        <span class="comment">//打印输出结果</span></div><div class="line">        <span class="keyword">while</span> (node != <span class="keyword">null</span>)&#123;</div><div class="line">            System.out.print(node.val);</div><div class="line">            node = node.next;</div><div class="line">            System.out.print(node != <span class="keyword">null</span> ? <span class="string">"-&gt;"</span> : <span class="string">""</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="问题二、单链表两两反转"><a href="#问题二、单链表两两反转" class="headerlink" title="问题二、单链表两两反转"></a>问题二、单链表两两反转</h2><p>一个链表：<code>a-&gt;b-&gt;c-&gt;d-&gt;e</code><br>每两个元素进行反转：<code>b-&gt;a-&gt;d-&gt;c-&gt;e</code><br>输入：链表头指针<br>输出：反转后的链表头指针<br>要求：<strong>不新建节点</strong></p>
<h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><p>仿照前面的单链表反转，我们最少需要三个指针： current，next， nextNext。<br>　　<br>分析：我们需要两个“指针”指着当前要反转的两个值current和next。两两反转后，我们还需要记录下一个的值，即反转A和B后， 需要记录 C 值，我们才能够不断向下走，直到到达链表末端。所以，需要另一个指向下一个值的“指针”，即nextNext。反转以后，A的下一个是C， <strong>但是，实际上，A的下一个应该是D</strong>，所以，每次反转时，我们需要更新前一个值的下一个值，也就是说把 A -&gt; C 改成 A -&gt; D，所以需要prev指针。所以，要完成这个操作，我们总共需要4个“指针”。具体看代码：<br>　　<br>所以最终我们一共需要分析四个指针： prev，current，next， nextNext。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 单链表两两反转</div><div class="line"> *</div><div class="line"> *      已知一个链表：a-&gt;b-&gt;c-&gt;d-&gt;e</div><div class="line"> * 每两个元素进行反转：b-&gt;a-&gt;d-&gt;c-&gt;e</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">reversePairedList</span><span class="params">(ListNode head)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    ListNode a = head;          <span class="comment">//当前节点A</span></div><div class="line">    ListNode b = head.next;     <span class="comment">//下个节点B</span></div><div class="line">    ListNode temp;              <span class="comment">//下下个节点C</span></div><div class="line">    ListNode previous = <span class="keyword">null</span>;   <span class="comment">//上一组的尾指针，在下一组反转后需要改变</span></div><div class="line">    ListNode newHead = b == <span class="keyword">null</span> ? a : b;</div><div class="line"></div><div class="line">    <span class="keyword">while</span>(b != <span class="keyword">null</span>)&#123;</div><div class="line">        temp = b.next;  <span class="comment">// 记录C节点</span></div><div class="line">        b.next = a;     <span class="comment">// a-&gt;b 反向</span></div><div class="line">        a.next = temp;</div><div class="line">        <span class="keyword">if</span>(previous != <span class="keyword">null</span>)&#123;</div><div class="line">            previous.next = b;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span>(temp == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        previous = a;</div><div class="line">        a = temp;       <span class="comment">//移动到下一组</span></div><div class="line">        b = temp.next;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> newHead;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://blog.csdn.net/feliciafay/article/details/6841115" target="_blank" rel="external">看图理解单链表的反转</a></li>
<li><a href="http://blog.csdn.net/lufeng20/article/details/7959973" target="_blank" rel="external">算法学习之数据结构之单链表反转，两两反转</a></li>
<li><a href="http://c.biancheng.net/cpp/html/2671.html" target="_blank" rel="external">单链表的建立(C语言)：头插法和尾插法建立单链表</a></li>
<li><a href="https://hwdlei.github.io/%E7%AC%94%E8%AF%95%E9%9D%A2%E8%AF%95/2016/10/20/list-revert/" target="_blank" rel="external">蚂蚁金服在线笔试题 - 链表两两反转</a></li>
<li><a href="http://blog.csdn.net/jxh_123/article/details/38369373" target="_blank" rel="external">算法题：反转单链表</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题一、反转单链表&quot;&gt;&lt;a href=&quot;#问题一、反转单链表&quot; class=&quot;headerlink&quot; title=&quot;问题一、反转单链表&quot;&gt;&lt;/a&gt;问题一、反转单链表&lt;/h2&gt;&lt;p&gt;题目：定义一个函数，输入一个链表的头结点，反转该链表并输出反转后链表的头结点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/gallery/reverse-linklist.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;链表结点定义如下，这里使用的是Java描述：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ListNode&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; val;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    ListNode next;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    ListNode(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; x) &amp;#123; val = x; &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://github.com/categories/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://github.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>【Android】AlertDialog中的EditText不能弹出软键盘的问题</title>
    <link href="http://github.com/2017/01/20/%E3%80%90Android%E3%80%91AlertDialog%E4%B8%AD%E7%9A%84EditText%E4%B8%8D%E8%83%BD%E5%BC%B9%E5%87%BA%E8%BD%AF%E9%94%AE%E7%9B%98%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://github.com/2017/01/20/【Android】AlertDialog中的EditText不能弹出软键盘的问题/</id>
    <published>2017-01-20T03:03:00.000Z</published>
    <updated>2017-01-20T03:13:42.212Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a><strong>摘要</strong></h2><p>AlertDialog中加入EditText但是不弹出软键盘等问题网上有很多不管用的解决方案，有的方案是<strong>强制弹出软键盘</strong>，然而即使弹出来，也是显示在AlertDialog的后面，被Dialog遮挡。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a><strong>解决方案</strong></h2><p>Dialog的官方文档：<a href="http://developer.android.com/reference/android/app/Dialog.html" target="_blank" rel="external">http://developer.android.com/reference/android/app/Dialog.html</a> ，其中有一段：</p>
<blockquote>
<p><strong>Note:</strong> Activities provide a facility to manage the creation, saving and restoring of dialogs. See <a href="https://developer.android.com/reference/android/app/Activity.html#onCreateDialog%28int%29" target="_blank" rel="external">onCreateDialog(int)</a>, <a href="https://developer.android.com/reference/android/app/Activity.html#onPrepareDialog%28int,%20android.app.Dialog%29" target="_blank" rel="external">onPrepareDialog(int, Dialog)</a>, <a href="https://developer.android.com/reference/android/app/Activity.html#showDialog%28int%29" target="_blank" rel="external">showDialog(int)</a>, and <a href="https://developer.android.com/reference/android/app/Activity.html#dismissDialog%28int%29" target="_blank" rel="external">dismissDialog(int)</a>. If these methods are used, <a href="https://developer.android.com/reference/android/app/Dialog.html#getOwnerActivity%28%29" target="_blank" rel="external">getOwnerActivity()</a> will return the Activity that managed this dialog.</p>
</blockquote>
<a id="more"></a>
<blockquote>
<p>Often you will want to have a Dialog display on top of the current input method, because there is no reason for it to accept text. You can do this by setting the <a href="https://developer.android.com/reference/android/view/WindowManager.LayoutParams.html#FLAG_ALT_FOCUSABLE_IM" target="_blank" rel="external">WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM</a> window flag (assuming your Dialog takes input focus, as it the default) with the following code:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">getWindow().setFlags(WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM,</div><div class="line">         WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM);</div></pre></td></tr></table></figure></p>
</blockquote>
<p>这段话的大概意思是说，WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM  这个参数会让Dialog遮挡住软键盘，显示在软键盘的前面。</p>
<p>这是默认情况下隐藏软键盘的方法，要重新显示软键盘，要执行下面这段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alertDialog.getWindow().clearFlags(WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM);</div></pre></td></tr></table></figure>
<p>我是把它写在了setOnFocusChangeListener里，起效了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">editText.setOnFocusChangeListener(<span class="keyword">new</span> View.OnFocusChangeListener() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFocusChange</span><span class="params">(View view, <span class="keyword">boolean</span> focused)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (focused) &#123;</div><div class="line">	         <span class="comment">//dialog弹出软键盘</span></div><div class="line">	         alertDialog.getWindow()</div><div class="line">			       .clearFlags(WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM);   </div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>AlertDialog.setView()则不会出现以上问题。</p>
<h3 id="另外"><a href="#另外" class="headerlink" title="另外"></a><strong>另外</strong></h3><p>为了防止弹出输入法时把后面的背景挤变形，可以在Manifest里的相应Activity添加：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">android:windowSoftInputMode="adjustPan|stateHidden"</div></pre></td></tr></table></figure>
<p>像这样：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">activity</span></span></div><div class="line">    <span class="attr">android:name</span>=<span class="string">".MainActivity"</span></div><div class="line">    <span class="attr">android:windowSoftInputMode</span>=<span class="string">"adjustPan|stateHidden"</span></div><div class="line">    <span class="attr">android:label</span>=<span class="string">"@string/app_name"</span>&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.MAIN"</span> /&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.LAUNCHER"</span> /&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></div></pre></td></tr></table></figure>
<hr>
<h2 id="【参考资料】"><a href="#【参考资料】" class="headerlink" title="【参考资料】"></a><strong>【参考资料】</strong></h2><p>1、<a href="http://blog.csdn.net/wurensen/article/details/21018115" target="_blank" rel="external">关于AlertDialog中EditText不能弹出输入法解决方法</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;&lt;strong&gt;摘要&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;AlertDialog中加入EditText但是不弹出软键盘等问题网上有很多不管用的解决方案，有的方案是&lt;strong&gt;强制弹出软键盘&lt;/strong&gt;，然而即使弹出来，也是显示在AlertDialog的后面，被Dialog遮挡。&lt;/p&gt;
&lt;h2 id=&quot;解决方案&quot;&gt;&lt;a href=&quot;#解决方案&quot; class=&quot;headerlink&quot; title=&quot;解决方案&quot;&gt;&lt;/a&gt;&lt;strong&gt;解决方案&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;Dialog的官方文档：&lt;a href=&quot;http://developer.android.com/reference/android/app/Dialog.html&quot;&gt;http://developer.android.com/reference/android/app/Dialog.html&lt;/a&gt; ，其中有一段：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; Activities provide a facility to manage the creation, saving and restoring of dialogs. See &lt;a href=&quot;https://developer.android.com/reference/android/app/Activity.html#onCreateDialog%28int%29&quot;&gt;onCreateDialog(int)&lt;/a&gt;, &lt;a href=&quot;https://developer.android.com/reference/android/app/Activity.html#onPrepareDialog%28int,%20android.app.Dialog%29&quot;&gt;onPrepareDialog(int, Dialog)&lt;/a&gt;, &lt;a href=&quot;https://developer.android.com/reference/android/app/Activity.html#showDialog%28int%29&quot;&gt;showDialog(int)&lt;/a&gt;, and &lt;a href=&quot;https://developer.android.com/reference/android/app/Activity.html#dismissDialog%28int%29&quot;&gt;dismissDialog(int)&lt;/a&gt;. If these methods are used, &lt;a href=&quot;https://developer.android.com/reference/android/app/Dialog.html#getOwnerActivity%28%29&quot;&gt;getOwnerActivity()&lt;/a&gt; will return the Activity that managed this dialog.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Android" scheme="http://github.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://github.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>【Android】TextView中不同大小字体如何上下垂直居中？</title>
    <link href="http://github.com/2017/01/03/%E3%80%90Android%E3%80%91TextView%E4%B8%AD%E4%B8%8D%E5%90%8C%E5%A4%A7%E5%B0%8F%E5%AD%97%E4%BD%93%E5%A6%82%E4%BD%95%E4%B8%8A%E4%B8%8B%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%EF%BC%9F/"/>
    <id>http://github.com/2017/01/03/【Android】TextView中不同大小字体如何上下垂直居中？/</id>
    <published>2017-01-03T09:03:00.000Z</published>
    <updated>2017-01-03T09:51:40.715Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>在客户端开发中，我们往往需要对一个TextView的文字的部分内容进行特殊化处理，比如加粗、改变颜色、加链接、下划线等。iOS为我们提供了<code>AttributedString</code>，而Android则提供了<strong><code>SpannableString</code></strong>。</p>
<p>在Android的android.text.style包下为我们提供了各种各样的span（可以<a href="http://blog.csdn.net/u010983881/article/details/52383539" target="_blank" rel="external"><strong>参考这篇文章</strong></a>），例如：</p>
<ul>
<li><p><strong>AbsoluteSizeSpan(int size)</strong> —— 设置字体大小，参数是绝对数值，相当于Word中的字体大小</p>
</li>
<li><p><strong>RelativeSizeSpan(float proportion)</strong> —— 设置字体大小，参数是相对于默认字体大小的倍数，比如默认字体大小是x, 那么设置后的字体大小就是x*proportion，这个用起来比较灵活，proportion&gt;1就是放大(zoom in), proportion&lt;1就是缩小(zoom out)</p>
</li>
<li><p><strong>BackgroundColorSpan(int color)</strong> —— 背景着色，参数是颜色数值，可以直接使用android.graphics.Color里面定义的常量，或是用Color.rgb(int, int, int)</p>
</li>
<li><p><strong>ForegroundColorSpan(int color)</strong> —— 前景着色，也就是字的着色，参数与背景着色一致</p>
</li>
</ul>
<a id="more"></a>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a><strong>问题</strong></h2><p>网上已经有着很多使用这些span的教程了，所以没必要在这里继续探讨这些基础使用了。但是，如果使用了<strong><code>AbsoluteSizeSpan(int size)</code></strong> 在同一个TextView中定义了不同字体大小，就会默认显示成底部对齐的方式：</p>
<p><img src="/gallery/Textview-vertical/not.png" alt=""></p>
<p>说到这里，第一反应肯定是<code>tv.setGravity(Gravity.CENTER_VERTICAL)</code>，但是很不幸，怎么试都不凑效。那么到底有没有办法使用Span让不同字体大小的垂直居中呢？</p>
<p>答案是：<strong>当然可以，得用<code>ReplacementSpan</code></strong></p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a><strong>分析</strong></h2><h3 id="为何是ReplacementSpan？"><a href="#为何是ReplacementSpan？" class="headerlink" title="为何是ReplacementSpan？"></a><strong>为何是ReplacementSpan？</strong></h3><p>它是系统提供给我们的一个抽象类。通过名字我们可以知道其实用于是用于替换。指示我们<strong>可以把文本的某一部分替换成我们想要的内容</strong>。这也许是我们想要的。</p>
<p><code>Relpacement</code>的定义很简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ReplacementSpan</span> <span class="keyword">extends</span> <span class="title">MetricAffectingSpan</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">(Paint paint, CharSequence text, <span class="keyword">int</span> start, <span class="keyword">int</span> end, Paint.FontMetricsInt fm)</span></span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(Canvas canvas, CharSequence text, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">float</span> x, <span class="keyword">int</span> top, <span class="keyword">int</span> y, <span class="keyword">int</span> bottom, Paint paint)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateMeasureState</span><span class="params">(TextPaint p)</span> </span>&#123; &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateDrawState</span><span class="params">(TextPaint ds)</span> </span>&#123; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们在继承它的时候，需要实现两个方法<code>getSize()</code>和<code>draw()</code>。通过方法名，我们也许能够知道其作用：<code>getSize()</code>用于确定span的大小（实际上只是一个宽度），<code>draw()</code>用于绘制我们想要的内容。</p>
<p>但是问题来了，这些方法的传参是什么？<strong>为何<code>getSize()</code>只返回了一个int值？</strong></p>
<p>了解了这两个问题，就基本弄懂了自定义span。来回答这两个问题前，我们首先要明确的一件事情是：span是用于<code>SpannableString</code>中，并且最终被用于<code>TextView</code>中。所以在定义span时，我们的大小、绘制内容都应该依赖于使用时的环境。我们假设自定义span使用的环境为A,那么A将包换一些信息，例如：<code>baseline</code>、<code>Paint</code>、<code>FontMetricsInt</code>等信息。</p>
<p>那我们现在来看看<code>getSize()</code>方法。<code>getSize()</code>的返回值是int，其实这个值指的是自定义span的宽度，那它的高度呢？其实高度是已知的，那就是外界环境A带来的字的高度。但我某些情况我们希望改变span的高度，我们该怎么做呢？ 如果对Android上字体绘制有一定了解的同学会知道，一个字的高度取决于绘制这个子的<strong><code>Paint.FontMetricsInt</code></strong></p>
<h3 id="什么是-Paint-FontMetrics"><a href="#什么是-Paint-FontMetrics" class="headerlink" title="什么是 Paint.FontMetrics"></a><strong>什么是 Paint.FontMetrics</strong></h3><p>它表示绘制字体时的度量标准。google的官方api文档对它的字段说明如下：</p>
<table>
<thead>
<tr>
<th>Type</th>
<th style="text-align:left">Fields</th>
</tr>
</thead>
<tbody>
<tr>
<td>public float</td>
<td style="text-align:left"><strong>ascent</strong> - The recommended distance above the baseline for singled spaced text.</td>
</tr>
<tr>
<td>public float</td>
<td style="text-align:left"><strong>bottom</strong> - The maximum distance below the baseline for the lowest glyph in the font at a given text size.</td>
</tr>
<tr>
<td>public float</td>
<td style="text-align:left"><strong>descent</strong> - The recommended distance below the baseline for singled spaced text.</td>
</tr>
<tr>
<td>public float</td>
<td style="text-align:left"><strong>leading</strong> - The recommended additional space to add between lines of text.</td>
</tr>
<tr>
<td>public float</td>
<td style="text-align:left"><strong>top</strong> - The maximum distance above the baseline for the tallest glyph in the font at a given text size.</td>
</tr>
</tbody>
</table>
<p>其中：</p>
<ul>
<li><strong>ascent</strong> : 字体最上端到基线的距离，为负值。</li>
<li><strong>descent</strong>：字体最下端到基线的距离，为正值。</li>
</ul>
<p><img src="/gallery/Textview-vertical/FontMetricsInt.png" alt=""></p>
<p>如上图，中间那条线（Baseline）就是基线，基线到上面那条线的距离就是<code>ascent</code>，基线到下面那条线的距离就是<code>descent</code>。</p>
<p>回到我们的主题， 我们发现<code>getSize()</code>方法的参数中有<code>Paint.FontMetricsInt</code>，那我们是否就可以通过改变传入的Paint.FontMetricsInt的<code>asent</code>和<code>desent</code>来达到改变高度的目的呢？答案是可行的。</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a><strong>解决方法</strong></h2><p>按照上面的分析，我们继承<code>ReplacementSpan</code> 自定义一个Span</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 使TextView中不同大小字体垂直居中</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomVerticalCenterSpan</span> <span class="keyword">extends</span> <span class="title">ReplacementSpan</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> fontSizeSp;    <span class="comment">//字体大小sp</span></div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">CustomVerticalCenterSpan</span><span class="params">(<span class="keyword">int</span> fontSizeSp)</span></span>&#123;</div><div class="line">		<span class="keyword">this</span>.fontSizeSp = fontSizeSp;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">(Paint paint, CharSequence text, <span class="keyword">int</span> start, <span class="keyword">int</span> end, Paint.FontMetricsInt fm)</span> </span>&#123;</div><div class="line">		text = text.subSequence(start, end);</div><div class="line">		Paint p = getCustomTextPaint(paint);</div><div class="line">		<span class="keyword">return</span> (<span class="keyword">int</span>) p.measureText(text.toString());</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(Canvas canvas, CharSequence text, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">float</span> x, <span class="keyword">int</span> top, <span class="keyword">int</span> y, <span class="keyword">int</span> bottom, Paint paint)</span> </span>&#123;</div><div class="line">		text = text.subSequence(start, end);</div><div class="line">		Paint p = getCustomTextPaint(paint);</div><div class="line">		Paint.FontMetricsInt fm = p.getFontMetricsInt();</div><div class="line">		canvas.drawText(text.toString(), x, y - ((y + fm.descent + y + fm.ascent) / <span class="number">2</span> - (bottom + top) / <span class="number">2</span>), p);    <span class="comment">//此处重新计算y坐标，使字体居中</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">private</span> TextPaint <span class="title">getCustomTextPaint</span><span class="params">(Paint srcPaint)</span> </span>&#123;</div><div class="line">		TextPaint paint = <span class="keyword">new</span> TextPaint(srcPaint);</div><div class="line">		paint.setTextSize(ViewUtils.getSpPixel(mContext, fontSizeSp));   <span class="comment">//设定字体大小, sp转换为px</span></div><div class="line">		<span class="keyword">return</span> paint;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>解释下形参：</p>
<ul>
<li><strong>x</strong>：要绘制的image的左边框到textview左边框的距离。</li>
<li><strong>y</strong>：要替换的文字的基线（Baseline）的纵坐标。</li>
<li><strong>top</strong>：替换行的最顶部位置。</li>
<li><strong>bottom</strong>：替换行的最底部位置。注意，textview中两行之间的行间距是属于上一行的，所以这里bottom是指行间隔的底部位置。</li>
<li><strong>paint</strong>：画笔，包含了要绘制字体的度量信息。</li>
</ul>
<p>所以就有：</p>
<ul>
<li><code>y + fm.descent</code>：得到字体的<code>descent</code>线坐标；<br> <code>y + fm.ascent</code>：得到字体的<code>ascent</code>线坐标；</li>
</ul>
<p><code>(y + fm.descent + y + fm.ascent) / 2</code> 也就是字体中间线的纵坐标</p>
<p><code>((y + fm.descent + y + fm.ascent) / 2 - (bottom + top) / 2)</code> 就是字体需要向上调整的距离</p>
<h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a><strong>使用方式</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">SpannableString ss = <span class="keyword">new</span> SpannableString(disStr + unitString);</div><div class="line"></div><div class="line">ss.setSpan(<span class="keyword">new</span> AbsoluteSizeSpan(<span class="number">40</span>, <span class="keyword">true</span>), <span class="number">0</span>, disStr.length(), Spannable.SPAN_EXCLUSIVE_INCLUSIVE);</div><div class="line"><span class="comment">//垂直居中显示文字</span></div><div class="line">ss.setSpan(<span class="keyword">new</span> CustomVerticalCenterSpan(<span class="number">23</span>), disStr.length(), ss.length(), Spannable.SPAN_EXCLUSIVE_INCLUSIVE);</div></pre></td></tr></table></figure>
<p>看看效果：</p>
<p><img src="/gallery/Textview-vertical/ok1.png" alt=""></p>
<p><img src="/gallery/Textview-vertical/ok2.png" alt=""></p>
<hr>
<h3 id="【参考资料】"><a href="#【参考资料】" class="headerlink" title="【参考资料】"></a><strong>【参考资料】</strong></h3><ol>
<li><p><a href="http://stackoverflow.com/questions/36964034/how-to-make-relativesizespan-align-to-top" target="_blank" rel="external">How to make RelativeSizeSpan align to top？</a> </p>
<p><img src="http://img.blog.csdn.net/20170103153457771?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDk4Mzg4MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
</li>
<li><p><a href="http://stackoverflow.com/questions/23990381/how-to-create-vertically-aligned-superscript-and-subscript-in-textview" target="_blank" rel="external">How to create vertically aligned superscript and subscript in TextView</a></p>
<p><img src="http://img.blog.csdn.net/20170103153252987?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDk4Mzg4MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
</li>
<li><p><a href="http://blog.cgsdream.org/2016/07/06/custom-android-span/" target="_blank" rel="external">教你自定义android中span</a></p>
</li>
<li><p><a href="http://www.cnblogs.com/withwind318/p/5541267.html" target="_blank" rel="external">Android ImageSpan与TextView中的text居中对齐问题解决（无论TextView设置行距与否）</a></p>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;在客户端开发中，我们往往需要对一个TextView的文字的部分内容进行特殊化处理，比如加粗、改变颜色、加链接、下划线等。iOS为我们提供了&lt;code&gt;AttributedString&lt;/code&gt;，而Android则提供了&lt;strong&gt;&lt;code&gt;SpannableString&lt;/code&gt;&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在Android的android.text.style包下为我们提供了各种各样的span（可以&lt;a href=&quot;http://blog.csdn.net/u010983881/article/details/52383539&quot;&gt;&lt;strong&gt;参考这篇文章&lt;/strong&gt;&lt;/a&gt;），例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;AbsoluteSizeSpan(int size)&lt;/strong&gt; —— 设置字体大小，参数是绝对数值，相当于Word中的字体大小&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;RelativeSizeSpan(float proportion)&lt;/strong&gt; —— 设置字体大小，参数是相对于默认字体大小的倍数，比如默认字体大小是x, 那么设置后的字体大小就是x*proportion，这个用起来比较灵活，proportion&amp;gt;1就是放大(zoom in), proportion&amp;lt;1就是缩小(zoom out)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;BackgroundColorSpan(int color)&lt;/strong&gt; —— 背景着色，参数是颜色数值，可以直接使用android.graphics.Color里面定义的常量，或是用Color.rgb(int, int, int)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;ForegroundColorSpan(int color)&lt;/strong&gt; —— 前景着色，也就是字的着色，参数与背景着色一致&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Android" scheme="http://github.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://github.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>【Java】泛型中 extends 和 super 的区别？</title>
    <link href="http://github.com/2016/12/27/%E3%80%90Java%E3%80%91%E6%B3%9B%E5%9E%8B%E4%B8%AD%20extends%20%E5%92%8C%20super%20%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F/"/>
    <id>http://github.com/2016/12/27/【Java】泛型中 extends 和 super 的区别？/</id>
    <published>2016-12-27T06:46:00.000Z</published>
    <updated>2017-06-16T10:27:21.325Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/gallery/java-genericity/example.png" alt=""></p>
<p><code>&lt;? extends T&gt;</code>和<code>&lt;? super T&gt;</code>是Java泛型中的<strong>“通配符（Wildcards）”</strong>和<strong>“边界（Bounds）”</strong>的概念。</p>
<ul>
<li><code>&lt;? extends T&gt;</code>：是指 <strong>“上界通配符（Upper Bounds Wildcards）”</strong></li>
<li><code>&lt;? super T&gt;</code>：是指 <strong>“下界通配符（Lower Bounds Wildcards）”</strong></li>
</ul>
<h2 id="为什么要用通配符和边界？"><a href="#为什么要用通配符和边界？" class="headerlink" title="为什么要用通配符和边界？"></a><strong>为什么要用通配符和边界？</strong></h2><p>使用泛型的过程中，经常出现一种很别扭的情况。比如按照题主的例子，我们有Fruit类，和它的派生类Apple类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fruit</span> </span>&#123;&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">extends</span> <span class="title">Fruit</span> </span>&#123;&#125;</div></pre></td></tr></table></figure>
<p>然后有一个最简单的容器：Plate类。盘子里可以放一个泛型的“东西”。我们可以对这个东西做最简单的“放”和“取”的动作：<code>set( )</code>和<code>get( )</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Plate</span>&lt;<span class="title">T</span>&gt;</span>&#123;</div><div class="line">    <span class="keyword">private</span> T item;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Plate</span><span class="params">(T t)</span></span>&#123;item=t;&#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T t)</span></span>&#123;item=t;&#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> item;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>现在我定义一个“水果盘子”，逻辑上水果盘子当然可以装苹果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Plate&lt;Fruit&gt; p=<span class="keyword">new</span> Plate&lt;Apple&gt;(<span class="keyword">new</span> Apple());</div></pre></td></tr></table></figure>
<p>但实际上Java编译器不允许这个操作。会报错，“装苹果的盘子”无法转换成“装水果的盘子”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">error: incompatible types: Plate&lt;Apple&gt; cannot be converted to Plate&lt;Fruit&gt;</div></pre></td></tr></table></figure>
<p>所以我的尴尬症就犯了。实际上，编译器脑袋里认定的逻辑是这样的：</p>
<ul>
<li>苹果 IS-A 水果</li>
<li>装苹果的盘子 NOT-IS-A 装水果的盘子</li>
</ul>
<p>所以，就算容器里装的东西之间有继承关系，但容器之间是没有继承关系的。所以我们不可以把Plate的引用传递给Plate。</p>
<p>为了让泛型用起来更舒服，Sun的大脑袋们就想出了<code>&lt;? extends T&gt;</code>和<code>&lt;? super T&gt;</code>的办法，来让“水果盘子”和“苹果盘子”之间发生关系。</p>
<h2 id="什么是上界？"><a href="#什么是上界？" class="headerlink" title="什么是上界？"></a><strong>什么是上界？</strong></h2><p>下面代码就是“上界通配符（Upper Bounds Wildcards）”：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Plate&lt;？ extends Fruit&gt;</div></pre></td></tr></table></figure>
<p>翻译成人话就是：一个能放水果以及一切是水果派生类的盘子。再直白点就是：啥水果都能放的盘子。这和我们人类的逻辑就比较接近了。<code>Plate&lt;？ extends Fruit&gt;</code>和<code>Plate&lt;Apple&gt;</code>最大的区别就是：<code>Plate&lt;？ extends Fruit&gt;</code>是<code>Plate&lt;Fruit&gt;</code>以及<code>Plate&lt;Apple&gt;</code>的基类。直接的好处就是，我们可以用“苹果盘子”给“水果盘子”赋值了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Plate&lt;? extends Fruit&gt; p=<span class="keyword">new</span> Plate&lt;Apple&gt;(<span class="keyword">new</span> Apple());</div></pre></td></tr></table></figure>
<p>如果把Fruit和Apple的例子再扩展一下，食物分成水果和肉类，水果有苹果和香蕉，肉类有猪肉和牛肉，苹果还有两种青苹果和红苹果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Lev 1</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Food</span></span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="comment">//Lev 2</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fruit</span> <span class="keyword">extends</span> <span class="title">Food</span></span>&#123;&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Meat</span> <span class="keyword">extends</span> <span class="title">Food</span></span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="comment">//Lev 3</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">extends</span> <span class="title">Fruit</span></span>&#123;&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Banana</span> <span class="keyword">extends</span> <span class="title">Fruit</span></span>&#123;&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pork</span> <span class="keyword">extends</span> <span class="title">Meat</span></span>&#123;&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Beef</span> <span class="keyword">extends</span> <span class="title">Meat</span></span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="comment">//Lev 4</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RedApple</span> <span class="keyword">extends</span> <span class="title">Apple</span></span>&#123;&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">GreenApple</span> <span class="keyword">extends</span> <span class="title">Apple</span></span>&#123;&#125;</div></pre></td></tr></table></figure>
<p>在这个体系中，下界通配符 <code>Plate&lt;？ extends Fruit&gt;</code> 覆盖下图中蓝色的区域。</p>
<p><img src="/gallery/java-genericity/lowerBounds.png" alt=""></p>
<h2 id="什么是下界？"><a href="#什么是下界？" class="headerlink" title="什么是下界？"></a><strong>什么是下界？</strong></h2><p>相对应的，“下界通配符（Lower Bounds Wildcards）”：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Plate&lt;？ <span class="keyword">super</span> Fruit&gt;</div></pre></td></tr></table></figure>
<p>表达的就是相反的概念：一个能放水果以及一切是水果基类的盘子。<code>Plate&lt;？ super Fruit&gt;</code>是<code>Plate&lt;Fruit&gt;</code>的基类，但不是<code>Plate&lt;Apple&gt;</code>的基类。对应刚才那个例子，<code>Plate&lt;？ super Fruit&gt;</code>覆盖下图中红色的区域。</p>
<p><img src="/gallery/java-genericity/upperBounds.png" alt=""></p>
<h2 id="上下界通配符的副作用"><a href="#上下界通配符的副作用" class="headerlink" title="上下界通配符的副作用"></a><strong>上下界通配符的副作用</strong></h2><p>边界让Java不同泛型之间的转换更容易了。但不要忘记，这样的转换也有一定的副作用。那就是容器的部分功能可能失效。</p>
<p>还是以刚才的Plate为例。我们可以对盘子做两件事，往盘子里set()新东西，以及从盘子里get()东西。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Plate</span>&lt;<span class="title">T</span>&gt;</span>&#123;</div><div class="line">    <span class="keyword">private</span> T item;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Plate</span><span class="params">(T t)</span></span>&#123;item=t;&#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T t)</span></span>&#123;item=t;&#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> item;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="上界-lt-extends-T-gt-不能往里存，只能往外取"><a href="#上界-lt-extends-T-gt-不能往里存，只能往外取" class="headerlink" title="上界&lt;? extends T&gt;不能往里存，只能往外取"></a>上界<code>&lt;? extends T&gt;</code>不能往里存，只能往外取</h3><p><code>&lt;? extends Fruit&gt;</code>会使往盘子里放东西的<code>set( )</code>方法失效。但取东西<code>get( )</code>方法还有效。比如下面例子里两个set()方法，插入Apple和Fruit都报错。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Plate&lt;? extends Fruit&gt; p=<span class="keyword">new</span> Plate&lt;Apple&gt;(<span class="keyword">new</span> Apple());</div><div class="line">	</div><div class="line"><span class="comment">//不能存入任何元素</span></div><div class="line">p.set(<span class="keyword">new</span> Fruit());    <span class="comment">//Error</span></div><div class="line">p.set(<span class="keyword">new</span> Apple());    <span class="comment">//Error</span></div><div class="line"></div><div class="line"><span class="comment">//读取出来的东西只能存放在Fruit或它的基类里。</span></div><div class="line">Fruit newFruit1=p.get();</div><div class="line">Object newFruit2=p.get();</div><div class="line">Apple newFruit3=p.get();    <span class="comment">//Error</span></div></pre></td></tr></table></figure>
<p>原因是编译器只知道容器内是Fruit或者它的派生类，但具体是什么类型不知道。可能是Fruit？可能是Apple？也可能是Banana，RedApple，GreenApple？编译器在看到后面用Plate赋值以后，盘子里没有被标上有“苹果”。而是标上一个占位符：CAP#1，来表示捕获一个Fruit或Fruit的子类，具体是什么类不知道，代号CAP#1。然后无论是想往里插入Apple或者Meat或者Fruit编译器都不知道能不能和这个CAP#1匹配，所以就都不允许。</p>
<p>所以通配符<code>&lt;?&gt;</code>和类型参数的区别就在于，对编译器来说所有的T都代表同一种类型。比如下面这个泛型方法里，三个T都指代同一个类型，要么都是String，要么都是Integer。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">fill</span><span class="params">(T... t)</span></span>;</div></pre></td></tr></table></figure>
<p>但通配符<code>&lt;?&gt;</code>没有这种约束，<code>Plate&lt;?&gt;</code>单纯的就表示：盘子里放了一个东西，是什么我不知道。</p>
<p>所以题主问题里的错误就在这里，<code>Plate&lt;？ extends Fruit&gt;</code>里什么都放不进去。</p>
<h3 id="下界-lt-super-T-gt-不影响往里存，但往外取只能放在Object对象里"><a href="#下界-lt-super-T-gt-不影响往里存，但往外取只能放在Object对象里" class="headerlink" title="下界&lt;? super T&gt;不影响往里存，但往外取只能放在Object对象里"></a>下界<code>&lt;? super T&gt;</code>不影响往里存，但往外取只能放在Object对象里</h3><p>使用下界<code>&lt;? super Fruit&gt;</code>会使从盘子里取东西的get( )方法部分失效，只能存放到Object对象里。set( )方法正常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Plate&lt;? <span class="keyword">super</span> Fruit&gt; p=<span class="keyword">new</span> Plate&lt;Fruit&gt;(<span class="keyword">new</span> Fruit());</div><div class="line"></div><div class="line"><span class="comment">//存入元素正常</span></div><div class="line">p.set(<span class="keyword">new</span> Fruit());</div><div class="line">p.set(<span class="keyword">new</span> Apple());</div><div class="line"></div><div class="line"><span class="comment">//读取出来的东西只能存放在Object类里。</span></div><div class="line">Apple newFruit3=p.get();    <span class="comment">//Error</span></div><div class="line">Fruit newFruit1=p.get();    <span class="comment">//Error</span></div><div class="line">Object newFruit2=p.get();</div></pre></td></tr></table></figure>
<p>因为下界规定了元素的最小粒度的下限，实际上是放松了容器元素的类型控制。既然元素是Fruit的基类，那往里存粒度比Fruit小的都可以。但往外读取元素就费劲了，只有所有类的基类Object对象才能装下。但这样的话，元素的类型信息就全部丢失。</p>
<h2 id="PECS原则"><a href="#PECS原则" class="headerlink" title="PECS原则"></a><strong>PECS原则</strong></h2><p>最后看一下什么是PECS（Producer Extends Consumer Super）原则，已经很好理解了：</p>
<ul>
<li><strong>频繁往外读取内容的，适合用上界Extends。</strong></li>
<li><strong>经常往里插入的，适合用下界Super。</strong></li>
</ul>
<hr>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://www.ciaoshen.com/2016/08/21/superExtends/" target="_blank" rel="external">Java泛型中extends和super的区别？</a></li>
</ul>
<hr>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/gallery/java-genericity/example.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;? extends T&amp;gt;&lt;/code&gt;和&lt;code&gt;&amp;lt;? super T&amp;gt;&lt;/code&gt;是Java泛型中的&lt;strong&gt;“通配符（Wildcards）”&lt;/strong&gt;和&lt;strong&gt;“边界（Bounds）”&lt;/strong&gt;的概念。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;? extends T&amp;gt;&lt;/code&gt;：是指 &lt;strong&gt;“上界通配符（Upper Bounds Wildcards）”&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;? super T&amp;gt;&lt;/code&gt;：是指 &lt;strong&gt;“下界通配符（Lower Bounds Wildcards）”&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;为什么要用通配符和边界？&quot;&gt;&lt;a href=&quot;#为什么要用通配符和边界？&quot; class=&quot;headerlink&quot; title=&quot;为什么要用通配符和边界？&quot;&gt;&lt;/a&gt;&lt;strong&gt;为什么要用通配符和边界？&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;使用泛型的过程中，经常出现一种很别扭的情况。比如按照题主的例子，我们有Fruit类，和它的派生类Apple类。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Fruit&lt;/span&gt; &lt;/span&gt;&amp;#123;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Apple&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Fruit&lt;/span&gt; &lt;/span&gt;&amp;#123;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后有一个最简单的容器：Plate类。盘子里可以放一个泛型的“东西”。我们可以对这个东西做最简单的“放”和“取”的动作：&lt;code&gt;set( )&lt;/code&gt;和&lt;code&gt;get( )&lt;/code&gt;方法。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Plate&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;T&lt;/span&gt;&amp;gt;&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; T item;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Plate&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(T t)&lt;/span&gt;&lt;/span&gt;&amp;#123;item=t;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(T t)&lt;/span&gt;&lt;/span&gt;&amp;#123;item=t;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; T &lt;span class=&quot;title&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; item;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Java" scheme="http://github.com/categories/Java/"/>
    
    
      <category term="Java Generics" scheme="http://github.com/tags/Java-Generics/"/>
    
  </entry>
  
</feed>
